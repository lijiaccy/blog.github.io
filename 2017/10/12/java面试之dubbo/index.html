<!DOCTYPE html>



  


<html class="theme-next mist use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.3" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.3">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.3">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.3">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.3" color="#222">





  <meta name="keywords" content="面试," />





  <link rel="alternate" href="/atom.xml" title="LiJia's Dream" type="application/atom+xml" />






<meta name="description" content="什么是dubbodubbo是一个分布式框架，远程服务调用的分布式框架，其核心部分包含： **集群容错**：提供基于接口方法的透明远程过程调用，包括多协议支持，以及软负载均衡，失败容错，地址路由，动态配置等集群支持。 **远程通讯**： 提供对多种基于长连接的NIO框架抽象封装，包括多种线程模型，序列化，以及“请求-响应”模式的信息交换方式。 **自动发现**：基于注册中心目录服务，使服务消费方能动">
<meta name="keywords" content="面试">
<meta property="og:type" content="article">
<meta property="og:title" content="java面试之dubbo">
<meta property="og:url" content="http://yoursite.com/2017/10/12/java面试之dubbo/index.html">
<meta property="og:site_name" content="LiJia&#39;s Dream">
<meta property="og:description" content="什么是dubbodubbo是一个分布式框架，远程服务调用的分布式框架，其核心部分包含： **集群容错**：提供基于接口方法的透明远程过程调用，包括多协议支持，以及软负载均衡，失败容错，地址路由，动态配置等集群支持。 **远程通讯**： 提供对多种基于长连接的NIO框架抽象封装，包括多种线程模型，序列化，以及“请求-响应”模式的信息交换方式。 **自动发现**：基于注册中心目录服务，使服务消费方能动">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="http://upload-images.jianshu.io/upload_images/4714843-cf0490f060ccfde3.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
<meta property="og:image" content="http://upload-images.jianshu.io/upload_images/4714843-3b81e7478679f974.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
<meta property="og:image" content="http://upload-images.jianshu.io/upload_images/4714843-b291b025f16e3947.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
<meta property="og:image" content="http://upload-images.jianshu.io/upload_images/4714843-9ba8e7f6f9047f8a.gif?imageMogr2/auto-orient/strip">
<meta property="og:updated_time" content="2017-10-24T01:26:08.546Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="java面试之dubbo">
<meta name="twitter:description" content="什么是dubbodubbo是一个分布式框架，远程服务调用的分布式框架，其核心部分包含： **集群容错**：提供基于接口方法的透明远程过程调用，包括多协议支持，以及软负载均衡，失败容错，地址路由，动态配置等集群支持。 **远程通讯**： 提供对多种基于长连接的NIO框架抽象封装，包括多种线程模型，序列化，以及“请求-响应”模式的信息交换方式。 **自动发现**：基于注册中心目录服务，使服务消费方能动">
<meta name="twitter:image" content="http://upload-images.jianshu.io/upload_images/4714843-cf0490f060ccfde3.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    version: '5.1.3',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2017/10/12/java面试之dubbo/"/>





  <title>java面试之dubbo | LiJia's Dream</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">LiJia's Dream</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">努力改掉懒惰的习惯！</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br />
            
            关于
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/10/12/java面试之dubbo/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="lijia">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LiJia's Dream">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">java面试之dubbo</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-10-12T09:00:16+08:00">
                2017-10-12
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/面试/" itemprop="url" rel="index">
                    <span itemprop="name">面试</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2017/10/12/java面试之dubbo/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count"
                        data-disqus-identifier="2017/10/12/java面试之dubbo/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h1 id="什么是dubbo"><a href="#什么是dubbo" class="headerlink" title="什么是dubbo"></a>什么是dubbo</h1><p>dubbo是一个分布式框架，远程服务调用的分布式框架，其核心部分包含：</p>
<pre><code>**集群容错**：提供基于接口方法的透明远程过程调用，包括多协议支持，以及软负载均衡，失败容错，地址路由，动态配置等集群支持。
**远程通讯**： 提供对多种基于长连接的NIO框架抽象封装，包括多种线程模型，序列化，以及“请求-响应”模式的信息交换方式。
**自动发现**：基于注册中心目录服务，使服务消费方能动态的查找服务提供方，使地址透明，使服务提供方可以平滑增加或减少机器。
</code></pre><h1 id="dubbo可以做什么"><a href="#dubbo可以做什么" class="headerlink" title="dubbo可以做什么"></a>dubbo可以做什么</h1><ul>
<li>透明化的远程方法调用，就像调用本地方法一样调用远程方法，只需简单配置，没有任何API侵入。</li>
<li>软负载均衡及容错机制，可在内网替代F5等硬件负载均衡器，降低成本，减少单点。</li>
<li>服务自动注册与发现，不再需要写死服务提供方地址，注册中心基于接口名查询服务提供者的IP地址，并且能够平滑添加或删除服务提供者。</li>
</ul>
<h1 id="dubbo的架构"><a href="#dubbo的架构" class="headerlink" title="dubbo的架构"></a>dubbo的架构</h1><p><img src="http://upload-images.jianshu.io/upload_images/4714843-cf0490f060ccfde3.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="dubbo架构图"></p>
<p><strong>图中节点角色说明：</strong><br><strong>Provider</strong>: 暴露服务的服务提供方。<br><strong>Consumer</strong>: 调用远程服务的服务消费方。<br><strong>Registry</strong>: 服务注册与发现的注册中心。<br><strong>Monitor</strong>: 统计服务的调用次调和调用时间的监控中心。<br><strong>Container</strong>: 服务运行容器。<br>对于这些角色来说，其他都还好，Monitor可能猿友们前期使用会把它忽略，但是后期会发现它的作用十分明显哦，如服务的调用量越来越大，服务的容量问题就暴露出来，这个服务需要多少机器支撑？什么时候该加机器？为了解决这个问题，第一步，要将服务现在每天的调用量，响应时间，都统计出来，作为容量规划的参考指标。其次，要可以动态调整权重，在线上，将某台机器的权重一直加大，并在加大的过程中记录响应时间的变化，直到响应时间到达阀值，记录此时的访问量，再以此访问量乘以机器数反推总容量。</p>
<p><strong>调用关系说明：</strong><br>0 服务容器负责启动，加载，运行服务提供者。<br>1 服务提供者在启动时，向注册中心注册自己提供的服务。<br>2 服务消费者在启动时，向注册中心订阅自己所需的服务。<br>3 注册中心返回服务提供者地址列表给消费者，如果有变更，注册中心将基于长连接推送变更数据给消费者。<br>4 服务消费者，从提供者地址列表中，基于软负载均衡算法，选一台提供者进行调用，如果调用失败，再选另一台调用。<br>5 服务消费者和提供者，在内存中累计调用次数和调用时间，定时每分钟发送一次统计数据到监控中心。</p>
<h1 id="dubbo的使用"><a href="#dubbo的使用" class="headerlink" title="dubbo的使用"></a>dubbo的使用</h1><h2 id="框架的搭建"><a href="#框架的搭建" class="headerlink" title="框架的搭建"></a>框架的搭建</h2><p>自己去google，有的博客讲的特别细。有的会在部署中出问题，有的会在打包出问题，这个需要多google去解决</p>
<h1 id="dubbo的一些面试题"><a href="#dubbo的一些面试题" class="headerlink" title="dubbo的一些面试题"></a>dubbo的一些面试题</h1><h2 id="dubbo默认使用什么通信协议"><a href="#dubbo默认使用什么通信协议" class="headerlink" title="dubbo默认使用什么通信协议"></a>dubbo默认使用什么通信协议</h2><p>dubbo共支持如下几种通信协议：</p>
<ul>
<li>dubbo://    <strong>Dubbo缺省协议采用单一长连接和NIO异步通讯，适合于小数据量大并发的服务调用，以及服务消费者机器数远大于服务提供者机器数的情况。</strong></li>
<li>rmi://  <strong>RMI协议采用JDK标准的java.rmi.*实现，采用阻塞式短连接和JDK标准序列化方式</strong></li>
<li>hessian://</li>
<li>http://</li>
<li>webservice://</li>
<li>thrift://</li>
<li>memcached://</li>
<li>redis://</li>
</ul>
<h2 id="服务调用超时问题怎么解决"><a href="#服务调用超时问题怎么解决" class="headerlink" title="服务调用超时问题怎么解决"></a>服务调用超时问题怎么解决</h2><p>dubbo在调用服务不成功时，默认是会重试两次的。这样在服务端的处理时间超过了设定的超时时间时，就会有重复请求，比如在发邮件时，可能就会发出多份重复邮件，执行注册请求时，就会插入多条重复的注册数据，那么怎么解决超时问题呢？<br><strong>1.对于核心的服务中心，去除dubbo超时重试机制，并重新评估设置超时时间。</strong><br><strong>2.业务处理代码必须放在服务端，客户端只做参数验证和服务调用，不涉及业务流程处理</strong><br>代码配置：<br><code>&lt;dubbo:provider delay=&quot;-1&quot; timeout=&quot;6000&quot; retries=&quot;0&quot;/&gt;</code><br>当然Dubbo的重试机制其实是非常好的QOS保证，它的路由机制，是会帮你把超时的请求路由到其他机器上，而不是本机尝试，所以 dubbo的重试机器也能一定程度的保证服务的质量。但是请一定要综合线上的访问情况，给出综合的评估。</p>
<h2 id="一般使用什么注册中心，还有其他的选择吗？"><a href="#一般使用什么注册中心，还有其他的选择吗？" class="headerlink" title="一般使用什么注册中心，还有其他的选择吗？"></a>一般使用什么注册中心，还有其他的选择吗？</h2><pre><code>Multicast注册中心
Zookeeper注册中心
Redis注册中心
Simple注册中心
</code></pre><p>正常情况下我们使用zookeeper注册中心<br><img src="http://upload-images.jianshu.io/upload_images/4714843-3b81e7478679f974.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="ZooKeeper层次命名空间"></p>
<p> ZooKeeper的节点是通过像树一样的结构来进行维护的，并且每一个节点通过路径来标示以及访问。除此之外，每一个节点还拥有自身的一些信息，包括：数据、数据长度、创建时间、修改时间等等。</p>
<p>从这样一类既含有数据，又作为路径表标示的节点的特点中，可以看出，ZooKeeper的节点既可以被看做是一个文件，又可以被看做是一个目录，它同时具有二者的特点。为了简单我们可以Znode来表示所讨论的ZooKeeper节点。</p>
<p>具体地说，Znode维护着数据、ACL（access controllist，访问控制列表）、时间戳等交换版本号等数据结构，它通过对这些数据的管理来让缓存生效并且令协调更新。每当Znode中的数据更新后它所维护的版本号将增加，这非常类似于数据库中计数器时间戳的操作方式。</p>
<p>另外Znode还具有原子性操作的特点：命名空间中，每一个Znode的数据将被原子地读写。读操作将读取与Znode相关的所有数据，写操作将替换掉所有的数据。除此之外，每一个节点都有一个访问控制列表，这个访问控制列表规定了用户操作的权限。</p>
<p>ZooKeeper中同样存在临时节点。这些节点与session同时存在，当session生命周期结束，这些临时节点也将被删除。临时节点在某些场合也发挥着非常重要的作用。</p>
<p>了解了Zookeeper的命名空间和节点之后我们需要跟上一篇文章中提到的内部逻辑联系起来.在上篇介绍到的内部流程中,拿到这里看看Zookeeper是如何处理的,流程如下图:</p>
<p><img src="http://upload-images.jianshu.io/upload_images/4714843-b291b025f16e3947.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>1  当服务提供者启动时,Zookeeper向/dubbo/com.foo.BarService/providers目录下写入自己的URL地址。<br>2 当服务消费者启动时,这时候有两个动作:</p>
<pre><code>订阅/dubbo/com.foo.BarService/providers目录下的提供者URL地址。
并向/dubbo/com.foo.BarService/consumers目录下写入自己的URL地址。
</code></pre><p>  3当监控中心启动时,订阅/dubbo/com.foo.BarService目录下的所有提供者和消费者URL地址。</p>
<h2 id="默认使用什么序列化框架"><a href="#默认使用什么序列化框架" class="headerlink" title="默认使用什么序列化框架"></a>默认使用什么序列化框架</h2><p>Dubbo默认使用的是<strong>Hessian</strong>序列化。hessian是一个采用二进制格式传输的服务框架，相对传统soap web service，更轻量，更快速。</p>
<p><strong>Hessian原理与协议简析：</strong><br>http的协议约定了数据传输的方式，hessian也无法改变太多：</p>
<pre><code>1) hessian中client与server的交互，基于http-post方式。
2) hessian将辅助信息，封装在http header中，比如“授权token”等，我们可以基于http-header来封装关于“安全校验”“meta数据”等。hessian提供了简单的&quot;校验&quot;机制。
3) 对于hessian的交互核心数据，比如“调用的方法”和参数列表信息，将通过post请求的body体直接发送，格式为字节流。
4) 对于hessian的server端响应数据，将在response中通过字节流的方式直接输出。
</code></pre><p>   hessian的协议本身并不复杂，在此不再赘言；所谓协议(protocol)就是约束数据的格式，client按照协议将请求信息序列化成字节序列发送给server端，server端根据协议，将数据反序列化成“对象”，然后执行指定的方法，并将方法的返回值再次按照协议序列化成字节流，响应给client，client按照协议将字节流反序列话成”对象”。</p>
<h2 id="服务提供者能实现失效踢出的原理"><a href="#服务提供者能实现失效踢出的原理" class="headerlink" title="服务提供者能实现失效踢出的原理"></a>服务提供者能实现失效踢出的原理</h2><p><img src="http://upload-images.jianshu.io/upload_images/4714843-9ba8e7f6f9047f8a.gif?imageMogr2/auto-orient/strip" alt=""></p>
<p><strong>    ConfigServer（配置中心）</strong><br>每个Server/Client之间会作一个实时的心跳检测（因为它们都是建立的Socket长连接），比如几秒钟检测一次。收集每个Server提供的服务的信息，每个Client的信息，整理出一个服务列表，如：</p>
<table>
<thead>
<tr>
<th style="text-align:left">serviceName</th>
<th style="text-align:center">serverAddressList</th>
<th style="text-align:center">clientAddressList</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">UserService</td>
<td style="text-align:center">192.168.0.1，192.168.0.2，192.168.0.3，192.168.0.4</td>
<td style="text-align:center">172.16.0.1，172.16.0.2</td>
</tr>
<tr>
<td style="text-align:left">ProductService</td>
<td style="text-align:center">192.168.0.3，192.168.0.4，192.168.0.5，192.168.0.6</td>
<td style="text-align:center">172.16.0.2，172.16.0.3</td>
</tr>
<tr>
<td style="text-align:left">OrderService</td>
<td style="text-align:center">192.168.0.10，192.168.0.12，192.168.0.5，192.168.0.6</td>
<td style="text-align:center">172.16.0.3，172.16.0.4</td>
</tr>
</tbody>
</table>
<p>当某个Server不可用，那么就更新受影响的服务对应的serverAddressList，即把这个Server从serverAddressList中踢出去（从地址列表中删除），同时将推送serverAddressList给这些受影响的服务的clientAddressList里面的所有Client。如：192.168.0.3挂了，那么UserService和ProductService的serverAddressList都要把192.168.0.3删除掉，同时把新的列表告诉对应的Client 172.16.0.1，172.16.0.2，172.16.0.3；<br>当某个Client挂了，那么更新受影响的服务对应的clientAddressList<br>ConfigServer根据服务列表，就能提供一个web管理界面，来查看管理服务的提供者和使用者。<br>新加一个Server时，由于它会主动与ConfigServer取得联系，而ConfigServer又会将这个信息主动发送给Client，所以新加一个Server时，只需要启动Server，然后几秒钟内，Client就会使用上它提供的服务<br><strong>    Client（调用服务的机器）</strong></p>
<p>每个Client启动时，主动与ConfigServer建立Socket长连接，并将自己的IP等相应信息发送给ConfigServer。<br>Client在使用服务的时候根据服务名称去ConfigServer中获取服务提供者信息（这样ConfigServer就知道某个服务是当前哪几个Client在使用），Client拿到这些服务提供者信息后，与它们都建立连接，后面就可以直接调用服务了，当有多个服务提供者的时候，Client根据一定的规则来进行负载均衡，如轮询，随机，按权重等。<br>一旦Client使用的服务它对应的服务提供者有变化（服务提供者有新增，删除的情况），ConfigServer就会把最新的服务提供者列表推送给Client，Client就会依据最新的服务提供者列表重新建立连接，新增的提供者建立连接，删除的提供者丢弃连接</p>
<p><strong>    Server（真正提供服务的机器）</strong></p>
<p>每个Server启动时，主动与ConfigServer建立Scoket长连接，并将自己的IP，提供的服务名称，端口等信息直接发送给ConfigServer，ConfigServer就会收集到每个Server提供的服务的信息。</p>
<p>优点：</p>
<ul>
<li>只要在Client和Server启动的时候，ConfigServer是好的，服务就可调用了，如果后面ConfigServer挂了，那只影响ConfigServer挂了以后服务提供者有变化，而Client还无法感知这一变化。</li>
<li>Client每次调用服务是不经过ConfigServer的，Client只是与它建立联系，从它那里获取提供服务者列表而已</li>
<li>调用服务-负载均衡：Client调用服务时，可以根据规则在多个服务提供者之间轮流调用服务。</li>
<li>服务提供者-容灾：某一个Server挂了，Client依然是可以正确的调用服务的，当前提是这个服务有至少2个服务提供者，Client能很快的感知到服务提供者的变化，并作出相应反应。</li>
<li><p>服务提供者-扩展：添加一个服务提供者很容易，而且Client会很快的感知到它的存在并使用它。</p>
<h2 id="服务上线怎么不影响旧版本"><a href="#服务上线怎么不影响旧版本" class="headerlink" title="服务上线怎么不影响旧版本"></a>服务上线怎么不影响旧版本</h2><p>dubbo的文档中说到：</p>
<p>   当一个接口实现，出现不兼容升级时，可以用版本号过渡，版本号不同的服务相互间不引用。<br>   在低压力时间段，先升级一半提供者为新版本，再将所有消费者升级为新版本，然后将剩下的一半提供者升级为新版本</p>
<p>  <code>&lt;dubbo:service interface=&quot;com.foo.BarService&quot; version=&quot;1.0.0&quot; /&gt;</code><br> <code>&lt;dubbo:service interface=&quot;com.foo.BarService&quot; version=&quot;2.0.0&quot; /&gt;</code><br> <code>&lt;dubbo:reference id=&quot;barService&quot; interface=&quot;com.foo.BarService&quot; version=&quot;1.0.0&quot; /&gt;</code><br> <code>&lt;dubbo:reference id=&quot;barService&quot; interface=&quot;com.foo.BarService&quot; version=&quot;2.0.0&quot; /&gt;</code><br>  不区分版本：(2.2.0以上版本支持)<br>  <code>&lt;dubbo:reference id=&quot;barService&quot; interface=&quot;com.foo.BarService&quot; version=&quot;*&quot; /&gt;</code></p>
<h2 id="dubbo协议下的单一长连接与多线程并发如何协同工作"><a href="#dubbo协议下的单一长连接与多线程并发如何协同工作" class="headerlink" title="dubbo协议下的单一长连接与多线程并发如何协同工作"></a>dubbo协议下的单一长连接与多线程并发如何协同工作</h2><p>底层采用netty。</p>
<h2 id="集群容错怎么做"><a href="#集群容错怎么做" class="headerlink" title="集群容错怎么做"></a>集群容错怎么做</h2><p><strong>dubbo的容错方案</strong><br>当我们的系统中用到Dubbo的集群环境,因为各种原因在集群调用失败时，Dubbo提供了多种容错方案，缺省为failover重试。<br>Dubbo的集群容错在这里想说说他是因为我们实际的项目中出现了此类的问题,因为依赖的第三方项目出现异常,导致dubbo调用超时,此时使用的是默认的集群容错方式,而配置的reties=’3’,这样前段系统连续掉用了三次服务。</p>
</li>
</ul>
<p><strong>通过上面dubbo架构图</strong><br>这里的Invoker是Provider的一个可调用Service的抽象，Invoker封装了Provider地址及Service接口信息。<br>Directory代表多个Invoker，可以把它看成List<invoker>，但与List不同的是，它的值可能是动态变化的，比如注册中心推送变更。<br>Cluster将Directory中的多个Invoker伪装成一个Invoker，对上层透明，伪装过程包含了容错逻辑，调用失败后，重试另一个。<br>Router负责从多个Invoker中按路由规则选出子集，比如读写分离，应用隔离等。<br>LoadBalance负责从多个Invoker中选出具体的一个用于本次调用，选的过程包含了负载均衡算法，调用失败后，需要重选。<br><strong>集群容错模式：</strong><br><strong>Failover Cluster</strong><br>失败自动切换，当出现失败，重试其它服务器。(缺省)<br>通常用于读操作，但重试会带来更长延迟。<br>可通过retries=”2”来设置重试次数(不含第一次)。正是文章刚开始说的那种情况.<br><strong>Failfast Cluster</strong><br>快速失败，只发起一次调用，失败立即报错。<br>通常用于非幂等性的写操作，比如新增记录。<br><strong>Failsafe Cluster</strong><br>失败安全，出现异常时，直接忽略。<br>通常用于写入审计日志等操作。<br><strong>Failback Cluster</strong><br>失败自动恢复，后台记录失败请求，定时重发。<br>通常用于消息通知操作。<br><strong>Forking Cluster</strong><br>并行调用多个服务器，只要一个成功即返回。<br>通常用于实时性要求较高的读操作，但需要浪费更多服务资源。<br>可通过forks=”2”来设置最大并行数。<br><strong>Broadcast Cluster</strong><br>广播调用所有提供者，逐个调用，任意一台报错则报错。(2.1.0开始支持)<br>通常用于通知所有提供者更新缓存或日志等本地资源信息。<br>重试次数配置如：(failover集群模式生效)<br><code>&lt;dubbo:serviceretries=&quot;2&quot;/&gt;</code>或：<br><code>&lt;dubbo:referenceretries=&quot;2&quot;/&gt;</code>或：<br><code>&lt;dubbo:reference&gt;
             &lt;dubbo:methodname=&quot;findFoo&quot;retries=&quot;2&quot;/&gt;
     &lt;/dubbo:reference&gt;</code><br>     集群模式配置如：<br><code>&lt;dubbo:servicecluster=&quot;failsafe&quot;/&gt;</code><br>或：<code>&lt;dubbo:referencecluster=&quot;failsafe&quot;/&gt;</code></invoker></p>
<h2 id="dubbo是如何实现负载均衡"><a href="#dubbo是如何实现负载均衡" class="headerlink" title="dubbo是如何实现负载均衡"></a>dubbo是如何实现负载均衡</h2><p>dubbo负载均衡策略：<br>在集群负载均衡时，Dubbo提供了多种均衡策略，缺省为random随机调用。<br><strong>RandomLoadBalance</strong><br>随机，按权重设置随机概率。<br>在一个截面上碰撞的概率高，但调用量越大分布越均匀，而且按概率使用权重后也比较均匀，有利于动态调整提供者权重。<br><strong>RoundRobin LoadBalance</strong><br>轮循，按公约后的权重设置轮循比率。<br>存在慢的提供者累积请求问题，比如：第二台机器很慢，但没挂，当请求调到第二台时就卡在那，久而久之，所有请求都卡在调到第二台上。<br><strong>LeastActive LoadBalance</strong><br>最少活跃调用数，相同活跃数的随机，活跃数指调用前后计数差。<br>使慢的提供者收到更少请求，因为越慢的提供者的调用前后计数差会越大。<br><strong>ConsistentHashLoadBalance</strong><br>一致性Hash，相同参数的请求总是发到同一提供者。<br>当某一台提供者挂时，原本发往该提供者的请求，基于虚拟节点，平摊到其它提供者，不会引起剧烈变动。<br>Dubbo的集群容错和负载均衡同样也是Dubbo本身的高级特性.正如我们在说自定义扩展的时候一样,这两个特征同样也可以进行自定义扩展,用户可以根据自己实际的需求来扩展他们从而满足项目的实际需求.</p>
<h2 id="遇到的问题"><a href="#遇到的问题" class="headerlink" title="遇到的问题"></a>遇到的问题</h2><p>场景描述：客户端远程异步调用ServiceA，ServiceA在处理客户端请求的过程中需要远程同步调用ServiceB，ServiceA从ServiceB的响应中取数据时，得到的是null。<br>对于上面的问题，解决办法有三个：<br>1.方法调用两次</p>
<pre><code>ServiceA调用ServiceB的地方写两次一样的调用，这个方法原理就像ServiceB调用ServiceC一样，即清除attachements。
这个方法最简单，但是可能对不了解的人来说，这块业务代码写重复了，会不小心删除掉，而且从写代码的角度来说，这个很鸡肋，所以不推荐。
</code></pre><p>2.修改Dubbo源码<br> 修改AbstractInvoker第137行，改成每次都对async进行实际赋值，</p>
<pre><code>boolean isAsync = getUrl().getMethodParameter(invocation.getMethodName(), Constants.ASYNC_KEY, false);
invocation.setAttachment(Constants.ASYNC_KEY, String.valueOf(isAsync));
</code></pre><p>3.自定义Filter<br>实现com.alibaba.dubbo.rpc.Filter，在RpcContext中清除这个async，</p>
<pre><code>@Activate(group = {Constants.PROVIDER})
 public class AsyncFilter implements Filter {
@Override
public Result invoke(Invoker&lt;?&gt; invoker, Invocation invocation) throws RpcException {
    RpcContext.getContext().getAttachments().remove(Constants.ASYNC_KEY);
return invoker.invoke(invocation);
}
}
</code></pre><p> 同时在src/main/resources/META-INF/dubbo/下添加com.alibaba.dubbo.rpc.Filter文件，内容文件如下：<br>     asyncFilter=com.abc.filter.AsyncFilter<br>根据n多的博客整理出来的一些，以后有其他东西再加进去</p>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/面试/" rel="tag"># 面试</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2017/10/11/Channel/" rel="next" title="Channel">
                <i class="fa fa-chevron-left"></i> Channel
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2017/10/12/Selector/" rel="prev" title="Selector">
                Selector <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  
    <div class="comments" id="comments">
      <div id="disqus_thread">
        <noscript>
          Please enable JavaScript to view the
          <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a>
        </noscript>
      </div>
    </div>

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">lijia</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives">
              
                  <span class="site-state-item-count">22</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">5</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">7</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          
            <div class="feed-link motion-element">
              <a href="/atom.xml" rel="alternate">
                <i class="fa fa-rss"></i>
                RSS
              </a>
            </div>
          

          <div class="links-of-author motion-element">
            
          </div>

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#什么是dubbo"><span class="nav-number">1.</span> <span class="nav-text">什么是dubbo</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#dubbo可以做什么"><span class="nav-number">2.</span> <span class="nav-text">dubbo可以做什么</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#dubbo的架构"><span class="nav-number">3.</span> <span class="nav-text">dubbo的架构</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#dubbo的使用"><span class="nav-number">4.</span> <span class="nav-text">dubbo的使用</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#框架的搭建"><span class="nav-number">4.1.</span> <span class="nav-text">框架的搭建</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#dubbo的一些面试题"><span class="nav-number">5.</span> <span class="nav-text">dubbo的一些面试题</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#dubbo默认使用什么通信协议"><span class="nav-number">5.1.</span> <span class="nav-text">dubbo默认使用什么通信协议</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#服务调用超时问题怎么解决"><span class="nav-number">5.2.</span> <span class="nav-text">服务调用超时问题怎么解决</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#一般使用什么注册中心，还有其他的选择吗？"><span class="nav-number">5.3.</span> <span class="nav-text">一般使用什么注册中心，还有其他的选择吗？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#默认使用什么序列化框架"><span class="nav-number">5.4.</span> <span class="nav-text">默认使用什么序列化框架</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#服务提供者能实现失效踢出的原理"><span class="nav-number">5.5.</span> <span class="nav-text">服务提供者能实现失效踢出的原理</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#服务上线怎么不影响旧版本"><span class="nav-number">5.6.</span> <span class="nav-text">服务上线怎么不影响旧版本</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#dubbo协议下的单一长连接与多线程并发如何协同工作"><span class="nav-number">5.7.</span> <span class="nav-text">dubbo协议下的单一长连接与多线程并发如何协同工作</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#集群容错怎么做"><span class="nav-number">5.8.</span> <span class="nav-text">集群容错怎么做</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#dubbo是如何实现负载均衡"><span class="nav-number">5.9.</span> <span class="nav-text">dubbo是如何实现负载均衡</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#遇到的问题"><span class="nav-number">5.10.</span> <span class="nav-text">遇到的问题</span></a></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2017</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">lijia</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Mist</a> v5.1.3</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.3"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.3"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.3"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.3"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.3"></script>



  


  

    
      <script id="dsq-count-scr" src="https://lijiaccy.disqus.com/count.js" async></script>
    

    
      <script type="text/javascript">
        var disqus_config = function () {
          this.page.url = 'http://yoursite.com/2017/10/12/java面试之dubbo/';
          this.page.identifier = '2017/10/12/java面试之dubbo/';
          this.page.title = 'java面试之dubbo';
        };
        var d = document, s = d.createElement('script');
        s.src = 'https://lijiaccy.disqus.com/embed.js';
        s.setAttribute('data-timestamp', '' + +new Date());
        (d.head || d.body).appendChild(s);
      </script>
    

  




	





  














  





  

  

  
  

  

  

  

</body>
</html>
