<!DOCTYPE html>



  


<html class="theme-next mist use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.3" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.3">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.3">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.3">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.3" color="#222">





  <meta name="keywords" content="netty," />





  <link rel="alternate" href="/atom.xml" title="LiJia's Dream" type="application/atom+xml" />






<meta name="description" content="垃圾回收机制请先去看 http://www.jianshu.com/p/b3eff15b3f72 四种引用状态在JDK1.2之前，Java中引用的定义很传统：如果引用类型的数据中存储的数值代表的是另一块内存的起始地址，就称这块内存代表着一个引用。这种定义很纯粹，但是太过于狭隘，一个对象只有被引用或者没被引用两种状态。我们希望描述这样一类对象：当内存空间还足够时，则能保留在内存中；如果内存空间在进行">
<meta name="keywords" content="netty">
<meta property="og:type" content="article">
<meta property="og:title" content="java面试之垃圾回收机制">
<meta property="og:url" content="http://yoursite.com/2017/10/25/java面试之垃圾回收机制/index.html">
<meta property="og:site_name" content="LiJia&#39;s Dream">
<meta property="og:description" content="垃圾回收机制请先去看 http://www.jianshu.com/p/b3eff15b3f72 四种引用状态在JDK1.2之前，Java中引用的定义很传统：如果引用类型的数据中存储的数值代表的是另一块内存的起始地址，就称这块内存代表着一个引用。这种定义很纯粹，但是太过于狭隘，一个对象只有被引用或者没被引用两种状态。我们希望描述这样一类对象：当内存空间还足够时，则能保留在内存中；如果内存空间在进行">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="http://upload-images.jianshu.io/upload_images/4714843-9b6454e5e56894fa.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
<meta property="og:image" content="http://upload-images.jianshu.io/upload_images/4714843-83f7d721a10698e4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
<meta property="og:image" content="http://upload-images.jianshu.io/upload_images/4714843-8206fc0304eea6dc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
<meta property="og:image" content="http://upload-images.jianshu.io/upload_images/4714843-69af799131500038.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
<meta property="og:image" content="http://upload-images.jianshu.io/upload_images/4714843-0af8fc407c11b0e4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
<meta property="og:image" content="http://upload-images.jianshu.io/upload_images/4714843-e4bcd3c3d7726186.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
<meta property="og:image" content="http://upload-images.jianshu.io/upload_images/4714843-bb812ac066c8ba36.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
<meta property="og:image" content="http://upload-images.jianshu.io/upload_images/4714843-9f089403fcdec43b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
<meta property="og:image" content="http://upload-images.jianshu.io/upload_images/4714843-5c6c17a39a644022.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
<meta property="og:image" content="http://upload-images.jianshu.io/upload_images/4714843-834c6d47c53e66dc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
<meta property="og:updated_time" content="2017-10-25T01:07:24.969Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="java面试之垃圾回收机制">
<meta name="twitter:description" content="垃圾回收机制请先去看 http://www.jianshu.com/p/b3eff15b3f72 四种引用状态在JDK1.2之前，Java中引用的定义很传统：如果引用类型的数据中存储的数值代表的是另一块内存的起始地址，就称这块内存代表着一个引用。这种定义很纯粹，但是太过于狭隘，一个对象只有被引用或者没被引用两种状态。我们希望描述这样一类对象：当内存空间还足够时，则能保留在内存中；如果内存空间在进行">
<meta name="twitter:image" content="http://upload-images.jianshu.io/upload_images/4714843-9b6454e5e56894fa.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    version: '5.1.3',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2017/10/25/java面试之垃圾回收机制/"/>





  <title>java面试之垃圾回收机制 | LiJia's Dream</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">LiJia's Dream</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">努力改掉懒惰的习惯！</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br />
            
            关于
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/10/25/java面试之垃圾回收机制/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="lijia">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LiJia's Dream">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">java面试之垃圾回收机制</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-10-25T09:06:47+08:00">
                2017-10-25
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/netty/" itemprop="url" rel="index">
                    <span itemprop="name">netty</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2017/10/25/java面试之垃圾回收机制/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count"
                        data-disqus-identifier="2017/10/25/java面试之垃圾回收机制/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h1 id="垃圾回收机制"><a href="#垃圾回收机制" class="headerlink" title="垃圾回收机制"></a>垃圾回收机制</h1><p>请先去看 <a href="http://www.jianshu.com/p/b3eff15b3f72" target="_blank" rel="external">http://www.jianshu.com/p/b3eff15b3f72</a></p>
<h1 id="四种引用状态"><a href="#四种引用状态" class="headerlink" title="四种引用状态"></a>四种引用状态</h1><p>在JDK1.2之前，Java中引用的定义很传统：如果引用类型的数据中存储的数值代表的是另一块内存的起始地址，就称这块内存代表着一个引用。这种定义很纯粹，但是太过于狭隘，一个对象只有被引用或者没被引用两种状态。我们希望描述这样一类对象：当内存空间还足够时，则能保留在内存中；如果内存空间在进行垃圾收集后还是非常紧张，则可以抛弃这些对象。很多系统的缓存功能都符合这样的应用场景。在JDK1.2之后，Java对引用的概念进行了扩充，将引用分为强引用、软引用、弱引用、虚引用4种，这4种引用强度依次减弱。<br><strong>1、强引用</strong><br>代码中普遍存在的类似”Object obj = new Object()”这类的引用，只要强引用还存在，垃圾收集器永远不会回收掉被引用的对象。<br><strong>2、软引用</strong><br>描述有些还有用但并非必需的对象。在系统将要发生内存溢出异常之前，将会把这些对象列进回收范围进行二次回收。如果这次回收还没有足够的内存，才会抛出内存溢出异常。Java中的类SoftReference表示软引用。<br><strong>3、弱引用</strong><br>描述非必需对象。被弱引用关联的对象只能生存到下一次垃圾回收之前，垃圾收集器工作之后，无论当前内存是否足够，都会回收掉只被弱引用关联的对象。Java中的类WeakReference表示弱引用。<br><strong>4、虚引用</strong><br>这个引用存在的唯一目的就是在这个对象被收集器回收时收到一个系统通知，被虚引用关联的对象，和其生存时间完全没关系。Java中的类PhantomReference表示虚引用。<br><img src="http://upload-images.jianshu.io/upload_images/4714843-9b6454e5e56894fa.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<h1 id="垃圾回收算法"><a href="#垃圾回收算法" class="headerlink" title="垃圾回收算法"></a>垃圾回收算法</h1><h2 id="标记-清除（Mark-Sweep）算法"><a href="#标记-清除（Mark-Sweep）算法" class="headerlink" title="标记-清除（Mark-Sweep）算法"></a>标记-清除（Mark-Sweep）算法</h2><p>这是最基础的算法，标记-清除算法就如同它的名字样，分为“标记”和“清除”两个阶段：<strong>首先标记出所有需要回收的对象，标记完成后统一回收所有被标记的对象。</strong>这种算法的不足主要体现在效率和空间，从效率的角度讲，标记和清除两个过程的效率都不高；从空间的角度讲，标记清除后会产生大量不连续的内存碎片， 内存碎片太多可能会导致以后程序运行过程中在需要分配较大对象时，无法找到足够的连续内存而不得不提前触发一次垃圾收集动作。标记-清除算法执行过程如图：<br><img src="http://upload-images.jianshu.io/upload_images/4714843-83f7d721a10698e4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<h2 id="复制（Copying）算法"><a href="#复制（Copying）算法" class="headerlink" title="复制（Copying）算法"></a>复制（Copying）算法</h2><p>复制算法是为了解决效率问题而出现的，<strong>它将可用的内存分为两块，每次只用其中一块，当这一块内存用完了，就将还存活着的对象复制到另外一块上面，然后再把已经使用过的内存空间一次性清理掉</strong>。这样每次只需要对整个半区进行内存回收，内存分配时也不需要考虑内存碎片等复杂情况，只需要移动指针，按照顺序分配即可。复制算法的执行过程如图：<br><img src="http://upload-images.jianshu.io/upload_images/4714843-8206fc0304eea6dc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><br>不过这种算法有个缺点，<strong>内存缩小为了原来的一半，这样代价太高了</strong>。现在的商用虚拟机都采用这种算法来<strong>回收新生代</strong>，不过研究表明1:1的比例非常不科学，因此<strong>新生代的内存被划分为一块较大的Eden空间和两块较小的Survivor空间，每次使用Eden和其中一块Survivor。</strong>每次回收时，将Eden和Survivor中还存活着的对象一次性复制到另外一块Survivor空间上，最后清理掉Eden和刚才用过的Survivor空间。HotSpot虚拟机默认Eden区和Survivor区的比例为8:1，意思是每次新生代中可用内存空间为整个新生代容量的90%。当然，我们没有办法保证每次回收都只有不多于10%的对象存活，当Survivor空间不够用时，需要依赖老年代进行分配担保（Handle Promotion）。</p>
<h2 id="标记-整理（Mark-Compact）算法"><a href="#标记-整理（Mark-Compact）算法" class="headerlink" title="标记-整理（Mark-Compact）算法"></a>标记-整理（Mark-Compact）算法</h2><p>复制算法在对象存活率较高的场景下要进行大量的复制操作，效率很低。万一对象100%存活，那么需要有额外的空间进行分配担保。老年代都是不易被回收的对象，对象存活率高，因此一般不能直接选用复制算法。根据老年代的特点，有人提出了另外一种标记-整理算法，过程与标记-清除算法一样，<strong>不过不是直接对可回收对象进行清理，而是让所有存活对象都向一端移动，然后直接清理掉边界以外的内存</strong>。标记-整理算法的工作过程如图：<br><img src="http://upload-images.jianshu.io/upload_images/4714843-69af799131500038.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<h2 id="分代收集算法"><a href="#分代收集算法" class="headerlink" title="分代收集算法"></a>分代收集算法</h2><p>根据上面的内容，用一张图概括一下堆内存的布局<br><img src="http://upload-images.jianshu.io/upload_images/4714843-0af8fc407c11b0e4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><br>     现代商用虚拟机基本都采用<strong>分代收集算法</strong>来进行垃圾回收。这种算法没什么特别的，无非是上面内容的结合罢了，根据对象的生命周期的不同将内存划分为几块，然后根据各块的特点采用最适当的收集算法。大批对象死去、少量对象存活的（新生代），使用复制算法，复制成本低；对象存活率高、没有额外空间进行分配担保的（老年代），采用标记-清理算法或者标记-整理算法。</p>
<h1 id="垃圾收集器"><a href="#垃圾收集器" class="headerlink" title="垃圾收集器"></a>垃圾收集器</h1><p>垃圾收集器就是上面讲的理论知识的具体实现了。不同虚拟机所提供的垃圾收集器可能会有很大差别，我们使用的是HotSpot，HotSpot这个虚拟机所包含的所有收集器如图：<br><img src="http://upload-images.jianshu.io/upload_images/4714843-e4bcd3c3d7726186.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><br>上图展示了7种作用于不同分代的收集器，如果两个收集器之间存在连线，那说明它们可以搭配使用。虚拟机所处的区域说明它是属于新生代收集器还是老年代收集器。多说一句，我们必须明确一个观点：没有最好的垃圾收集器，更加没有万能的收集器，只能选择对具体应用最合适的收集器。这也是HotSpot为什么要实现这么多收集器的原因。</p>
<h2 id="1、Serial收集器"><a href="#1、Serial收集器" class="headerlink" title="1、Serial收集器"></a>1、Serial收集器</h2><p>最基本、发展历史最久的收集器，这个收集器是一个<strong>采用复制算法的单线程的收集器，单线程一方面意味着它只会使用一个CPU或一条线程去完成垃圾收集工作，另一方面也意味着它进行垃圾收集时必须暂停其他线程的所有工作，直到它收集结束为止</strong>。后者意味着，在用户不可见的情况下要把用户正常工作的线程全部停掉，这对很多应用是难以接受的。不过实际上到目前为止，<strong>Serial收集器依然是虚拟机运行在Client模式下的默认新生代收集器</strong>，因为它简单而高效。用户桌面应用场景中，分配给虚拟机管理的内存一般来说不会很大，收集几十兆甚至一两百兆的新生代停顿时间在几十毫秒最多一百毫秒，只要不是频繁发生，这点停顿是完全可以接受的。Serial收集器运行过程如下图所示：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/4714843-bb812ac066c8ba36.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>说明：1. 需要STW（Stop The World），停顿时间长。2. 简单高效，对于单个CPU环境而言，Serial收集器由于没有线程交互开销，可以获取最高的单线程收集效率。</p>
<h2 id="2、ParNew收集器"><a href="#2、ParNew收集器" class="headerlink" title="2、ParNew收集器"></a>2、ParNew收集器</h2><p><strong>ParNew收集器其实就是Serial收集器的多线程版本</strong>，除了使用多条线程进行垃圾收集外，其余行为和Serial收集器完全一样，包括使用的也是复制算法。ParNew收集器除了多线程以外和Serial收集器并没有太多创新的地方，<strong>但是它却是Server模式下的虚拟机首选的新生代收集器</strong>，其中有一个很重要的和性能无关的原因是，除了Serial收集器外，目前只有它能与CMS收集器配合工作（看图）。CMS收集器是一款几乎可以认为有划时代意义的垃圾收集器，因为它第一次实现了让垃圾收集线程与用户线程基本上同时工作。ParNew收集器在单CPU的环境中绝对不会有比Serial收集器更好的效果，甚至由于线程交互的开销，该收集器在两个CPU的环境中都不能百分之百保证可以超越Serial收集器。当然，随着可用CPU数量的增加，它对于GC时系统资源的有效利用还是很有好处的。它默认开启的收集线程数与CPU数量相同，在CPU数量非常多的情况下，可以使用-XX:ParallelGCThreads参数来限制垃圾收集的线程数。ParNew收集器运行过程如下图所示：<br><img src="http://upload-images.jianshu.io/upload_images/4714843-9f089403fcdec43b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<h2 id="3、Parallel-Scavenge收集器"><a href="#3、Parallel-Scavenge收集器" class="headerlink" title="3、Parallel Scavenge收集器"></a>3、Parallel Scavenge收集器</h2><p>Parallel Scavenge收集器也是一个新生代收集器，也是用复制算法的收集器，也是并行的多线程收集器，但是它的特点是它的关注点和其他收集器不同。介绍这个收集器主要还是介绍<strong>吞吐量</strong>的概念。<strong>CMS等收集器的关注点是尽可能缩短垃圾收集时用户线程的停顿时间，而Parallel Scavenge收集器的目标则是打到一个可控制的吞吐量</strong>。所谓吞吐量的意思就是CPU用于运行用户代码时间与CPU总消耗时间的比值，即<strong>吞吐量=运行用户代码时间/（运行用户代码时间+垃圾收集时间）</strong>，虚拟机总运行100分钟，垃圾收集1分钟，那吞吐量就是99%。另外，<strong>Parallel Scavenge</strong>收集器是虚拟机运行在Server模式下的默认垃圾收集器<strong>。<br>     停顿时间短适合需要与用户交互的程序，良好的响应速度能提升用户体验；高吞吐量则可以高效率利用CPU时间，尽快完成运算任务，主要适合在后台运算而不需要太多交互的任务。<br>     虚拟机提供了-XX:MaxGCPauseMillis和-XX:GCTimeRatio两个参数来精确控制最大垃圾收集停顿时间和吞吐量大小。不过不要以为前者越小越好，GC停顿时间的缩短是以牺牲吞吐量和新生代空间换取的。由于与吞吐量关系密切，</strong>Parallel Scavenge收集器也被称为“吞吐量优先收集器”<strong>。Parallel Scavenge收集器有一个-XX:+UseAdaptiveSizePolicy参数，这是一个开关参数，这个参数打开之后，就不需要手动指定新生代大小、Eden区和Survivor参数等细节参数了，虚拟机会根据当前系统的运行情况手机性能监控信息，动态调整这些参数以提供最合适的停顿时间或者最大的吞吐量。</strong>如果对于垃圾收集器运作原理不太了解，以至于在优化比较困难的时候，使用Parallel Scavenge收集器配合自适应调节策略，把内存管理的调优任务交给虚拟机去完成将是一个不错的选择**。</p>
<h2 id="4、Serial-Old收集器"><a href="#4、Serial-Old收集器" class="headerlink" title="4、Serial Old收集器"></a>4、Serial Old收集器</h2><p><strong>Serial收集器的老年代版本，同样是一个单线程收集器，使用“标记-整理算法”</strong>，这个收集器的主要意义也是在于给Client模式下的虚拟机使用。</p>
<h2 id="5、Parallel-Old收集器"><a href="#5、Parallel-Old收集器" class="headerlink" title="5、Parallel Old收集器"></a>5、Parallel Old收集器</h2><p><strong>Parallel Scavenge收集器的老年代版本，使用多线程和“标记-整理”算法</strong>。这个收集器在JDK 1.6之后的出现，“吞吐量优先收集器”终于有了比较名副其实的应用组合，在注重吞吐量以及CPU资源敏感的场合，都可以优先考虑Parallel Scavenge收集器+Parallel Old收集器的组合。运行过程如下图所示：<br><img src="http://upload-images.jianshu.io/upload_images/4714843-5c6c17a39a644022.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<h2 id="6、CMS收集器"><a href="#6、CMS收集器" class="headerlink" title="6、CMS收集器"></a>6、CMS收集器</h2><p><strong>CMS（Conrrurent Mark Sweep）收集器是以获取最短回收停顿时间为目标的收集器。使用标记 - 清除算法</strong>，收集过程分为如下四步：<br>(1). 初始标记，标记GCRoots能直接关联到的对象，时间很短。<br>(2). 并发标记，进行GCRoots Tracing（可达性分析）过程，时间很长。<br>(3). 重新标记，修正并发标记期间因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录，时间较长。<br>(4). 并发清除，回收内存空间，时间很长。<br>其中，并发标记与并发清除两个阶段耗时最长，但是可以与用户线程并发执行。运行过程如下图所示:<br><img src="http://upload-images.jianshu.io/upload_images/4714843-834c6d47c53e66dc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><br>说明：1. 对CPU资源非常敏感，可能会导致应用程序变慢，吞吐率下降。2. 无法处理浮动垃圾，因为在并发清理阶段用户线程还在运行，自然就会产生新的垃圾，而在此次收集中无法收集他们，只能留到下次收集，这部分垃圾为浮动垃圾，同时，由于用户线程并发执行，所以需要预留一部分老年代空间提供并发收集时程序运行使用。3. 由于采用的标记 - 清除算法，会产生大量的内存碎片，不利于大对象的分配，可能会提前触发一次Full GC。虚拟机提供了-XX:+UseCMSCompactAtFullCollection参数来进行碎片的合并整理过程，这样会使得停顿时间变长，虚拟机还提供了一个参数配置，-XX:+CMSFullGCsBeforeCompaction，用于设置执行多少次不压缩的Full GC后，接着来一次带压缩的GC。</p>
<h2 id="7、G1收集器"><a href="#7、G1收集器" class="headerlink" title="7、G1收集器"></a>7、G1收集器</h2><p>G1是目前技术发展的最前沿成果之一，HotSpot开发团队赋予它的使命是未来可以替换掉JDK1.5中发布的CMS收集器。与其他GC收集器相比，G1收集器有以下特点：<br>(1). 并行和并发。使用多个CPU来缩短Stop The World停顿时间，与用户线程并发执行。<br>(2). 分代收集。独立管理整个堆，但是能够采用不同的方式去处理新创建对象和已经存活了一段时间、熬过多次GC的旧对象，以获取更好的收集效果。<br>(3). 空间整合。基于标记 - 整理算法，无内存碎片产生。<br>(4). 可预测的停顿。能简历可预测的停顿时间模型，能让使用者明确指定在一个长度为M毫秒的时间片段内，消耗在垃圾收集上的时间不得超过N毫秒。<br>     在G1之前的垃圾收集器，收集的范围都是整个新生代或者老年代，而G1不再是这样。使用G1收集器时，Java堆的内存布局与其他收集器有很大差别，它将整个Java堆划分为多个大小相等的独立区域（Region），虽然还保留有新生代和老年代的概念，但新生代和老年代不再是物理隔离的了，它们都是一部分（可以不连续）Region的集合。</p>
<h1 id="GC日志的理解"><a href="#GC日志的理解" class="headerlink" title="GC日志的理解"></a>GC日志的理解</h1><h2 id="GC-LOG-及Collector行为分析"><a href="#GC-LOG-及Collector行为分析" class="headerlink" title="GC LOG 及Collector行为分析"></a>GC LOG 及Collector行为分析</h2><p>LOG分析包含前面文章所介绍的各个GC collector的行为分析。通过加入 -XX:+PrintGCDetails 参数则可以打印详细GC信息至控制台。参数-verbose:gc也是可以，但不够详细。通过加入-XX:+PrintGCDateStamps则可以记录GC发生的详细时间。<br>通过加入 -Xloggc:/home/XX/gc/app_gc.log 可以把GC输出至文件，这对长时间服务器GC监控很有帮助。以下列出一些参数大致打印的信息如下：</p>
<ol>
<li><p>-verbose:gc： [GC 72104K-&gt;9650K(317952K), 0.0130635 secs]</p>
</li>
<li><p>-XX:+PrintGCDetails: [GC [PSYoungGen: 142826K-&gt;10751K(274944K)] 162800K-&gt;54759K(450048K), 0.0609952 secs] [Times: user=0.13 sys=0.02, real=0.06 secs]</p>
</li>
<li><p>-XX:+PrintGCDetails 加上-XX:+PrintGCDateStamps 参数则打印如下：<br>2015-12-06T12:32:02.890+0800: [GC [PSYoungGen: 142833K-&gt;10728K(142848K)] 166113K-&gt;59145K(317952K), 0.0792023 secs] [Times: user=0.22 sys=0.00, real=0.08 secs] </p>
</li>
</ol>
<p>可以看出，如果是想监控详细信息与GC发生时间，加上-XX:+PrintGCDateStamps -XX:+PrintGCDetails 参数会是一个比较好的选择。</p>
<p><strong>首先来说明一段在各个GC中通用的字段含义说明：</strong><br>1、142826K-&gt;10751K(274944K) 分别代表回收前、回收后以及总内存大小。<br>2、Times: user=0.46 sys=0.05, real=0.07 secs：  user代表GC 需要的各个CPU总时间(各个CPU时间相加)，sys代表回收器自身的行为所占用CPU时间，real则代表本次GC所耗费的真正耗时(在多核CPU中并行回收，它通常小于user) 。</p>
<h2 id="Serial-GC-XX-UseSerialGC"><a href="#Serial-GC-XX-UseSerialGC" class="headerlink" title="Serial GC (-XX:+UseSerialGC)"></a>Serial GC (-XX:+UseSerialGC)</h2><p> 下面是一段的Serial GC日志含义依次分解：</p>
<hr>
<p>[GC[DefNew: 78656K-&gt;8704K(78656K), 0.0487492 secs] 135584K-&gt;80553K(253440K), 0.0488309 secs] [Times: user=0.05 sys=0.00, real=0.05 secs] </p>
<p>[Full GC[Tenured: 62546K-&gt;60809K(174784K), 0.1600120 secs] 85931K-&gt;60809K(253440K), [Perm : 38404K-&gt;38404K(65536K)], 0.1600814 secs] [Times: user=0.16 sys=0.00, real=0.16 secs]</p>
<hr>
<ol>
<li>其中的DefNew代表单线程回收yong generation。</li>
<li>紧跟后面的 78656K-&gt;8704K(78656K) 中的 78656K 代表young generation 回收前大小，8704K 代表回收后大小，括号中的78656K 代表young generation总大小(包含2个survivor)。</li>
<li>135584K-&gt;80553K(253440K) 则代表整个Heap(young+old)的变化与总量，含义参照前面所述(Perm也一样)。</li>
<li>Full GC 即代表 major GC, Tenured: 62546K-&gt;60809K(174784K)则表示 old generation变化及总量</li>
</ol>
<h2 id="ParallelGC"><a href="#ParallelGC" class="headerlink" title="ParallelGC"></a>ParallelGC</h2><p>-XX:-UseParallelGC：Use parallel garbage collection for scavenges. (Introduced in 1.4.1)<br>-XX:-UseParallelOldGC：Use parallel garbage collection for the full collections. Enabling this option automatically sets </p>
<h2 id="XX-UseParallelGC-Introduced-in-5-0-update-6"><a href="#XX-UseParallelGC-Introduced-in-5-0-update-6" class="headerlink" title="-XX:+UseParallelGC. (Introduced in 5.0 update 6.)"></a>-XX:+UseParallelGC. (Introduced in 5.0 update 6.)</h2><p>[GC [PSYoungGen: 88524K-&gt;10728K(274944K)] 133505K-&gt;61187K(450048K), 0.0374438 secs] [Times: user=0.08 sys=0.00, real=0.04 secs]<br>[Full GC [PSYoungGen: 10728K-&gt;0K(274944K)] [ParOldGen: 50459K-&gt;50210K(175104K)] 61187K-&gt;50210K(450048K) [PSPermGen: 38656K-&gt;38643K(77312K)], 0.3787131 secs] [Times: user=0.98 sys=0.02, real=0.38 secs]</p>
<hr>
<ol>
<li><p>PSYoungGen 代表并行回收 young generation</p>
</li>
<li><p>ParOldGen 代表并行回收 old generation.</p>
</li>
<li><p>PSPermGen 代表并行回收 Permanent generation. 其他的参数与前面解释的类似。</p>
</li>
</ol>
<h2 id="CMS-GC"><a href="#CMS-GC" class="headerlink" title="CMS GC"></a>CMS GC</h2><p>CMS GC相对来说比较复杂，通过使用 -XX:+UseConcMarkSweepGC 参数在指定，但是一般情况需要更多的其他参数来保证它能比较好地达到我们的低延时目的，下面就部分常用参数做介绍：</p>
<p>-XX:+CMSIncrementalMode     采用增量式的标记方式，减少标记时应用停顿时间<br>-XX:+CMSParallelRemarkEnabled     启用并行标记<br>-XX:CMSInitiatingOccupancyFraction=70     Old generation消耗比例达到多少时进行回收，通常配置60-80之间<br>-XX:CMSFullGCsBeforeCompaction=1     多少次Full GC 后压缩old generation一次<br>-XX:+UseCMSInitiatingOccupancyOnly<br>-XX:+ScavengeBeforeFullGC             Old generation GC前对young generation GC一次，默认开启。<br>-XX:+CMSScavengeBeforeRemark     CMS remark之前进行一次young generation GC</p>
<h2 id="GC监控工具"><a href="#GC监控工具" class="headerlink" title="GC监控工具"></a>GC监控工具</h2><p>1、jstack 可以定位到具体的线程堆栈，定位cpu冲高 结合top<br>实例：</p>
<pre><code>j&apos;s
</code></pre><p>2、jmap查看堆内存使用情况</p>
<p><strong>3、jstat统计堆的使用情况</strong><br>    jstat用于实时监测 GC情况，如PID为7880的应用监测，每 1000毫秒打印一次：</p>
<hr>
<p>jstat -gc 7880 1000<br>S0C S1C S0U S1U EC EU OC OU PC PU YGC YGCT FGC FGCT GCT<br>8704.0 8704.0 8704.0 0.0 69952.0 14761.0 277100.0 181950.8 65536.0 37705.5 60 2.946 35 1.285 4.231<br>8704.0 8704.0 8704.0 0.0 69952.0 14763.0 277100.0 181950.8 65536.0 37705.5 60 2.946 35 1.285 4.231</p>
<hr>
<p>4、vivalueVM MAT</p>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/netty/" rel="tag"># netty</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2017/10/24/netty之服务端创建/" rel="next" title="netty之服务端创建">
                <i class="fa fa-chevron-left"></i> netty之服务端创建
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2017/10/25/netty之客户端创建/" rel="prev" title="netty之客户端创建">
                netty之客户端创建 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  
    <div class="comments" id="comments">
      <div id="disqus_thread">
        <noscript>
          Please enable JavaScript to view the
          <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a>
        </noscript>
      </div>
    </div>

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">lijia</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives">
              
                  <span class="site-state-item-count">25</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">5</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">7</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          
            <div class="feed-link motion-element">
              <a href="/atom.xml" rel="alternate">
                <i class="fa fa-rss"></i>
                RSS
              </a>
            </div>
          

          <div class="links-of-author motion-element">
            
          </div>

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#垃圾回收机制"><span class="nav-number">1.</span> <span class="nav-text">垃圾回收机制</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#四种引用状态"><span class="nav-number">2.</span> <span class="nav-text">四种引用状态</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#垃圾回收算法"><span class="nav-number">3.</span> <span class="nav-text">垃圾回收算法</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#标记-清除（Mark-Sweep）算法"><span class="nav-number">3.1.</span> <span class="nav-text">标记-清除（Mark-Sweep）算法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#复制（Copying）算法"><span class="nav-number">3.2.</span> <span class="nav-text">复制（Copying）算法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#标记-整理（Mark-Compact）算法"><span class="nav-number">3.3.</span> <span class="nav-text">标记-整理（Mark-Compact）算法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#分代收集算法"><span class="nav-number">3.4.</span> <span class="nav-text">分代收集算法</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#垃圾收集器"><span class="nav-number">4.</span> <span class="nav-text">垃圾收集器</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1、Serial收集器"><span class="nav-number">4.1.</span> <span class="nav-text">1、Serial收集器</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2、ParNew收集器"><span class="nav-number">4.2.</span> <span class="nav-text">2、ParNew收集器</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3、Parallel-Scavenge收集器"><span class="nav-number">4.3.</span> <span class="nav-text">3、Parallel Scavenge收集器</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4、Serial-Old收集器"><span class="nav-number">4.4.</span> <span class="nav-text">4、Serial Old收集器</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5、Parallel-Old收集器"><span class="nav-number">4.5.</span> <span class="nav-text">5、Parallel Old收集器</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#6、CMS收集器"><span class="nav-number">4.6.</span> <span class="nav-text">6、CMS收集器</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#7、G1收集器"><span class="nav-number">4.7.</span> <span class="nav-text">7、G1收集器</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#GC日志的理解"><span class="nav-number">5.</span> <span class="nav-text">GC日志的理解</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#GC-LOG-及Collector行为分析"><span class="nav-number">5.1.</span> <span class="nav-text">GC LOG 及Collector行为分析</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Serial-GC-XX-UseSerialGC"><span class="nav-number">5.2.</span> <span class="nav-text">Serial GC (-XX:+UseSerialGC)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ParallelGC"><span class="nav-number">5.3.</span> <span class="nav-text">ParallelGC</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#XX-UseParallelGC-Introduced-in-5-0-update-6"><span class="nav-number">5.4.</span> <span class="nav-text">-XX:+UseParallelGC. (Introduced in 5.0 update 6.)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#CMS-GC"><span class="nav-number">5.5.</span> <span class="nav-text">CMS GC</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#GC监控工具"><span class="nav-number">5.6.</span> <span class="nav-text">GC监控工具</span></a></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2017</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">lijia</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Mist</a> v5.1.3</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.3"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.3"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.3"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.3"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.3"></script>



  


  

    
      <script id="dsq-count-scr" src="https://lijiaccy.disqus.com/count.js" async></script>
    

    
      <script type="text/javascript">
        var disqus_config = function () {
          this.page.url = 'http://yoursite.com/2017/10/25/java面试之垃圾回收机制/';
          this.page.identifier = '2017/10/25/java面试之垃圾回收机制/';
          this.page.title = 'java面试之垃圾回收机制';
        };
        var d = document, s = d.createElement('script');
        s.src = 'https://lijiaccy.disqus.com/embed.js';
        s.setAttribute('data-timestamp', '' + +new Date());
        (d.head || d.body).appendChild(s);
      </script>
    

  




	





  














  





  

  

  
  

  

  

  

</body>
</html>
