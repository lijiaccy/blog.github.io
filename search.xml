<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[java面试之类加载机制和双亲委派]]></title>
    <url>%2F2017%2F10%2F24%2Fjava%E9%9D%A2%E8%AF%95%E4%B9%8B%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6%E5%92%8C%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%2F</url>
    <content type="text"><![CDATA[什么是类的加载类的加载指的是将类的.class文件中的二进制数据读入到内存中，将其放在运行时数据区的方法区内，然后在堆区创建一个java.lang.Class对象，用来封装类在方法区内的数据结构。类的加载的最终产品是位于堆区中的Class对象，Class对象封装了类在方法区内的数据结构，并且向Java程序员提供了访问方法区内的数据结构的接口。 类的生命周期其种类的加载过程包括加载，验证，准备，解析，初始化五个阶段。在这五个阶段中，加载，验证，准备，初始化的顺序是固定的，而解析阶段则不一定，它在某些情况下可以在初始化阶段之后工作，这是为了支持java的运行时绑定（动态绑定）。这里的几个阶段是按顺序开始的，而不是按顺序进行或者完成，因为这些阶段通常交叉进行的。 加载查找并加载类的二进制数据，在这个阶段，虚拟机需要完成以下三件事情： 通过一个类的全限定名来获取其定义的二进制字节流 将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构 在Java堆中生成一个代表这个类的java.lang.Class对象作为对方法区中这些数据的访问入口相对于类加载的其他阶段而言，加载阶段是可控性最强的阶段，因为程序猿既可以使用系统提供的类加载器来完成加载，也可以自定义自己的类加载器加载。双亲委派机制①加载完成之后，虚拟机外部的二进制字节流就按照虚拟机所需的格式存储在方法区中，而在堆中也创建一个java.lang.Class对象，这样可以通过该对象访问方法区中的这些数据。验证验证是连接的第一步，这一阶段是为了确保Class文件的字节流包含的信息符合当前虚拟机的要求，冰球不会危害虚拟机自身的安全。验证阶段大致完成4个检验动作： 文件格式验证：验证字节流是否符合Class文件格式的规范。 元数据验证：对字节码描述的信息进行语义分析，以保证其描述的信息符合java语言规范的要求。 字节码验证：通过数据流和控制流的分析，确定程序语义是合法的、符合逻辑的。 符号引用验证：确保解析动作能正确执行。验证阶段非常重要，但不是必须的，这个对程序运行期没有影响。如果所应用的类经过反复验证，可以考虑采用-Xverifynone参数来关闭大部分的类验证措施，以缩短虚拟机类加载时间。 准备准备阶段是正式为类变量分配内存并设置泪变量初始值的阶段，这些内存都将在方法区中分配。选哟注意以下几点：1、这个阶段的内存分配仅仅是static变量，而不是实例变量。实例变量会在对象实例化的时候随着对象一起分配在java队中。2、这里所设置的初始值通常情况下是数据默认值，而不是java代码中所显式设置的值。 int a = 1;//这个阶段a的初始值就是0，而不是1另外还需注意下面几点： 对基本数据类型来说，对于类变量（static）和全局变量，如果不显式地对其赋值而直接使用，则系统会为其赋予默认的零值，而对于局部变量来说，在使用前必须显式地为其赋值，否则编译时不通过。 对于同时被static和final修饰的常量，必须在声明的时候就为其显式地赋值，否则编译时不通过；而只被final修饰的常量则既可以在声明时显式地为其赋值，也可以在类初始化时显式地为其赋值，总之，在使用前必须为其显式地赋值，系统不会为其赋予默认零值。 对于引用数据类型reference来说，如数组引用、对象引用等，如果没有对其进行显式地赋值而直接使用，系统都会为其赋予默认的零值，即null。 如果在数组初始化时没有对数组中的各元素赋值，那么其中的元素将根据对应的数据类型而被赋予默认的值3、也就是第二点中，如果一个属性同时被final和static修饰，准备阶段就会初始化为指定的值并放入常量池。解析解析阶段是虚拟机将常量池中的符号引用转换为直接引用的过程，解析动作主要针对类或者接口、字段、类方法、接口方法、方法类型、方法句柄、调用点限定符7类符号引用进行。符号引用就是一组符号来描述目标，可以是任何字符。初始化为类的静态变量赋予正确的初始值，JVM负责对类进行初始化，主要对类变量进行初始化。在Java中对类变量进行初始值设定有两种方式：①声明类变量是指定初始值②使用静态代码块为类变量指定初始值JVM初始化步骤：1、假如这个类还没有被加载和连接，则程序先加载并连接该类2、假如该类的直接父类还没有被初始化，则先初始化其直接父类3、假如类中有初始化语句，则系统依次执行这些初始化语句类初始化时机：只有当对类的主动使用的时候才会导致类的初始化，类的主动使用包括以下六种： 创建类的实例，也就是new的方式 访问某个类或接口的静态变量，或者对该静态变量赋值 调用类的静态方法 反射（如Class.forName(“com.shengsiyuan.Test”)） 初始化某个类的子类，则其父类也会被初始化 Java虚拟机启动时被标明为启动类的类（Java Test），直接使用java.exe命令来运行某个主类结束生命周期在如下几种情况下，Java虚拟机将结束生命周期 执行了System.exit()方法 程序正常执行结束 程序在执行过程中遇到了异常或错误而异常终止 由于操作系统出现错误而导致Java虚拟机进程终止 类加载器 public class Test { public static void main(String[] args) { ClassLoader classLoader = Thread.currentThread().getContextClassLoader(); System.out.println(classLoader); System.out.println(classLoader.getParent()); System.out.println(classLoader.getParent().getParent()); } } 结果： sun.misc.Launcher$AppClassLoader@7d4991ad sun.misc.Launcher$ExtClassLoader@677327b6 null最后的null是由于Bootstrap Loader（引导类加载器）是用C语言实现的，找不到一个确定的返回父Loader的方式，于是就返回null。通过一个图看类加载器： 注意：这里父类加载器并不是通过继承关系来实现的，而是采用组合实现的。站在Java虚拟机的角度来讲，只存在两种不同的类加载器：启动类加载器：它使用C++实现（这里仅限于Hotspot，也就是JDK1.5之后默认的虚拟机，有很多其他的虚拟机是用Java语言实现的），是虚拟机自身的一部分；所有其他的类加载器：这些类加载器都由Java语言实现，独立于虚拟机之外，并且全部继承自抽象类java.lang.ClassLoader，这些类加载器需要由启动类加载器加载到内存中之后才能去加载其他的类。 站在Java开发人员的角度来看，类加载器可以大致划分为以下三类： 启动类加载器：Bootstrap ClassLoader，负责加载存放在JDK\jre\lib(JDK代表JDK的安装目录，下同)下，或被-Xbootclasspath参数指定的路径中的，并且能被虚拟机识别的类库（如rt.jar，所有的java.开头的类均被Bootstrap ClassLoader加载）。启动类加载器是无法被Java程序直接引用的。扩展类加载器：Extension ClassLoader，该加载器由sun.misc.Launcher$ExtClassLoader实现，它负责加载DK\jre\lib\ext目录中，或者由java.ext.dirs系统变量指定的路径中的所有类库（如javax.开头的类），开发者可以直接使用扩展类加载器。应用程序类加载器：Application ClassLoader，该类加载器由sun.misc.Launcher$AppClassLoader来实现，它负责加载用户类路径（ClassPath）所指定的类，开发者可以直接使用该类加载器，如果应用程序中没有自定义过自己的类加载器，一般情况下这个就是程序中默认的类加载器。 应用程序都是由这三种类加载器互相配合进行加载的，如果有必要，我们还可以加入自定义的类加载器。因为JVM自带的ClassLoader只是懂得从本地文件系统加载标准的java class文件，因此如果编写了自己的ClassLoader，便可以做到如下几点： 1）在执行非置信代码之前，自动验证数字签名。2）动态地创建符合用户特定需要的定制化构建类。3）从特定的场所取得java class，例如数据库中和网络中。 JVM类加载机制全盘负责，当一个类加载器负责加载某个Class时，该Class所依赖的和引用的其他Class也将由该类加载器负责载入，除非显示使用另外一个类加载器来载入父类委托，先让父类加载器试图加载该类，只有在父类加载器无法加载该类时才尝试从自己的类路径中加载该类缓存机制，缓存机制将会保证所有加载过的Class都会被缓存，当程序中需要使用某个Class时，类加载器先从缓存区寻找该Class，只有缓存区不存在，系统才会读取该类对应的二进制数据，并将其转换成Class对象，存入缓存区。这就是为什么修改了Class后，必须重启JVM，程序的修改才会生效 类加载有三种方式：1、命令行启动应用时候由JVM初始化加载2、通过Class.forName()方法动态加载3、通过ClassLoader.loadClass()方法动态加载 Class.forName()和ClassLoader.loadClass()区别Class.forName()：将类的.class文件加载到jvm中之外，还会对类进行解释，执行类中的static块；ClassLoader.loadClass()：只干一件事情，就是将.class文件加载到jvm中，不会执行static中的内容,只有在newInstance才会去执行static块。注：Class.forName(name, initialize, loader)带参函数也可控制是否加载static块。并且只有调用了newInstance()方法采用调用构造函数，创建类的对象 。 双亲委派模型双亲委派模型的工作流程是：如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把请求委托给父加载器去完成，依次向上，因此，所有的类加载请求最终都应该被传递到顶层的启动类加载器中，只有当父加载器在它的搜索范围中没有找到所需的类时，即无法完成该加载，子加载器才会尝试自己去加载该类。双亲委派机制:1、当AppClassLoader加载一个class时，它首先不会自己去尝试加载这个类，而是把类加载请求委派给父类加载器ExtClassLoader去完成。2、当ExtClassLoader加载一个class时，它首先也不会自己去尝试加载这个类，而是把类加载请求委派给BootStrapClassLoader去完成。3、如果BootStrapClassLoader加载失败（例如在$JAVA_HOME/jre/lib里未查找到该class），会使用ExtClassLoader来尝试加载；4、若ExtClassLoader也加载失败，则会使用AppClassLoader来加载，如果AppClassLoader也加载失败，则会报出异常ClassNotFoundException。ClassLoader源码分析： public Class&lt;?&gt; loadClass(String name)throws ClassNotFoundException { return loadClass(name, false); } protected synchronized Class&lt;?&gt; loadClass(String name, boolean resolve)throws ClassNotFoundException { // 首先判断该类型是否已经被加载 Class c = findLoadedClass(name); if (c == null) { //如果没有被加载，就委托给父类加载或者委派给启动类加载器加载 try { if (parent != null) { //如果存在父类加载器，就委派给父类加载器加载 c = parent.loadClass(name, false); } else { //如果不存在父类加载器，就检查是否是由启动类加载器加载的类，通过调用本地方法native Class findBootstrapClass(String name) c = findBootstrapClass0(name); } } catch (ClassNotFoundException e) { // 如果父类加载器和启动类加载器都不能完成加载任务，才调用自身的加载功能 c = findClass(name); } } if (resolve) { resolveClass(c); } return c; } 双亲委派模型意义： 系统类防止内存中出现多份同样的字节码 保证Java程序安全稳定运行]]></content>
      <categories>
        <category>面试</category>
      </categories>
      <tags>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[netty之私有栈]]></title>
    <url>%2F2017%2F10%2F23%2Fnetty%E4%B9%8B%E7%A7%81%E6%9C%89%E6%A0%88%2F</url>
    <content type="text"><![CDATA[协议栈功能设计Netty协议栈用于内部各模块间的通信，基于TCP/IP协议栈。 协议栈功能描述 基于Netty的NIO通信框架，提供高性能的异步通信能力 提供消息的编解码框架，可以实现POJO的序列化和反序列化 提供基于IP地址的白名单接入认证机制 链路的有效校验机制 链路的断连机制通信模型 （1） Netty协议栈客户端发送握手请求消息，携带节点ID等有效身份认证信息（2） Netty协议栈服务端对握手请求消息进行合法性验证。校验通过后，返回登陆成功的应答信息。（3） 链路建立成功之后，客户端发送业务消息。（4） 链路成功之后，服务端发送心跳消息。（5） 链路成功之后，客户端发送心跳消息。（6） 链路建立成功之后，服务端发送业务消息。（7） 服务端退出时，服务器关闭连接，客户端感知对方关闭，被动关闭客户端。注意：Netty协议通信双方链路建立成功之后，双发可以进行全双工通信，无论是客户端还是服务端，都可以主动发送消息给对方。双方之间的心跳采用Ping-Pong机制，当链路空闲时，客户端主动发送ping消息给服务端，服务端收到后发送Pong返回给客户端，如果客户端连续发送N条ping消息都没有收到服务端返回的pong消息，说明链路已经挂死或者对方处于异常，客户端应主动关闭连接，间隔周期T后发起重连操作，直到重连成功。 消息的定义Netty协议栈消息定义包含了两部分：消息头和消息体 Netty协议支持的字段类型java所有的基本类型还有String，map，set，array，list Netty协议的编解码使用同一的编解码类型 链路的建立Netty协议栈是支持服务端和客户端的，但是对于使用Netty协议栈的应用程序中，不需要刻意的去区别服务端和客户端。在分布式组网环境中，一个节点可能是服务端，也可能是客户端。Netty协议栈对客户端的说明如下，如果A节点需要调用B节点的服务，而A节点和B节点还没有建立物理链路，则由调用方主动发起连接。调用方称为客户端，被调用方称为服务端。注意链路建立的安全机制 链路的关闭由于采用长连接通信，在正常业务运行期间，双方通过心跳和业务消息维护链路，任何一方不需要主动关闭连接。在以下情况下，需要客户端和服务端关闭连接。 当双方关机或者重启时，会主动关闭链路，另一方读取到操作系统的通知信号，得知双方的REST链路，需要关闭连接，释放自身的 句柄等资源。由于采用TCP全双工通信，通信双方都需要关闭连接，释放资源。 消息读写过程中，发生了I/0异常，需要主动关闭连接 心跳超时，需要主动关闭连接 发生编码异常等不可恢复错误时，需要主动关闭连接可靠性设计1、心跳机制（1）当网络处于空闲状态达到T时，客户端主动发送Ping心跳消息给服务端。（2）如果在下一个周期T到来时客户端没有收到对方发送的Pong心跳应答消息或者读取到服务端发送的其他业务消息，则心跳失败计数器加1（3）每当客户端接收到服务的业务消息或者Pong应答消息，将心跳失败计数器清零；（4）服务端网络空闲状态时间达到T后，服务端将心跳失败计数器加1；只要连接到客户端发送的Ping消息或者其他业务消息，计数器清零；（5）服务端连续N次没有接收到客户端的Ping消息或者其他业务消息，则关闭链路，释放资源，等待客户端重连。2、重连机制要注意的只有一点，不是失败后立即重连，需要确保句柄资源释放，如果重连失败，必须打印异常堆栈信息。3、重复登录保护在缓存地址表中查看客户端死否已经登录，如果已经登录，则拒绝重复登录。如果客户有ID，看此客户ID是否登录。以上两个如果有一个验证未通过，返回-1安全设计IP白名单验证实例代码参考 http://www.cnblogs.com/carl10086/p/6195568.html]]></content>
      <categories>
        <category>netty</category>
      </categories>
      <tags>
        <tag>netty</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[netty之WebSocket]]></title>
    <url>%2F2017%2F10%2F19%2Fnetty%E4%B9%8BWebSocket%2F</url>
    <content type="text"><![CDATA[Http的弊端HTTP的生命周期通过Request来界定，也就是一个Request 一个Response。那么在HTTP1.0中，这次HTTP请求就结束了。在HTTP1.1中进行了改进，使得有一个keep-alive，也就是说，在一个HTTP连接中，可以发送多个Request，接收多个Response。但是请记住 Request 和 Response ， 在HTTP中永远是这样，也就是说一个request只能有一个response。而且这个response也是被动的，不能主动发起。 ajax轮询其实ajax轮询就是在js上加上一个定时器 window.setInterval(function(){$.ajax(getting)},1000);//1秒执行一次 由于ajax轮询采用的是http协议，而http协议是无状态的，每次轮询都需要去建立连接，然后去判断。浪费带宽和服务器资源。 长连接获取资源，没有获取到资源就不断开。在无消息的情况下不会频繁的请求，耗费资源小。但是服务器hold连接会消耗资源，返回数据顺序无保证，难于管理维护。 Websocket传统HTTP客户端与服务器请求响应模式如下图所示： WebSocket模式客户端与服务器请求响应模式如下图： 上图对比可以看出，相对于传统HTTP每次请求-应答都需要客户端与服务端建立连接的模式，WebSocket是类似Socket的TCP长连接通讯模式。 一旦WebSocket连接建立后，后续数据都以帧序列的形式传输。在客户端断开WebSocket连接或Server端中断连接前，不需要客户端和服务端重新发起连接请求。在海量并发及客户端与服务器交互负载流量大的情况下，极大的节省了网络带宽资源的消耗，有明显的性能优势，且客户端发送和接受消息是在同一个持久连接上发起，实时性优势明显。 相比HTTP长连接，WebSocket有以下特点： 是真正的全双工方式，建立连接后客户端与服务器端是完全平等的，可以互相主动请求。而HTTP长连接基于HTTP，是传统的客户端对服务器发起请求的模式。 HTTP长连接中，每次数据交换除了真正的数据部分外，服务器和客户端还要大量交换HTTP header，信息交换效率很低。Websocket协议通过第一个request建立了TCP连接之后，之后交换的数据都不需要发送 HTTP header就能交换数据，这显然和原有的HTTP协议有区别所以它需要对服务器和客户端都进行升级才能实现（主流浏览器都已支持HTML5）。此外还有 multiplexing、不同的URL可以复用同一个WebSocket连接等功能。这些都是HTTP长连接不能做到的。 下面再通过客户端和服务端交互的报文对比WebSocket通讯与传统HTTP的不同点：在客户端，new WebSocket实例化一个新的WebSocket客户端对象，请求类似 ws://yourdomain:port/path 的服务端WebSocket URL，客户端WebSocket对象会自动解析并识别为WebSocket请求，并连接服务端端口，执行双方握手过程，客户端发送数据格式类似： GET /webfin/websocket/ HTTP/1.1 Host: localhost Upgrade: websocket Connection: Upgrade Sec-WebSocket-Key: xqBt3ImNzJbYqRINxEFlkg== Origin: http://localhost:8080 Sec-WebSocket-Version: 13 可以看到，客户端发起的WebSocket连接报文类似传统HTTP报文，Upgrade：websocket参数值表明这是WebSocket类型请求，Sec-WebSocket-Key是WebSocket客户端发送的一个 base64编码的密文，要求服务端必须返回一个对应加密的Sec-WebSocket-Accept应答，否则客户端会抛出Error during WebSocket handshake错误，并关闭连接。 服务端收到报文后返回的数据格式类似： HTTP/1.1 101 Switching ProtocolsUpgrade: websocketConnection: UpgradeSec-WebSocket-Accept: K7DJLdLooIwIG/MOpvWFB3y3FE8= Sec-WebSocket-Accept的值是服务端采用与客户端一致的密钥计算出来后返回客户端的，HTTP/1.1 101 Switching Protocols表示服务端接受WebSocket协议的客户端连接，经过这样的请求-响应处理后，两端的WebSocket连接握手成功, 后续就可以进行TCP通讯了。用户可以查阅WebSocket协议栈了解WebSocket客户端和服务端更详细的交互数据格式。在开发方面，WebSocket API 也十分简单：只需要实例化 WebSocket，创建连接，然后服务端和客户端就可以相互发送和响应消息。在WebSocket 实现及案例分析部分可以看到详细的 WebSocket API 及代码实现。 Websocket其实是一个新协议，跟HTTP协议基本没有关系，只是为了兼容现有浏览器的握手规范而已，也就是说它是HTTP协议上的一种补充可以通过这样一张图理解有交集，但是并不是全部。另外Html5是指的一系列新的API，或者说新规范，新技术。Http协议本身只有1.0和1.1，而且跟Html本身没有直接关系。 WebSocket特点总结 单一的TCP连接，采用全双工模式通信 对代理，防火墙和路由器透明 无头部信息，Cookie和身份验证 无安全开销 通过“ping/pong”帧保持链路激活 度武器可以主动传递消息给客户端用Netty实现WebSocketWebSocketServer import io.netty.bootstrap.ServerBootstrap; import io.netty.channel.Channel; import io.netty.channel.ChannelInitializer; import io.netty.channel.ChannelPipeline; import io.netty.channel.EventLoopGroup; import io.netty.channel.nio.NioEventLoopGroup; import io.netty.channel.socket.SocketChannel; import io.netty.channel.socket.nio.NioServerSocketChannel; import io.netty.handler.codec.http.HttpObjectAggregator; import io.netty.handler.codec.http.HttpServerCodec; import io.netty.handler.stream.ChunkedWriteHandler; public class WebSocketServer { public void run(int port) throws Exception { EventLoopGroup bossGroup = new NioEventLoopGroup(); EventLoopGroup workerGroup = new NioEventLoopGroup(); try { ServerBootstrap b = new ServerBootstrap(); b.group(bossGroup, workerGroup) .channel(NioServerSocketChannel.class) .childHandler(new ChannelInitializer&lt;SocketChannel&gt;() { @Override protected void initChannel(SocketChannel ch) throws Exception { ChannelPipeline pipeline = ch.pipeline(); pipeline.addLast(&quot;http-codec&quot;, new HttpServerCodec()); pipeline.addLast(&quot;aggregator&quot;, new HttpObjectAggregator(65536)); ch.pipeline().addLast(&quot;http-chunked&quot;, new ChunkedWriteHandler()); pipeline.addLast(&quot;handler&quot;, new WebSocketServerHandler()); } }); Channel ch = b.bind(port).sync().channel(); System.out.println(&quot;Web socket server started at port &quot; + port + &apos;.&apos;); System.out .println(&quot;Open your browser and navigate to http://localhost:&quot; + port + &apos;/&apos;); ch.closeFuture().sync(); } finally { bossGroup.shutdownGracefully(); workerGroup.shutdownGracefully(); } } public static void main(String[] args) throws Exception { int port = 8080; if (args.length &gt; 0) { try { port = Integer.parseInt(args[0]); } catch (NumberFormatException e) { e.printStackTrace(); } } new WebSocketServer().run(port); } } WebSocketServerHandler import io.netty.buffer.ByteBuf; import io.netty.buffer.Unpooled; import io.netty.channel.ChannelFuture; import io.netty.channel.ChannelFutureListener; import io.netty.channel.ChannelHandlerContext; import io.netty.channel.SimpleChannelInboundHandler; import io.netty.handler.codec.http.DefaultFullHttpResponse; import io.netty.handler.codec.http.FullHttpRequest; import io.netty.handler.codec.http.FullHttpResponse; import io.netty.handler.codec.http.websocketx.*; import io.netty.util.CharsetUtil; import java.util.logging.Level; import java.util.logging.Logger; import static io.netty.handler.codec.http.HttpHeaderUtil.setContentLength; import static io.netty.handler.codec.http.HttpHeaderUtil.isKeepAlive; import static io.netty.handler.codec.http.HttpResponseStatus.BAD_REQUEST; import static io.netty.handler.codec.http.HttpVersion.HTTP_1_1; public class WebSocketServerHandler extends SimpleChannelInboundHandler&lt;Object&gt; { private static final Logger logger = Logger .getLogger(WebSocketServerHandler.class.getName()); private WebSocketServerHandshaker handshaker; @Override public void messageReceived(ChannelHandlerContext ctx, Object msg) throws Exception { // 传统的HTTP接入 if (msg instanceof FullHttpRequest) { handleHttpRequest(ctx, (FullHttpRequest) msg); } // WebSocket接入 else if (msg instanceof WebSocketFrame) { handleWebSocketFrame(ctx, (WebSocketFrame) msg); } } @Override public void channelReadComplete(ChannelHandlerContext ctx) throws Exception { ctx.flush(); } private void handleHttpRequest(ChannelHandlerContext ctx, FullHttpRequest req) throws Exception { // 如果HTTP解码失败，返回HHTP异常 if (!req.decoderResult().isSuccess() || (!&quot;websocket&quot;.equals(req.headers().get(&quot;Upgrade&quot;)))) { sendHttpResponse(ctx, req, new DefaultFullHttpResponse(HTTP_1_1, BAD_REQUEST)); return; } // 构造握手响应返回，本机测试 WebSocketServerHandshakerFactory wsFactory = new WebSocketServerHandshakerFactory( &quot;ws://localhost:8080/websocket&quot;, null, false); handshaker = wsFactory.newHandshaker(req); if (handshaker == null) { WebSocketServerHandshakerFactory.sendUnsupportedVersionResponse(ctx.channel()); } else { handshaker.handshake(ctx.channel(), req); } } private void handleWebSocketFrame(ChannelHandlerContext ctx, WebSocketFrame frame) { // 判断是否是关闭链路的指令 if (frame instanceof CloseWebSocketFrame) { handshaker.close(ctx.channel(), (CloseWebSocketFrame) frame.retain()); return; } // 判断是否是Ping消息 if (frame instanceof PingWebSocketFrame) { ctx.channel().write( new PongWebSocketFrame(frame.content().retain())); return; } // 本例程仅支持文本消息，不支持二进制消息 if (!(frame instanceof TextWebSocketFrame)) { throw new UnsupportedOperationException(String.format( &quot;%s frame types not supported&quot;, frame.getClass().getName())); } // 返回应答消息 String request = ((TextWebSocketFrame) frame).text(); if (logger.isLoggable(Level.FINE)) { logger.fine(String.format(&quot;%s received %s&quot;, ctx.channel(), request)); } ctx.channel().write( new TextWebSocketFrame(request + &quot; , 欢迎使用Netty WebSocket服务，现在时刻：&quot; + new java.util.Date().toString())); } private static void sendHttpResponse(ChannelHandlerContext ctx, FullHttpRequest req, FullHttpResponse res) { // 返回应答给客户端 if (res.status().code() != 200) { ByteBuf buf = Unpooled.copiedBuffer(res.status().toString(), CharsetUtil.UTF_8); res.content().writeBytes(buf); buf.release(); setContentLength(res, res.content().readableBytes()); } // 如果是非Keep-Alive，关闭连接 ChannelFuture f = ctx.channel().writeAndFlush(res); if (!isKeepAlive(req) || res.status().code() != 200) { f.addListener(ChannelFutureListener.CLOSE); } } @Override public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception { cause.printStackTrace(); ctx.close(); } } 然后启动WebSocketServer，控制台会出现下面地址：但是这个地址是无效的 最后给个html显示 &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; Netty WebSocket 时间服务器 &lt;/head&gt; &lt;br&gt; &lt;body&gt; &lt;br&gt; &lt;script type=&quot;text/javascript&quot;&gt; var socket; if (!window.WebSocket) { window.WebSocket = window.MozWebSocket; } if (window.WebSocket) { socket = new WebSocket(&quot;ws://localhost:8080/websocket&quot;); socket.onmessage = function(event) { var ta = document.getElementById(&apos;responseText&apos;); ta.value=&quot;&quot;; ta.value = event.data }; socket.onopen = function(event) { var ta = document.getElementById(&apos;responseText&apos;); ta.value = &quot;打开WebSocket服务正常，浏览器支持WebSocket!&quot;; }; socket.onclose = function(event) { var ta = document.getElementById(&apos;responseText&apos;); ta.value = &quot;&quot;; ta.value = &quot;WebSocket 关闭!&quot;; }; } else { alert(&quot;抱歉，您的浏览器不支持WebSocket协议!&quot;); } function send(message) { if (!window.WebSocket) { return; } if (socket.readyState == WebSocket.OPEN) { socket.send(message); } else { alert(&quot;WebSocket连接没有建立成功!&quot;); } } &lt;/script&gt; &lt;form onsubmit=&quot;return false;&quot;&gt; &lt;input type=&quot;text&quot; name=&quot;message&quot; value=&quot;Netty最佳实践&quot;/&gt; &lt;br&gt;&lt;br&gt; &lt;input type=&quot;button&quot; value=&quot;发送WebSocket请求消息&quot; onclick=&quot;send(this.form.message.value)&quot;/&gt; &lt;hr color=&quot;blue&quot;/&gt; &lt;h3&gt;服务端返回的应答消息&lt;/h3&gt; &lt;textarea id=&quot;responseText&quot; style=&quot;width:500px;height:300px;&quot;&gt;&lt;/textarea&gt; &lt;/form&gt; &lt;/body&gt; &lt;/html&gt; 运行这个html，会显示 这个时间是后台返回回来的。到此这个WebSocket也搭建完成。]]></content>
      <categories>
        <category>netty</category>
      </categories>
      <tags>
        <tag>netty</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Netty之Http协议]]></title>
    <url>%2F2017%2F10%2F18%2Fnetty%E4%B9%8BHttp%E5%8D%8F%E8%AE%AE%2F</url>
    <content type="text"><![CDATA[什么是HTTPHTTP是一个属于应用层的面向对象的协议，由于其简捷、快速的方式，适用于分布式超媒体信息系统。 HTTP协议的主要特点 支持客户/服务器模式。 简单快速：客户向服务器请求服务时，只需传送请求方法和路径。请求方法常用的有GET、HEAD、POST。每种方法规定了客户与服务器联系的类型不同。由于HTTP协议简单，使得HTTP服务器的程序规模小，因而通信速度很快。 灵活：HTTP允许传输任意类型的数据对象。正在传输的类型由Content-Type加以标记。 无连接：无连接的含义是限制每次连接只处理一个请求。服务器处理完客户的请求，并收到客户的应答后，即断开连接。采用这种方式可以节省传输时间。 无状态：HTTP协议是无状态协议。无状态是指协议对于事务处理没有记忆能力。缺少状态意味着如果后续处理需要前面的信息，则它必须重传，这样可能导致每次连接传送的数据量增大。另一方面，在服务器不需要先前信息时它的应答就较快。HTTP的url组成HTTP使用统一资源标识符（Uniform Resource Identifiers, URI）来传输数据和建立连接。URL是一种特殊类型的URI，包含了用于查找某个资源的足够的信息 URL全称是UniformResourceLocator, 中文叫统一资源定位符,是互联网上用来标识某一处资源的地址。以下面这个URL为例，介绍下普通URL的各部分组成：http://www.aspxfans.com:8080/news/index.asp?boardID=5&amp;ID=24618&amp;page=1#name 从上面的URL可以看出，一个完整的URL包括以下几部分：1.协议部分：该URL的协议部分为“http：”，这代表网页使用的是HTTP协议。在Internet中可以使用多种协议，如HTTP，FTP等等本例中使用的是HTTP协议。在”HTTP”后面的“//”为分隔符2.域名部分：该URL的域名部分为“www.aspxfans.com”。一个URL中，也可以使用IP地址作为域名使用3.端口部分：跟在域名后面的是端口，域名和端口之间使用“:”作为分隔符。端口不是一个URL必须的部分，如果省略端口部分，将采用默认端口4.虚拟目录部分：从域名后的第一个“/”开始到最后一个“/”为止，是虚拟目录部分。虚拟目录也不是一个URL必须的部分。本例中的虚拟目录是“/news/”5.文件名部分：从域名后的最后一个“/”开始到“？”为止，是文件名部分，如果没有“?”,则是从域名后的最后一个“/”开始到“#”为止，是文件部分，如果没有“？”和“#”，那么从域名后的最后一个“/”开始到结束，都是文件名部分。本例中的文件名是“index.asp”。文件名部分也不是一个URL必须的部分，如果省略该部分，则使用默认的文件名6.锚部分：从“#”开始到最后，都是锚部分。本例中的锚部分是“name”。锚部分也不是一个URL必须的部分7.参数部分：从“？”开始到“#”为止之间的部分为参数部分，又称搜索部分、查询部分。本例中的参数部分为“boardID=5&amp;ID=24618&amp;page=1”。参数可以允许有多个参数，参数与参数之间用“&amp;”作为分隔符。 HTTP之请求消息Requesthttp请求由三部分组成，分别是：请求行、消息报头、请求正文 请求行请求行以一个方法符号开头，以空格分开，后面跟着请求的URI和协议的版本。GET： 请求获取Request-URI所标识的资源POST： 在Request-URI所标识的资源后附加新的数据HEAD： 请求获取由Request-URI所标识的资源的响应消息报头PUT： 请求服务器存储一个资源，并用Request-URI作为其标识DELETE： 请求服务器删除Request-URI所标识的资源TRACE： 请求服务器回送收到的请求信息，主要用于测试或诊断CONNECT： 保留将来使用OPTIONS： 请求查询服务器的性能，或者查询与资源相关的选项和需求 通过一个简单的Socket来看看这个 import java.io.IOException; import java.io.InputStream; import java.io.InputStreamReader; import java.net.ServerSocket; import java.net.Socket; public class Test { public static void main(String[] args) throws IOException { // 服务器监听端口号9999 ServerSocket serverSocket = new ServerSocket(9999); // 等待接收请求，这是一个阻塞的方法，当请求到来的时候才会继续向下执行 Socket socket = serverSocket.accept(); // 获取请求内容 InputStream is = socket.getInputStream(); InputStreamReader reader = new InputStreamReader(is); // 输出请求内容 while (true) { System.out.print((char)reader.read()); } } } 然后运行main方法。在浏览器中输入http://localhost:9999/test?lijia=1231控制台会输出下面的结果： 请求行（第2行）：（请求方法GET，请求资源/test?lijia=1231，HTTP版本1.1）请求头部（第3-10行）：紧接着请求行（即第2行）之后的部分，用来说明服务器要使用的附加信息空行（第11行）：请求头部后面的空行是必须的请求数据（空行之后的）：为空，也必须有空行。这个例子的请求数据为空。 下图用POST传递：和GET差不多，不过请求数据放到最下面了 HTTP之响应消息ResponseHTTP响应也是由四个部分组成，分别是：状态行、消息报头、空行和响应正文 状态行：，由HTTP协议版本号， 状态码， 状态消息 三部分组成。第一行为状态行，（HTTP/1.1）表明HTTP版本为1.1版本，状态码为200，状态消息为（ok）消息报头：用来说明客户端要使用的一些附加信息第二行和第三行为消息报头，Date:生成响应的日期和时间；Content-Type:指定了MIME类型的HTML(text/html),编码类型是UTF-8空行：消息报头后面的空行是必须的响应正文：服务器返回给客户端的文本信息。空行后面的html部分为响应正文。 其中状态代码有三位数字组成，第一个数字定义了响应的类别，且有五种可能取值：1xx：指示信息–表示请求已接收，继续处理2xx：成功–表示请求已被成功接收、理解、接受3xx：重定向–要完成请求必须进行更进一步的操作4xx：客户端错误–请求有语法错误或请求无法实现5xx：服务器端错误–服务器未能实现合法的请求常见状态码： 200 OK //客户端请求成功 400 Bad Request //客户端请求有语法错误，不能被服务器所理解 401 Unauthorized //请求未经授权，这个状态代码必须和WWW-Authenticate报头域一起使用 403 Forbidden //服务器收到请求，但是拒绝提供服务 404 Not Found //请求资源不存在，eg：输入了错误的URL 500 Internal Server Error //服务器发生不可预期的错误 503 Server Unavailable //服务器当前不能处理客户端的请求，一段时间后可能恢复正常 更多状态码请看看 http://www.runoob.com/http/http-status-codes.html HTTP工作原理一次HTTP操作称为一个事务，其工作整个过程如下： 1）、地址解析 如用客户端浏览器请求这个页面：http://localhost.com:8080/index.htm 从中分解出协议名、主机名、端口、对象路径等部分，对于我们的这个地址，解析得到的结果如下： 协议名：http 主机名：localhost.com 端口：8080 对象路径：/index.html 在这一步，需要域名系统DNS解析域名localhost.com,得主机的IP地址。 2）、封装HTTP请求数据包 把以上部分结合本机自己的信息，封装成一个HTTP请求数据包 3）封装成TCP包，建立TCP连接（TCP的三次握手） 在HTTP工作开始之前，客户机（Web浏览器）首先要通过网络与服务器建立连接，该连接是通过TCP来完成的，该协议与IP协议共同构建Internet，即著名的TCP/IP协议族，因此Internet又被称作是TCP/IP网络。HTTP是比TCP更高层次的应用层协议，根据规则，只有低层协议建立之后才能，才能进行更层协议的连接，因此，首先要建立TCP连接，一般TCP连接的端口号是80。这里是8080端口 4）客户机发送请求命令 建立连接后，客户机发送一个请求给服务器，请求方式的格式为：统一资源标识符（URL）、协议版本号，后边是MIME信息包括请求修饰符、客户机信息和可内容。 5）服务器响应 服务器接到请求后，给予相应的响应信息，其格式为一个状态行，包括信息的协议版本号、一个成功或错误的代码，后边是MIME信息包括服务器信息、实体信息和可能的内容。 实体消息是服务器向浏览器发送头信息后，它会发送一个空白行来表示头信息的发送到此为结束，接着，它就以Content-Type应答头信息所描述的格式发送用户所请求的实际数据 6）服务器关闭TCP连接 一般情况下，一旦Web服务器向浏览器发送了请求数据，它就要关闭TCP连接，然后如果浏览器或者服务器在其头信息加入了这行代码 Connection:keep-alive TCP连接在发送后将仍然保持打开状态，于是，浏览器可以继续通过相同的连接发送请求。保持连接节省了为每个请求建立新连接所需的时间，还节约了网络带宽。 7） 服务器将响应信息传给客户端响应体中的内容可能是一个html页面，也可能是一张图片，通过输入流将其读出，并写回到显示器上。 用netty实现http的文件服务HttpServer启动类import io.netty.bootstrap.ServerBootstrap; import io.netty.channel.ChannelFuture; import io.netty.channel.ChannelInitializer; import io.netty.channel.EventLoopGroup; import io.netty.channel.nio.NioEventLoopGroup; import io.netty.channel.socket.SocketChannel; import io.netty.channel.socket.nio.NioServerSocketChannel; import io.netty.handler.codec.http.HttpObjectAggregator; import io.netty.handler.codec.http.HttpRequestDecoder; import io.netty.handler.codec.http.HttpResponseEncoder; import io.netty.handler.stream.ChunkedWriteHandler; public class HttpServer { private static final String DEFAULT_URL = &quot;/src/&quot;; public static void main(String[] args) { int port = 8888; String url = DEFAULT_URL; if(args.length &gt; 1){ url = args[1]; } new HttpServer().connect(port, url); } private void connect(int port, final String url) { EventLoopGroup bossGroup = new NioEventLoopGroup(); EventLoopGroup workerGroup = new NioEventLoopGroup(); try{ ServerBootstrap b = new ServerBootstrap(); b.group(bossGroup, workerGroup).channel(NioServerSocketChannel.class) .childHandler(new ChannelInitializer&lt;SocketChannel&gt;() { @Override protected void initChannel(SocketChannel ch) throws Exception { ch.pipeline().addLast(&quot;http-decoder&quot;, new HttpRequestDecoder()); ch.pipeline().addLast(&quot;http-aggregator&quot;, new HttpObjectAggregator(65536)); ch.pipeline().addLast(&quot;http-encoder&quot;, new HttpResponseEncoder()); ch.pipeline().addLast(&quot;http-chunked&quot;, new ChunkedWriteHandler()); ch.pipeline().addLast(&quot;fileServerHandler&quot;, new HttpFileServerHandler(url)); } }); ChannelFuture f = b.bind(&quot;localhost&quot;,port).sync(); System.out.println(&quot;HTTP 文件服务器启动, 地址是： &quot; + &quot;http://localhost:&quot; + port + url); f.channel().closeFuture().sync(); } catch (InterruptedException e) { e.printStackTrace(); } finally{ bossGroup.shutdownGracefully(); workerGroup.shutdownGracefully(); } } } HttpFileServerHandler（业务处理）import io.netty.buffer.ByteBuf; import io.netty.buffer.Unpooled; import io.netty.channel.*; import io.netty.handler.codec.http.*; import io.netty.handler.stream.ChunkedFile; import io.netty.util.CharsetUtil; import javax.activation.MimetypesFileTypeMap; import java.io.File; import java.io.FileNotFoundException; import java.io.RandomAccessFile; import java.io.UnsupportedEncodingException; import java.net.URLDecoder; import java.util.regex.Pattern; public class HttpFileServerHandler extends SimpleChannelInboundHandler&lt;FullHttpRequest&gt;{ private final String url; public HttpFileServerHandler(String url) { this.url = url; } @Override protected void messageReceived(ChannelHandlerContext ctx, FullHttpRequest request) throws Exception { //对解码结果进行判断 if(!request.decoderResult().isSuccess()) { sendError(ctx, HttpResponseStatus.BAD_REQUEST); return; } //判断是不是GET方法 if(request.method() != HttpMethod.GET) { sendError(ctx, HttpResponseStatus.METHOD_NOT_ALLOWED); return; } final String uri = request.uri(); //将uri解码 final String path = sanitizeUri(uri); if(path == null) { sendError(ctx, HttpResponseStatus.FORBIDDEN); return; } File file = new File(path); //文件隐藏或者不存在 if(file.isHidden() || !file.exists()) { sendError(ctx, HttpResponseStatus.NOT_FOUND); return; } //是不是一个目录 if(file.isDirectory()) { if(uri.endsWith(&quot;/&quot;)) { sendListing(ctx, file); }else{ sendRedirect(ctx, uri + &quot;/&quot;); } return; } //不是文件 if(!file.isFile()) { sendError(ctx, HttpResponseStatus.FORBIDDEN); return; } RandomAccessFile randomAccessFile = null; try{ randomAccessFile = new RandomAccessFile(file, &quot;r&quot;); }catch(FileNotFoundException fnfd){ sendError(ctx, HttpResponseStatus.NOT_FOUND); return; } //获取文件长度 long fileLength = randomAccessFile.length(); HttpResponse response = new DefaultHttpResponse(HttpVersion.HTTP_1_1, HttpResponseStatus.OK); HttpHeaderUtil.setContentLength(response, fileLength); setContentTypeHeader(response, file); if(HttpHeaderUtil.isKeepAlive(request)){ response.headers().set(HttpHeaderNames.CONNECTION, HttpHeaderValues.KEEP_ALIVE); } ctx.write(response); ChannelFuture sendFileFuture = null; sendFileFuture = ctx.write(new ChunkedFile(randomAccessFile, 0, fileLength, 8192), ctx.newProgressivePromise()); sendFileFuture.addListener(new ChannelProgressiveFutureListener() { @Override public void operationComplete(ChannelProgressiveFuture future) throws Exception { System.out.println(&quot;Transfer complete.&quot;); } @Override public void operationProgressed(ChannelProgressiveFuture future, long progress, long total) throws Exception { if(total &lt; 0){ System.err.println(&quot;Transfer progress: &quot; + progress); } else{ System.err.println(&quot;Transfer progress: &quot; + progress + &quot;/&quot; + total); } } }); ChannelFuture lastContentFuture = ctx.writeAndFlush(LastHttpContent.EMPTY_LAST_CONTENT); if(!HttpHeaderUtil.isKeepAlive(request)){ lastContentFuture.addListener(ChannelFutureListener.CLOSE); } } @Override public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception { cause.printStackTrace(); if(ctx.channel().isActive()){ sendError(ctx, HttpResponseStatus.INTERNAL_SERVER_ERROR); } } private static final Pattern INSECURE_URI = Pattern.compile(&quot;.*[&lt;&gt;&amp;\&quot;].*&quot;); private String sanitizeUri(String uri){ try{ uri = URLDecoder.decode(uri, &quot;UTF-8&quot;); }catch(UnsupportedEncodingException e){ try{ uri = URLDecoder.decode(uri, &quot;ISO-8859-1&quot;); }catch(UnsupportedEncodingException e1){ throw new Error(); } } if(!uri.startsWith(url)){ return null; } if(!uri.startsWith(&quot;/&quot;)){ return null; } uri = uri.replace(&apos;/&apos;, File.separatorChar); if(uri.contains(File.separator + &apos;.&apos;) || uri.contains(&apos;.&apos; + File.separator) || uri.startsWith(&quot;.&quot;) || uri.endsWith(&quot;.&quot;) || INSECURE_URI.matcher(uri).matches()){ return null; } return System.getProperty(&quot;user.dir&quot;) + File.separator + uri; } private static final Pattern ALLOWED_FILE_NAME = Pattern.compile(&quot;[A-Za-z0-9][-_A-Za-z0-9\\.]*&quot;); //返回并显示 private static void sendListing(ChannelHandlerContext ctx, File dir){ FullHttpResponse response = new DefaultFullHttpResponse(HttpVersion.HTTP_1_1, HttpResponseStatus.OK); response.headers().set(HttpHeaderNames.CONTENT_TYPE, &quot;text/html;charset=UTF-8&quot;); String dirPath = dir.getPath(); StringBuilder buf = new StringBuilder(); buf.append(&quot;&lt;!DOCTYPE html&gt;\r\n&quot;); buf.append(&quot;&lt;html&gt;&lt;head&gt;&lt;title&gt;&quot;); buf.append(dirPath); buf.append(&quot;目录:&quot;); buf.append(&quot;&lt;/title&gt;&lt;/head&gt;&lt;body&gt;\r\n&quot;); buf.append(&quot;&lt;h3&gt;&quot;); buf.append(dirPath).append(&quot; 目录：&quot;); buf.append(&quot;&lt;/h3&gt;\r\n&quot;); buf.append(&quot;&lt;ul&gt;&quot;); buf.append(&quot;&lt;li&gt;链接：&lt;a href=\&quot; ../\&quot;)..&lt;/a&gt;&lt;/li&gt;\r\n&quot;); for (File f : dir.listFiles()) { if(f.isHidden() || !f.canRead()) { continue; } String name = f.getName(); if (!ALLOWED_FILE_NAME.matcher(name).matches()) { continue; } buf.append(&quot;&lt;li&gt;链接：&lt;a href=\&quot;&quot;); buf.append(name); buf.append(&quot;\&quot;&gt;&quot;); buf.append(name); buf.append(&quot;&lt;/a&gt;&lt;/li&gt;\r\n&quot;); } buf.append(&quot;&lt;/ul&gt;&lt;/body&gt;&lt;/html&gt;\r\n&quot;); ByteBuf buffer = Unpooled.copiedBuffer(buf,CharsetUtil.UTF_8); response.content().writeBytes(buffer); buffer.release(); ctx.writeAndFlush(response).addListener(ChannelFutureListener.CLOSE); } private static void sendRedirect(ChannelHandlerContext ctx, String newUri){ FullHttpResponse response = new DefaultFullHttpResponse(HttpVersion.HTTP_1_1, HttpResponseStatus.FOUND); response.headers().set(HttpHeaderNames.LOCATION, newUri); ctx.writeAndFlush(response).addListener(ChannelFutureListener.CLOSE); } private static void sendError(ChannelHandlerContext ctx, HttpResponseStatus status){ FullHttpResponse response = new DefaultFullHttpResponse(HttpVersion.HTTP_1_1, status, Unpooled.copiedBuffer(&quot;Failure: &quot; + status.toString() + &quot;\r\n&quot;, CharsetUtil.UTF_8)); response.headers().set(HttpHeaderNames.CONTENT_TYPE, &quot;text/html;charset=UTF-8&quot;); ctx.writeAndFlush(response).addListener(ChannelFutureListener.CLOSE); } private static void setContentTypeHeader(HttpResponse response, File file){ MimetypesFileTypeMap mimetypesFileTypeMap = new MimetypesFileTypeMap(); response.headers().set(HttpHeaderNames.CONTENT_TYPE, mimetypesFileTypeMap.getContentType(file.getPath())); } } 然后启动HttpServer，控制台会出现 然后输入 http://localhost:8888/src/ ，会显示 看看上面的代码在HttpServer中加入了 ch.pipeline().addLast(&quot;http-decoder&quot;, new HttpRequestDecoder()); ch.pipeline().addLast(&quot;http-aggregator&quot;, new HttpObjectAggregator(65536)); ch.pipeline().addLast(&quot;http-encoder&quot;, new HttpResponseEncoder()); ch.pipeline().addLast(&quot;http-chunked&quot;, new ChunkedWriteHandler()); ch.pipeline().addLast(&quot;fileServerHandler&quot;, new HttpFileServerHandler(url)); 加入了请求消息解码器。HttpObjectAggregator这个作用是将多个消息转化成单一的FullHttpRequest或者FullHttpResponse。业务处理放在HttpFileServerHandler中]]></content>
      <categories>
        <category>netty</category>
      </categories>
      <tags>
        <tag>netty</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[netty编解码技术]]></title>
    <url>%2F2017%2F10%2F17%2Fnetty%E7%BC%96%E8%A7%A3%E7%A0%81%E6%8A%80%E6%9C%AF%2F</url>
    <content type="text"><![CDATA[java序列化序列化是干什么的为了保存在内存中的各种对象的状态（也就是实例变量，不是方法），并且可以把保存的对象状态再读出来。虽然你可以用你自己的各种各样的方法来保存object states，但是Java给你提供一种应该比你自己好的保存对象状态的机制，那就是序列化。 java序列化之后码流太大首先通过一个列子来看看 import java.io.ByteArrayOutputStream; import java.io.IOException; import java.io.ObjectOutputStream; import java.io.Serializable; import java.nio.ByteBuffer; public class UserInfo implements Serializable { /** * 默认的序列号 */ private static final long serialVersionUID = 1L; private String userName; private int id; public UserInfo buildUserName(String userName) { this.userName = userName; return this; } public UserInfo buildUserID(int id) { this.id = id; return this; } public final String getUserName() { return userName; } public final void setUserName(String userName) { this.userName = userName; } public final int getUserID() { return id; } public final void setUserID(int userID) { this.id = userID; } public byte[] codeC() { ByteBuffer buffer = ByteBuffer.allocate(1024); byte[] value = this.userName.getBytes(); buffer.putInt(value.length); buffer.put(value); buffer.putInt(this.id); buffer.flip(); value = null; byte[] result = new byte[buffer.remaining()]; buffer.get(result); return result; } public byte[] codeC(ByteBuffer buffer) { buffer.clear(); byte[] value = this.userName.getBytes(); buffer.putInt(value.length); buffer.put(value); buffer.putInt(this.id); buffer.flip(); value = null; byte[] result = new byte[buffer.remaining()]; buffer.get(result); return result; } public static void main(String[] args) throws IOException { System.out.println(&quot;------------大小----------&quot;); UserInfo info = new UserInfo(); info.buildUserID(100).buildUserName(&quot;Welcome to Netty&quot;); ByteArrayOutputStream bos = new ByteArrayOutputStream(); ObjectOutputStream os = new ObjectOutputStream(bos); os.writeObject(info); os.flush(); os.close(); byte[] b = bos.toByteArray(); System.out.println(&quot;The jdk serializable length is : &quot; + b.length); bos.close(); System.out.println(&quot;-------------------------------------&quot;); System.out.println(&quot;The byte array serializable length is : &quot; + info.codeC().length); System.out.println(&quot;------------时间----------&quot;); UserInfo info1 = new UserInfo(); info1.buildUserID(100).buildUserName(&quot;Welcome to Netty&quot;); int loop = 1000000; ByteArrayOutputStream bos1 = null; ObjectOutputStream os1 = null; long startTime = System.currentTimeMillis(); for (int i = 0; i &lt; loop; i++) { bos1 = new ByteArrayOutputStream(); os1 = new ObjectOutputStream(bos1); os1.writeObject(info1); os1.flush(); os1.close(); byte[] b1 = bos.toByteArray(); bos.close(); } long endTime = System.currentTimeMillis(); System.out.println(&quot;The jdk serializable cost time is : &quot; + (endTime - startTime) + &quot; ms&quot;); System.out.println(&quot;-------------------------------------&quot;); ByteBuffer buffer1 = ByteBuffer.allocate(1024); startTime = System.currentTimeMillis(); for (int i = 0; i &lt; loop; i++) { byte[] b1 = info.codeC(buffer1); } endTime = System.currentTimeMillis(); System.out.println(&quot;The byte array serializable cost time is : &quot; + (endTime - startTime) + &quot; ms&quot;); } } 运行结果是： 上面是两个测试结果前面都是默认序列化之后的数据大小和序列化的时间，下面都是使用NIO的编解码去对对象进行编码。可以看出默认的Serializable 接口还有一些瑕疵。 编码框架MessagePack编解码MessagePack的特点： 编解码高效，性能高 序列化之后的码流小 支持跨语言简单使用：POJO:需要加上@Message import org.msgpack.annotation.Message; @Message public class Student { private int id; private String name; public int getId() { return id; } public void setId(int id) { this.id = id; } public String getName() { return name; } public void setName(String name) { this.name = name; } @Override public String toString() { return &quot;Student [id=&quot; + id + &quot;, name=&quot; + name + &quot;]&quot;; } } 测试类： Student student = new Student(); student.setId(1); student.setName(&quot;lijia&quot;); MessagePack messagePack = new MessagePack(); try { byte[] write = messagePack.write(student); Value read = messagePack.read(write); System.out.println(read); } catch (IOException e) { e.printStackTrace(); } 运行结果： Protobuf编解码这个我弄了一天，找到一个windows版本的，但是在电脑上运行不了。大致了解一下吧1 .proto文件相当于确定数据协议，数据结构中存在哪些数据，数据类型是怎么样2 modifiers 2-1 required 不可以增加或删除的字段，必须初始化 2-2 optional 可选字段，可删除，可以不初始化 2-3 repeated 可重复字段， 对应到java文件里，生成的是List 3 Message在proto文件里，数据的协议时以Message的形式表现的。4 Build生成具体的java类时，例如Person.java，同时会存在build方法。文档的意思是对于转化后的数据，具有唯一性，build提供了便利的方法来初始化这些数据。这个先放着，以后回头好好研究这个协议。 Marshalling编解码由于Marshalling完全兼容java序列化。调用jboss的API对对象进行编解码。首先要引入jboss-marshalling的jar包。下面的代码是marshalling编解码 public final class MarshallingCodeCFactory { /** * 创建Jboss Marshalling解码器MarshallingDecoder * * @return */ public static MarshallingDecoder buildMarshallingDecoder() { final MarshallerFactory marshallerFactory = Marshalling .getProvidedMarshallerFactory(&quot;serial&quot;); final MarshallingConfiguration configuration = new MarshallingConfiguration(); configuration.setVersion(5); UnmarshallerProvider provider = new DefaultUnmarshallerProvider( marshallerFactory, configuration); MarshallingDecoder decoder = new MarshallingDecoder(provider, 1024); return decoder; } /** * 创建Jboss Marshalling编码器MarshallingEncoder * * @return */ public static MarshallingEncoder buildMarshallingEncoder() { final MarshallerFactory marshallerFactory = Marshalling .getProvidedMarshallerFactory(&quot;serial&quot;); final MarshallingConfiguration configuration = new MarshallingConfiguration(); configuration.setVersion(5); MarshallerProvider provider = new DefaultMarshallerProvider( marshallerFactory, configuration); MarshallingEncoder encoder = new MarshallingEncoder(provider); return encoder; } } 用法：还是以client为例 public class SubReqClient { public void connect(int port, String host) throws Exception { // 配置客户端NIO线程组 EventLoopGroup group = new NioEventLoopGroup(); try { Bootstrap b = new Bootstrap(); b.group(group).channel(NioSocketChannel.class) .option(ChannelOption.TCP_NODELAY, true) .handler(new ChannelInitializer&lt;SocketChannel&gt;() { @Override public void initChannel(SocketChannel ch) throws Exception { ch.pipeline().addLast(MarshallingCodeCFactory.buildMarshallingDecoder()); ch.pipeline().addLast(MarshallingCodeCFactory.buildMarshallingEncoder()); ch.pipeline().addLast(new SubReqClientHandler()); } }); // 发起异步连接操作 ChannelFuture f = b.connect(host, port).sync(); // 当代客户端链路关闭 f.channel().closeFuture().sync(); } finally { // 优雅退出，释放NIO线程组 group.shutdownGracefully(); } } /** * @param args * @throws Exception */ public static void main(String[] args) throws Exception { int port = 8080; if (args != null &amp;&amp; args.length &gt; 0) { try { port = Integer.valueOf(args[0]); } catch (NumberFormatException e) { // 采用默认值 } } new SubReqClient().connect(port, &quot;127.0.0.1&quot;); } } 还是在initChannel这个方法中添加 ch.pipeline().addLast(MarshallingCodeCFactory.buildMarshallingDecoder()); ch.pipeline().addLast(MarshallingCodeCFactory.buildMarshallingEncoder()); 服务端和这个一样。注意的是Marshalling支持拆包的处理。 总结性能对比 框架 字节大小（byte） 序列化时间 反序列化时间 messagepack 12793 2313335 529458 protebuf 6590 941790 408571 json 17181 1338371 1776519 讲了3中序列化框架和jdk自带的区别：MessagePack：在反序列化耗内存大小方面，msgpack远远超出json（1.6倍），由于内存是移动客户端场景下的重要指标，因此基本可以排除msgpack。protebuf：缺点是不支持半包处理，其余的都比megpack好marshalling：这个自带半包处理]]></content>
      <categories>
        <category>netty</category>
      </categories>
      <tags>
        <tag>netty</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[netty粘包拆包]]></title>
    <url>%2F2017%2F10%2F13%2Fnetty%E7%B2%98%E5%8C%85%E6%8B%86%E5%8C%85%2F</url>
    <content type="text"><![CDATA[什么是TCP粘包/拆包首先了解什么是长连接和短连接长连接： Client方与Server方先建立通讯连接，连接建立后不断开， 然后再进行报文发送和接收。短连接：Client方与Server每进行一次报文收发交易时才进行通讯连接，交易完毕后立即断开连接。 什么时候会出现粘包问题 如果用tcp每次发送数据，就与对方建立连接，然后双方发送完一段数据后，就关闭连接，这样就不会出现粘包问题（因为只有一种包结构,类似于http协议）。关闭连接主要要双方都发送close连接（参考tcp关闭协议）。如：A需要发送一段字符串给B，那么A与B建立连接，然后发送双方都默认好的协议字符如”hello，world”，然后B收到报文后，就将缓冲区数据接收,然后关闭连接，这样粘包问题不用考虑到，因为大家都知道是发送一段字符。 如果发送数据无结构，如文件传输，这样发送方只管发送，接收方只管接收存储就ok，也不用考虑粘包 在流传输中出现，UDP不会出现粘包，因为它有消息边界 如果双方建立连接，需要在连接后一段时间内发送不同结构数据，如连接后，有好几种结构： (1)：”Hello，world” (2)：”Hello，lijia”如果发送方连续将这两个包都发出去了，接收方接受的信息可能是”Hello，worldHello，lijia“。这就需要拆包，所以双方应该规定一个较好的包结构，所以一般可能会在头加一个数据长度之类的包，以确保接收。所以：粘包出现原因1 发送端需要等缓冲区满才发送出去，造成粘包2 接收方不及时接收缓冲区的包，造成多个包接收下面的图显示几种可能性 客服端发送两个包给服务端，服务端读取字节数不确定，可能是上面三种情况： a、分别获取两个独立的包，不存在粘包，拆包的情况 b、一次获取两个完整的数据包，这就是粘包 c、第一次获取D1和部分D2数据，第二次获取D2剩余内容，这就是拆包 还有一种可能，就是多次拆包，即服务端接收划窗小，而D1，D2又比较大 粘包的解决策略1、发送端给每个数据包添加包首部，首部中应该至少包含数据包的长度，这样接收端在接收到数据后，通过读取包首部的长度字段，便知道每一个数据包的实际长度了。2、发送端将每个数据包封装为固定长度（不够的可以通过补0填充），这样接收端每次从接收缓冲区中读取固定长度的数据就自然而然的把每个数据包拆分开来。3、可以在数据包之间设置边界，如添加特殊符号，这样，接收端通过这个边界就可以将不同的数据包拆分开。4、其他首先模拟去看着这个问题TimeServer import io.netty.bootstrap.ServerBootstrap; import io.netty.channel.ChannelFuture; import io.netty.channel.ChannelInitializer; import io.netty.channel.ChannelOption; import io.netty.channel.EventLoopGroup; import io.netty.channel.nio.NioEventLoopGroup; import io.netty.channel.socket.SocketChannel; import io.netty.channel.socket.nio.NioServerSocketChannel; public class TimeServer { public void bind(int port) throws Exception { // 配置服务端的NIO线程组 EventLoopGroup bossGroup = new NioEventLoopGroup(); EventLoopGroup workerGroup = new NioEventLoopGroup(); try { ServerBootstrap b = new ServerBootstrap(); b.group(bossGroup, workerGroup) .channel(NioServerSocketChannel.class) .option(ChannelOption.SO_BACKLOG, 1024) .childHandler(new ChildChannelHandler()); // 绑定端口，同步等待成功 ChannelFuture f = b.bind(port).sync(); // 等待服务端监听端口关闭 f.channel().closeFuture().sync(); } finally { // 优雅退出，释放线程池资源 bossGroup.shutdownGracefully(); workerGroup.shutdownGracefully(); } } private class ChildChannelHandler extends ChannelInitializer&lt;SocketChannel&gt; { @Override protected void initChannel(SocketChannel arg0) throws Exception { arg0.pipeline().addLast(new TimeServerHandler()); } } /** * @param args * @throws Exception */ public static void main(String[] args) throws Exception { int port = 8080; if (args != null &amp;&amp; args.length &gt; 0) { try { port = Integer.valueOf(args[0]); } catch (NumberFormatException e) { // 采用默认值 } } new TimeServer().bind(port); } }TimeServerHandler import io.netty.buffer.ByteBuf; import io.netty.buffer.Unpooled; import io.netty.channel.ChannelHandlerAdapter; import io.netty.channel.ChannelHandlerContext; public class TimeServerHandler extends ChannelHandlerAdapter { private int counter; @Override public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception { ByteBuf buf = (ByteBuf) msg; byte[] req = new byte[buf.readableBytes()]; buf.readBytes(req); String body = new String(req, &quot;UTF-8&quot;).substring(0, req.length - System.getProperty(&quot;line.separator&quot;).length()); System.out.println(&quot;The time server receive order : &quot; + body + &quot; ; the counter is : &quot; + ++counter); String currentTime = &quot;QUERY TIME ORDER&quot;.equalsIgnoreCase(body) ? new java.util.Date( System.currentTimeMillis()).toString() : &quot;BAD ORDER&quot;; currentTime = currentTime + System.getProperty(&quot;line.separator&quot;); ByteBuf resp = Unpooled.copiedBuffer(currentTime.getBytes()); ctx.writeAndFlush(resp); } @Override public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) { ctx.close(); } }TimeClient import io.netty.bootstrap.Bootstrap; import io.netty.channel.ChannelFuture; import io.netty.channel.ChannelInitializer; import io.netty.channel.ChannelOption; import io.netty.channel.EventLoopGroup; import io.netty.channel.nio.NioEventLoopGroup; import io.netty.channel.socket.SocketChannel; import io.netty.channel.socket.nio.NioSocketChannel; public class TimeClient { public void connect(int port, String host) throws Exception { // 配置客户端NIO线程组 EventLoopGroup group = new NioEventLoopGroup(); try { Bootstrap b = new Bootstrap(); b.group(group).channel(NioSocketChannel.class) .option(ChannelOption.TCP_NODELAY, true) .handler(new ChannelInitializer&lt;SocketChannel&gt;() { @Override public void initChannel(SocketChannel ch) throws Exception { ch.pipeline().addLast(new TimeClientHandler()); } }); // 发起异步连接操作 ChannelFuture f = b.connect(host, port).sync(); // 当代客户端链路关闭 f.channel().closeFuture().sync(); } finally { // 优雅退出，释放NIO线程组 group.shutdownGracefully(); } } /** * @param args * @throws Exception */ public static void main(String[] args) throws Exception { int port = 8080; if (args != null &amp;&amp; args.length &gt; 0) { try { port = Integer.valueOf(args[0]); } catch (NumberFormatException e) { // 采用默认值 } } new TimeClient().connect(port, &quot;127.0.0.1&quot;); } }TimeClientHandler import io.netty.buffer.ByteBuf; import io.netty.buffer.Unpooled; import io.netty.channel.ChannelHandlerAdapter; import io.netty.channel.ChannelHandlerContext; import java.util.logging.Logger; public class TimeClientHandler extends ChannelHandlerAdapter { private static final Logger logger = Logger .getLogger(TimeClientHandler.class.getName()); private int counter; private byte[] req; /** * Creates a client-side handler. */ public TimeClientHandler() { req = (&quot;QUERY TIME ORDER&quot; + System.getProperty(&quot;line.separator&quot;)) .getBytes(); } @Override public void channelActive(ChannelHandlerContext ctx) { ByteBuf message = null; for (int i = 0; i &lt; 100; i++) { message = Unpooled.buffer(req.length); message.writeBytes(req); ctx.writeAndFlush(message); } } @Override public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception { ByteBuf buf = (ByteBuf) msg; byte[] req = new byte[buf.readableBytes()]; buf.readBytes(req); String body = new String(req, &quot;UTF-8&quot;); System.out.println(&quot;Now is : &quot; + body + &quot; ; the counter is : &quot; + ++counter); } @Override public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) { // 释放资源 logger.warning(&quot;Unexpected exception from downstream : &quot; + cause.getMessage()); ctx.close(); } }执行结果： 服务端收到2条消息，理论上是100条，发生了粘包。客户端也只收到了2条消息 Netty如何去处理这个问题呢LineBasedFrameDecoder在上面代码的TimeServer和ClientServer的initChannel方法中，分别加上 arg0.pipeline().addLast(new LineBasedFrameDecoder(1024)); arg0.pipeline().addLast(new StringDecoder()); 和 ch.pipeline().addLast(new LineBasedFrameDecoder(1024)); ch.pipeline().addLast(new StringDecoder());如下图： 然后将TimeServerHandler和TimeClientHandler中channelRead方法的获取body字符串改成TimeServerHandler中修改： public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception { String body = (String) msg; System.out.println(&quot;The time server receive order : &quot; + body + &quot; ; the counter is : &quot; + ++counter); String currentTime = &quot;QUERY TIME ORDER&quot;.equalsIgnoreCase(body) ? new java.util.Date( System.currentTimeMillis()).toString() : &quot;BAD ORDER&quot;; currentTime = currentTime + System.getProperty(&quot;line.separator&quot;); ByteBuf resp = Unpooled.copiedBuffer(currentTime.getBytes()); ctx.writeAndFlush(resp); } TimeClientHandler中修改： @Override public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception { String body = (String) msg; System.out.println(&quot;Now is : &quot; + body + &quot; ; the counter is : &quot; + ++counter); } 那么再执行代码，会出现 这就是正确结果。 LineBasedFrameDecoder的原理LineBasedFrameDecoder的工作原理就是依次遍历ByteBuf中的可读字节，判断是否有”\n“或者”\r\n”，如果有，就以此为结束位置，从可读索引到结束位置区间的字节组成了一个字符串。它是以换行符为结束标志的解码器，支持携带结束符或者不携带两种方式，支持配置单行的最大长度。如果读到最大长度还没有发现换行符，就会抛出异常。同时忽略之前读到的字节。如果不是以换行结束呢，怎么解决？ DelimiterBasedFrameDecoderEchoServer : import io.netty.bootstrap.ServerBootstrap; import io.netty.buffer.ByteBuf; import io.netty.buffer.Unpooled; import io.netty.channel.ChannelFuture; import io.netty.channel.ChannelInitializer; import io.netty.channel.ChannelOption; import io.netty.channel.EventLoopGroup; import io.netty.channel.nio.NioEventLoopGroup; import io.netty.channel.socket.SocketChannel; import io.netty.channel.socket.nio.NioServerSocketChannel; import io.netty.handler.codec.DelimiterBasedFrameDecoder; import io.netty.handler.codec.string.StringDecoder; import io.netty.handler.logging.LogLevel; import io.netty.handler.logging.LoggingHandler; public class EchoServer { public void bind(int port) throws Exception { // 配置服务端的NIO线程组 EventLoopGroup bossGroup = new NioEventLoopGroup(); EventLoopGroup workerGroup = new NioEventLoopGroup(); try { ServerBootstrap b = new ServerBootstrap(); b.group(bossGroup, workerGroup) .channel(NioServerSocketChannel.class) .option(ChannelOption.SO_BACKLOG, 100) .handler(new LoggingHandler(LogLevel.INFO)) .childHandler(new ChannelInitializer&lt;SocketChannel&gt;() { @Override public void initChannel(SocketChannel ch) throws Exception { ByteBuf delimiter = Unpooled.copiedBuffer(&quot;$_&quot; .getBytes()); ch.pipeline().addLast( new DelimiterBasedFrameDecoder(1024, delimiter)); ch.pipeline().addLast(new StringDecoder()); ch.pipeline().addLast(new EchoServerHandler()); } }); // 绑定端口，同步等待成功 ChannelFuture f = b.bind(port).sync(); // 等待服务端监听端口关闭 f.channel().closeFuture().sync(); } finally { // 优雅退出，释放线程池资源 bossGroup.shutdownGracefully(); workerGroup.shutdownGracefully(); } } public static void main(String[] args) throws Exception { int port = 8080; if (args != null &amp;&amp; args.length &gt; 0) { try { port = Integer.valueOf(args[0]); } catch (NumberFormatException e) { // 采用默认值 } } new EchoServer().bind(port); } } EchoServerHandler : import io.netty.buffer.ByteBuf; import io.netty.buffer.Unpooled; import io.netty.channel.ChannelHandler.Sharable; import io.netty.channel.ChannelHandlerAdapter; import io.netty.channel.ChannelHandlerContext; @Sharable public class EchoServerHandler extends ChannelHandlerAdapter { int counter = 0; @Override public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception { String body = (String) msg; System.out.println(&quot;This is &quot; + ++counter + &quot; times receive client : [&quot; + body + &quot;]&quot;); body += &quot;$_&quot;; ByteBuf echo = Unpooled.copiedBuffer(body.getBytes()); ctx.writeAndFlush(echo); } @Override public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) { cause.printStackTrace(); ctx.close();// 发生异常，关闭链路 } } EchoClient : import io.netty.bootstrap.Bootstrap; import io.netty.buffer.ByteBuf; import io.netty.buffer.Unpooled; import io.netty.channel.ChannelFuture; import io.netty.channel.ChannelInitializer; import io.netty.channel.ChannelOption; import io.netty.channel.EventLoopGroup; import io.netty.channel.nio.NioEventLoopGroup; import io.netty.channel.socket.SocketChannel; import io.netty.channel.socket.nio.NioSocketChannel; import io.netty.handler.codec.DelimiterBasedFrameDecoder; import io.netty.handler.codec.string.StringDecoder; public class EchoClient { public void connect(int port, String host) throws Exception { // 配置客户端NIO线程组 EventLoopGroup group = new NioEventLoopGroup(); try { Bootstrap b = new Bootstrap(); b.group(group).channel(NioSocketChannel.class) .option(ChannelOption.TCP_NODELAY, true) .handler(new ChannelInitializer&lt;SocketChannel&gt;() { @Override public void initChannel(SocketChannel ch) throws Exception { ByteBuf delimiter = Unpooled.copiedBuffer(&quot;$_&quot; .getBytes()); ch.pipeline().addLast( new DelimiterBasedFrameDecoder(1024, delimiter)); ch.pipeline().addLast(new StringDecoder()); ch.pipeline().addLast(new EchoClientHandler()); } }); // 发起异步连接操作 ChannelFuture f = b.connect(host, port).sync(); // 当代客户端链路关闭 f.channel().closeFuture().sync(); } finally { // 优雅退出，释放NIO线程组 group.shutdownGracefully(); } } /** * @param args * @throws Exception */ public static void main(String[] args) throws Exception { int port = 8080; if (args != null &amp;&amp; args.length &gt; 0) { try { port = Integer.valueOf(args[0]); } catch (NumberFormatException e) { // 采用默认值 } } new EchoClient().connect(port, &quot;127.0.0.1&quot;); } } TimeClientHandler : import io.netty.buffer.Unpooled; import io.netty.channel.ChannelHandlerAdapter; import io.netty.channel.ChannelHandlerContext; public class TimeClientHandler extends ChannelHandlerAdapter { private int counter; static final String ECHO_REQ = &quot;Hi, Lilinfeng. Welcome to Netty.$_&quot;; /** * Creates a client-side handler. */ public TimeClientHandler () { } @Override public void channelActive(ChannelHandlerContext ctx) { // ByteBuf buf = UnpooledByteBufAllocator.DEFAULT.buffer(ECHO_REQ // .getBytes().length); // buf.writeBytes(ECHO_REQ.getBytes()); for (int i = 0; i &lt; 10; i++) { ctx.writeAndFlush(Unpooled.copiedBuffer(ECHO_REQ.getBytes())); } } @Override public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception { System.out.println(&quot;This is &quot; + ++counter + &quot; times receive server : [&quot;+ msg + &quot;]&quot;); } @Override public void channelReadComplete(ChannelHandlerContext ctx) throws Exception { ctx.flush(); } @Override public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) { cause.printStackTrace(); ctx.close(); } } 运行之后出现 如果把EchoServer的ch.pipeline().addLast(new DelimiterBasedFrameDecoder(1024,delimiter));注释掉那么server获取的字符串就是 由于没有分隔符解码器，导致了一次性读取客户端所有数据，就是典型的tcp粘包问题。 FixedLengthFrameDecoderEchoServer ： import io.netty.bootstrap.ServerBootstrap; import io.netty.channel.ChannelFuture; import io.netty.channel.ChannelInitializer; import io.netty.channel.ChannelOption; import io.netty.channel.EventLoopGroup; import io.netty.channel.nio.NioEventLoopGroup; import io.netty.channel.socket.SocketChannel; import io.netty.channel.socket.nio.NioServerSocketChannel; import io.netty.handler.codec.FixedLengthFrameDecoder; import io.netty.handler.codec.string.StringDecoder; import io.netty.handler.logging.LogLevel; import io.netty.handler.logging.LoggingHandler; public class EchoServer { public void bind(int port) throws Exception { // 配置服务端的NIO线程组 EventLoopGroup bossGroup = new NioEventLoopGroup(); EventLoopGroup workerGroup = new NioEventLoopGroup(); try { ServerBootstrap b = new ServerBootstrap(); b.group(bossGroup, workerGroup) .channel(NioServerSocketChannel.class) .option(ChannelOption.SO_BACKLOG, 100) .handler(new LoggingHandler(LogLevel.INFO)) .childHandler(new ChannelInitializer&lt;SocketChannel&gt;() { @Override public void initChannel(SocketChannel ch) throws Exception { ch.pipeline().addLast( new FixedLengthFrameDecoder(20)); ch.pipeline().addLast(new StringDecoder()); ch.pipeline().addLast(new EchoServerHandler()); } }); // 绑定端口，同步等待成功 ChannelFuture f = b.bind(port).sync(); // 等待服务端监听端口关闭 f.channel().closeFuture().sync(); } finally { // 优雅退出，释放线程池资源 bossGroup.shutdownGracefully(); workerGroup.shutdownGracefully(); } } public static void main(String[] args) throws Exception { int port = 8080; if (args != null &amp;&amp; args.length &gt; 0) { try { port = Integer.valueOf(args[0]); } catch (NumberFormatException e) { // 采用默认值 } } new EchoServer().bind(port); } } EchoServerHandler ： import io.netty.channel.ChannelHandler.Sharable; import io.netty.channel.ChannelHandlerAdapter; import io.netty.channel.ChannelHandlerContext; @Sharable public class EchoServerHandler extends ChannelHandlerAdapter { @Override public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception { System.out.println(&quot;Receive client : [&quot; + msg + &quot;]&quot;); } @Override public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) { cause.printStackTrace(); ctx.close();// 发生异常，关闭链路 } } 启动EchoServer然后从cmd中启动telnet localhost 8080,我以1234567890一直循环输入，但是由于FixedLengthFrameDecoder设置的大小为20，那么每次不超过20就不会返回，如果超过20，输出20个字符，剩下的以另一个包形式返回。 总结LineBasedFrameDecoder:以换行处理粘包DelimiterBasedFrameDecoder：设置固定的分隔符，然后解码去解决粘包问题FixedLengthFrameDecoder：对固定长度的消息进行自动解码]]></content>
      <categories>
        <category>netty</category>
      </categories>
      <tags>
        <tag>netty</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[netty入门]]></title>
    <url>%2F2017%2F10%2F13%2Fnetty%E5%85%A5%E9%97%A8%2F</url>
    <content type="text"><![CDATA[什么是nettyNetty 是一个基于 JAVA NIO 类库的异步通信框架，它的架构特点是：异步非阻塞、基于事件驱动、高性能、高可靠性和高可定制性。 Netty 能够做什么 开发异步、非阻塞的 TCP 网络应用程序； 开发异步、非阻塞的 UDP 网络应用程序； 开发异步文件传输应用程序； 开发异步 HTTP 服务端和客户端应用程序； 提供对多种编解码框架的集成，包括谷歌的 Protobuf、Jbossmarshalling、Java 序列化、压缩编解码、XML 解码、字符串编解码等，这些编解码框架可以被用户直接使用； 提供形式多样的编解码基础类库，可以非常方便的实现私有协议栈编解码框架的二次定制和开发； 基于职责链模式的 Pipeline-Handler 机制，用户可以非常方便的对网络事件进行拦截和定制； 所有的 IO 操作都是异步的，用户可以通过 Future-Listener 机制主动 Get 结果或者由 IO 线程操作完成之后主动 Notify 结果，用户的业务线程不需要同步等待； IP 黑白名单控制； 打印消息码流； 流量控制和整形； 性能统计； 基于链路空闲事件检测的心跳检测 …… Netty总体结构 Netty网络模型Netty是典型的Reactor模型结构。Netty中的Reactor模型主要由多路复用器(Acceptor)、事件分发器(Dispatcher)、事件处理器(Handler)组成，可以分为三种。 单线程模型所有I/O操作都由一个线程完成，即多路复用、事件分发和处理都是在一个Reactor线程上完成的。 对于一些小容量应用场景，可以使用单线程模型。但是对于高负载、大并发的应用却不合适，主要原因如下： 一个线程同时处理成百上千的链路，性能上无法支撑，即便CPU负荷达到100%，也无法满足海量消息的编码、解码、读取和发送； 当负载过重后，处理速度将变慢，这会导致大量客户端连接超时，超时之后往往会进行重发，最终会导致大量消息积压和处理超时，成为系统的性能瓶颈； 一旦单线程意外跑飞，或者进入死循环，会导致整个系统通信模块不可用，不能接收和处理外部消息，造成节点故障，可靠性不高。多线程模型为了解决单线程模型存在的一些问题，演化而来的Reactor线程模型。 多线程模型的特点： 有专门一个Acceptor线程用于监听服务端，接收客户端的TCP连接请求； 网络IO的读写操作由一个NIO线程池负责，线程池可以采用标准的JDK线程池实现，包含一个任务队列和N个可用的线程，由这些NIO线程负责消息的读取、解码、编码和发送； 一个NIO线程可以同时处理多条链路，但是一个链路只能对应一个NIO线程，防止发生并发操作问题。 在绝大多数场景下，Reactor多线程模型都可以满足性能需求；但是，在极特殊应用场景中，一个NIO线程负责监听和处理所有的客户端连接可能会存在性能问题。例如百万客户端并发连接，或者服务端需要对客户端的握手消息进行安全认证，认证本身非常损耗性能。在这类场景下，单独一个Acceptor线程可能会存在性能不足问题，为了解决性能问题，产生了第三种Reactor线程模型-主从Reactor多线程模型。 主从多线程模型采用多个reactor，每个reactor都在自己单独的线程里执行。如果是多核，则可以同时响应多个客户端的请求，一旦链路建立成功就将链路注册到负责I/O读写的SubReactor线程池上。 事实上，Netty的线程模型并非固定不变，在启动辅助类中创建不同的EventLoopGroup实例并通过适当的参数配置，就可以支持上述三种Reactor线程模型。正是因为Netty对Reactor线程模型的支持提供了灵活的定制能力，所以可以满足不同业务场景的性能需求。 入门实例在用netty之前，先看看NIO的步骤 创建ServerSocketChannel，配置它为非阻塞模式 绑定监听，配置TCP参数，例如backlog大小 创建一个独立的I/O线程，用于轮询多路复用器Selector 创建Selector，将之前创建的ServerSocketChannel注册到Selector上，监听SelectKey.ACCEPT 启动I/O线程，在循环体中执行Selector.select()方法，轮询就绪的Channel 当轮询到就绪状态的Channel时，需要对其进行判断，如果是OP_APPECT状态，说明是新客户端接入，则调用ServerSocketChannel.accept()方法接受新的客户端 设置新接入的客户端链路SocketChannel为非阻塞模式，配置其他的一些TCP参数 将SocketChannel注册到Selector，监听OP_READ操作位 如果轮询的Channel为OP_READ，则说明SocketChannel中有新的就绪的数据包需要读取，则构造ByteBuffer对象，读取数据包。 如果轮询的Channel为OP_WRITE，说明还有数据没有发送完，需要继续发送用netty来做呢，还是用李林峰老师的代码来理解，netty版本是 &lt;dependency&gt; &lt;groupId&gt;io.netty&lt;/groupId&gt; &lt;artifactId&gt;netty-all&lt;/artifactId&gt; &lt;version&gt;5.0.0.Alpha1&lt;/version&gt; &lt;/dependency&gt; 服务端TimeServer： import io.netty.bootstrap.ServerBootstrap; import io.netty.channel.ChannelFuture; import io.netty.channel.ChannelInitializer; import io.netty.channel.ChannelOption; import io.netty.channel.EventLoopGroup; import io.netty.channel.nio.NioEventLoopGroup; import io.netty.channel.socket.SocketChannel; import io.netty.channel.socket.nio.NioServerSocketChannel; public class TimeServer { public void bind(int port) throws Exception { // 配置服务端的NIO两个线程组，其实就是Reactor线程组。 //创建两个的原因就是一个是服务器接收客户端的连接，一个是进行SocketChannel网络读写 EventLoopGroup bossGroup = new NioEventLoopGroup(); EventLoopGroup workerGroup = new NioEventLoopGroup(); try { //这个b对象是netty用于启动NIO服务端的辅助启动类，目的是降低服务器端的开发复杂度 ServerBootstrap b = new ServerBootstrap(); //将两个线程组当参数传递到启动类中 b.group(bossGroup, workerGroup) //设置Channel为NioServerSocketChannel，对应的就是JDK中的ServerSocketChannel .channel(NioServerSocketChannel.class) //设置TCP参数，即backlog为1024 .option(ChannelOption.SO_BACKLOG, 1024) //绑定I/O事件的处理类ChildChannelHandler .childHandler(new ChildChannelHandler()); // 绑定端口，同步等待成功 ChannelFuture f = b.bind(port).sync(); // 异步阻塞，等待服务端监听端口关闭 f.channel().closeFuture().sync(); } finally { // 优雅退出，释放线程池资源 bossGroup.shutdownGracefully(); workerGroup.shutdownGracefully(); } } private class ChildChannelHandler extends ChannelInitializer&lt;SocketChannel&gt; { @Override protected void initChannel(SocketChannel arg0) throws Exception { arg0.pipeline().addLast(new TimeServerHandler()); } } /** * @param args * @throws Exception */ public static void main(String[] args) throws Exception { int port = 8080; if (args != null &amp;&amp; args.length &gt; 0) { try { port = Integer.valueOf(args[0]); } catch (NumberFormatException e) { // 采用默认值 } } new TimeServer().bind(port); } } TimeServerHandler： import io.netty.buffer.ByteBuf; import io.netty.buffer.Unpooled; import io.netty.channel.ChannelHandlerAdapter; import io.netty.channel.ChannelHandlerContext; //继承了ChannelHandlerAdapter，用于网络事件的读写操作 public class TimeServerHandler extends ChannelHandlerAdapter { public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception { ByteBuf buf = (ByteBuf) msg; //buf.readableBytes()获取缓冲区可读的字节数，并根据可读的字节数创建数组 byte[] req = new byte[buf.readableBytes()]; //复制到新的数组 buf.readBytes(req); //获取请求信息 String body = new String(req, &quot;UTF-8&quot;); System.out.println(&quot;The time server receive order : &quot; + body); //如果是QUERY TIME ORDER创建应答信息并返回给客户端 String currentTime = &quot;QUERY TIME ORDER&quot;.equalsIgnoreCase(body) ? new java.util.Date( System.currentTimeMillis()).toString() : &quot;BAD ORDER&quot;; ByteBuf resp = Unpooled.copiedBuffer(currentTime.getBytes()); ctx.write(resp); } public void channelReadComplete(ChannelHandlerContext ctx) throws Exception { //将消息发送队列中的消息写到SocketChannel中发送给对方 ctx.flush(); } @Override public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) { //发送异常时关闭 ctx.close(); } } 客户端TimeClient： import io.netty.bootstrap.Bootstrap; import io.netty.channel.ChannelFuture; import io.netty.channel.ChannelInitializer; import io.netty.channel.ChannelOption; import io.netty.channel.EventLoopGroup; import io.netty.channel.nio.NioEventLoopGroup; import io.netty.channel.socket.SocketChannel; import io.netty.channel.socket.nio.NioSocketChannel; public class TimeClient { public void connect(int port, String host) throws Exception { // 配置客户端NIO线程组，这个和server一样 EventLoopGroup group = new NioEventLoopGroup(); try { Bootstrap b = new Bootstrap(); b.group(group).channel(NioSocketChannel.class) .option(ChannelOption.TCP_NODELAY, true) .handler(new ChannelInitializer&lt;SocketChannel&gt;() { @Override public void initChannel(SocketChannel ch) throws Exception { ch.pipeline().addLast(new TimeClientHandler()); } }); // 发起异步连接操作，调用sync等待连接成功 ChannelFuture f = b.connect(host, port).sync(); // 当代客户端链路关闭 f.channel().closeFuture().sync(); } finally { // 优雅退出，释放NIO线程组 group.shutdownGracefully(); } } /** * @param args * @throws Exception */ public static void main(String[] args) throws Exception { int port = 8080; if (args != null &amp;&amp; args.length &gt; 0) { try { port = Integer.valueOf(args[0]); } catch (NumberFormatException e) { // 采用默认值 } } new TimeClient().connect(port, &quot;127.0.0.1&quot;); } } TimeClientHandler ： import io.netty.buffer.ByteBuf; import io.netty.buffer.Unpooled; import io.netty.channel.ChannelHandlerAdapter; import io.netty.channel.ChannelHandlerContext; import java.util.logging.Logger; public class TimeClientHandler extends ChannelHandlerAdapter { private static final Logger logger = Logger .getLogger(TimeClientHandler.class.getName()); private final ByteBuf firstMessage; /** * Creates a client-side handler. */ public TimeClientHandler() { byte[] req = &quot;QUERY TIME ORDER&quot;.getBytes(); firstMessage = Unpooled.buffer(req.length); firstMessage.writeBytes(req); } //当客户端和服务端的TCP链路建立成功之后，会调用该方法，发送查询时间的指令给服务器 public void channelActive(ChannelHandlerContext ctx) { ctx.writeAndFlush(firstMessage); } //当服务器返回应答信息时，该方法被调用，从netty的ByteBuf中读取并打印应答信息 public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception { ByteBuf buf = (ByteBuf) msg; byte[] req = new byte[buf.readableBytes()]; buf.readBytes(req); String body = new String(req, &quot;UTF-8&quot;); System.out.println(&quot;Now is : &quot; + body); } @Override public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) { // 发生异常，打印异常日志，释放客户端资源 logger.warning(&quot;Unexpected exception from downstream : &quot; + cause.getMessage()); ctx.close(); } } 运行结果是：]]></content>
      <categories>
        <category>netty</category>
      </categories>
      <tags>
        <tag>netty</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Selector]]></title>
    <url>%2F2017%2F10%2F12%2FSelector%2F</url>
    <content type="text"><![CDATA[选择器的概念Selector是Java NIO中的一个组件，用于检查一个或多个NIO Channel的状态是否处于可读、可写。如此可以实现单线程管理多个channels,也就是可以管理多个网络链接。 为什么要用选择器用单线程处理多个channels的好处是我需要更少的线程来处理channel。实际上，你甚至可以用一个线程来处理所有的channels。从操作系统的角度来看，切换线程开销是比较昂贵的，并且每个线程都需要占用系统资源，因此用的线程越少越好。但是现在的操作系统和CPU内核已经越来越好了（不在此说了）。通过一个图来表示一个线程管理selector Selector操作创建SelectorSelector selector = Selector.open(); 注册Channel到Selector上为了将Channel和Selector配合使用，必须将Channel注册到Selector上。通过SelectableChannel.register()来实现，如下 channel.configureBlocking(false); SelectionKey key = channel.register(selector, Selectionkey.OP_READ); Channel必须是非阻塞的。所以FileChannel不适用Selector，因为FileChannel不能切换为非阻塞模式。Socket channel可以正常使用。注意register()的第二个参数，这是一个interest集合，意思啥通过Selector监听Channel对什么事件感兴趣，可以监听四种不通类型的事件： Connect(SelectionKey.OP_CONNECT) Accept(SelectionKey.OP_ACCEPT) Read(SelectionKey.OP_READ) Writer(SelectionKey.OP_WRITE) 如果对多个事件感兴趣可利用位的或运算结合多个常量 int interestSet = SelectionKey.OP_READ | SelectionKey.OP_WRITE; SelectionKey代表了Secletor和SelectableChannel的注册关系 key.attachment(); //返回SelectionKey的attachment，attachment可以在注册channel的时候指定。 key.channel(); // 返回该SelectionKey对应的channel。 key.selector(); // 返回该SelectionKey对应的Selector。 key.interestOps(); //返回代表需要Selector监控的IO操作的bit mask key.readyOps(); //返回一个bit mask，代表在相应channel上可以进行的IO操作。 key.attachment()可以将一个对象或者更多信息附着到SelectionKey上，这样就能方便的识别某个给定的通道。例如，可以附加 与通道一起使用的Buffer，或是包含聚集数据的某个对象。使用方法如下： selectionKey.attach(theObject); Object attachedObj = selectionKey.attachment(); 还可以在用register()方法向Selector注册Channel的时候附加对象 SelectionKey key = channel.register(selector, SelectionKey.OP_READ, theObject); key.channel() &amp;&amp; key.selector()从SelectionKey访问Channel和Selector很简单 Channel channel = selectionKey.channel(); Selector selector = selectionKey.selector(); key.interestOps()就像向Selector注册通道一节中所描述的，interest集合是你所选择的感兴趣的事件集合。可以通过SelectionKey读写interest集合 int interestSet = selectionKey.interestOps(); boolean isInterestedInAccept = (interestSet &amp; SelectionKey.OP_ACCEPT) == SelectionKey.OP_ACCEPT； boolean isInterestedInConnect = interestSet &amp; SelectionKey.OP_CONNECT; boolean isInterestedInRead = interestSet &amp; SelectionKey.OP_READ; boolean isInterestedInWrite = interestSet &amp; SelectionKey.OP_WRITE; key.readyOps()ready 集合是通道已经准备就绪的操作的集合。在一次选择(Selection)之后，你会首先访问这个ready set。Selection将在下一小节进行解释。可以这样访问ready集合 int readySet = selectionKey.readyOps(); 可以用像检测interest集合那样的方法，来检测channel中什么事件或操作已经就绪。但是，也可以使用以下四个方法，它们都会返回一个布尔类型： selectionKey.isAcceptable(); selectionKey.isConnectable(); selectionKey.isReadable(); selectionKey.isWritable(); 通过Selector选择通道一旦向Selector注册了一或多个通道，就可以调用几个重载的select()方法。这些方法返回你所感兴趣的事件（如连接、接受、读或写）已经准备就绪的那些通道。换句话说，如果你对“读就绪”的通道感兴趣，select()方法会返回读事件已经就绪的那些通道。 int select() int select(long timeout) int selectNow() select()阻塞到至少有一个通道在你注册的事件上就绪了。 select(long timeout)和select()一样，除了最长会阻塞timeout毫秒(参数)。 selectNow()不会阻塞，不管什么通道就绪都立刻返回（译者注：此方法执行非阻塞的选择操作。如果自从前一次选择操作后，没有通道变成可选择的，则此方法直接返回零。）。 select()方法返回的int值表示有多少通道已经就绪。亦即，自上次调用select()方法后有多少通道变成就绪状态。如果调用select()方法，因为有一个通道变成就绪状态，返回了1，若再次调用select()方法，如果另一个通道就绪了，它会再次返回1。如果对第一个就绪的channel没有做任何操作，现在就有两个就绪的通道，但在每次select()方法调用之间，只有一个通道就绪了。 selectedKeys()一旦调用了select()方法，并且返回值表明有一个或更多个通道就绪了，然后可以通过调用selector的selectedKeys()方法，访问“已选择键集（selected key set）”中的就绪通道。如下所示： Set selectedKeys = selector.selectedKeys(); 可以遍历这个已选择的键集合来访问就绪的通道 Set selectedKeys = selector.selectedKeys(); Iterator keyIterator = selectedKeys.iterator(); while(keyIterator.hasNext()) { SelectionKey key = keyIterator.next(); if(key.isAcceptable()) { // a connection was accepted by a ServerSocketChannel. } else if (key.isConnectable()) { // a connection was established with a remote server. } else if (key.isReadable()) { // a channel is ready for reading } else if (key.isWritable()) { // a channel is ready for writing } keyIterator.remove(); } 这个循环遍历已选择键集中的每个键，并检测各个键所对应的通道的就绪事件。 注意每次迭代末尾的keyIterator.remove()调用。Selector不会自己从已选择键集中移除SelectionKey实例。必须在处理完通道时自己移除。下次该通道变成就绪时，Selector会再次将其放入已选择键集中。 SelectionKey.channel()方法返回的通道需要转型成你要处理的类型，如ServerSocketChannel或SocketChannel等。wakeUp() 某个线程调用select()方法后阻塞了，即使没有通道已经就绪，也有办法让其从select()方法返回。只要让其它线程在第一个线程调用select()方法的那个对象上调用Selector.wakeup()方法即可。阻塞在select()方法上的线程会立马返回。 如果有其它线程调用了wakeup()方法，但当前没有线程阻塞在select()方法上，下个调用select()方法的线程会立即“醒来（wake up）”。close() 用完Selector后调用其close()方法会关闭该Selector，且使注册到该Selector上的所有SelectionKey实例无效。通道本身并不会关闭。 完整的示例这里有一个完整的示例，打开一个Selector，注册一个通道注册到这个Selector上(通道的初始化过程略去),然后持续监控这个Selector的四种事件（接受，连接，读，写）是否就绪。 Selector selector = Selector.open(); channel.configureBlocking(false); SelectionKey key = channel.register(selector, SelectionKey.OP_READ); while(true) { int readyChannels = selector.select(); if(readyChannels == 0) continue; Set selectedKeys = selector.selectedKeys(); Iterator keyIterator = selectedKeys.iterator(); while(keyIterator.hasNext()) { SelectionKey key = keyIterator.next(); if(key.isAcceptable()) { // a connection was accepted by a ServerSocketChannel. } else if (key.isConnectable()) { // a connection was established with a remote server. } else if (key.isReadable()) { // a channel is ready for reading } else if (key.isWritable()) { // a channel is ready for writing } keyIterator.remove(); } } 引用李林峰老师《netty权威指南》的代码 server public class TimeServer { public static void main(String[] args) throws IOException { int port = 8080; if (args != null &amp;&amp; args.length &gt; 0) { try { port = Integer.valueOf(args[0]); } catch (NumberFormatException e) { // 采用默认值 } } MultiplexerTimeServer timeServer = new MultiplexerTimeServer(port); new Thread(timeServer, &quot;NIO-MultiplexerTimeServer-001&quot;).start(); } } class MultiplexerTimeServer implements Runnable { private Selector selector; private ServerSocketChannel servChannel; private volatile boolean stop; /** * 初始化多路复用器、绑定监听端口 * * @param port */ public MultiplexerTimeServer(int port) { try { selector = Selector.open(); servChannel = ServerSocketChannel.open(); servChannel.configureBlocking(false); servChannel.socket().bind(new InetSocketAddress(port), 1024); servChannel.register(selector, SelectionKey.OP_ACCEPT); System.out.println(&quot;The time server is start in port : &quot; + port); } catch (IOException e) { e.printStackTrace(); System.exit(1); } } public void stop() { this.stop = true; } /* * (non-Javadoc) * * @see java.lang.Runnable#run() */ public void run() { while (!stop) { try { selector.select(1000); Set&lt;SelectionKey&gt; selectedKeys = selector.selectedKeys(); Iterator&lt;SelectionKey&gt; it = selectedKeys.iterator(); SelectionKey key = null; while (it.hasNext()) { key = it.next(); it.remove(); try { handleInput(key); } catch (Exception e) { if (key != null) { key.cancel(); if (key.channel() != null) key.channel().close(); } } } } catch (Throwable t) { t.printStackTrace(); } } // 多路复用器关闭后，所有注册在上面的Channel和Pipe等资源都会被自动去注册并关闭，所以不需要重复释放资源 if (selector != null) try { selector.close(); } catch (IOException e) { e.printStackTrace(); } } private void handleInput(SelectionKey key) throws IOException { if (key.isValid()) { // 处理新接入的请求消息 if (key.isAcceptable()) { // Accept the new connection ServerSocketChannel ssc = (ServerSocketChannel) key.channel(); SocketChannel sc = ssc.accept(); sc.configureBlocking(false); // Add the new connection to the selector sc.register(selector, SelectionKey.OP_READ); } if (key.isReadable()) { // Read the data SocketChannel sc = (SocketChannel) key.channel(); ByteBuffer readBuffer = ByteBuffer.allocate(1024); int readBytes = sc.read(readBuffer); if (readBytes &gt; 0) { readBuffer.flip(); byte[] bytes = new byte[readBuffer.remaining()]; readBuffer.get(bytes); String body = new String(bytes, &quot;UTF-8&quot;); System.out.println(&quot;The time server receive order : &quot; + body); String currentTime = &quot;QUERY TIME ORDER&quot; .equalsIgnoreCase(body) ? new java.util.Date( System.currentTimeMillis()).toString() : &quot;BAD ORDER&quot;; doWrite(sc, currentTime); } else if (readBytes &lt; 0) { // 对端链路关闭 key.cancel(); sc.close(); } else ; // 读到0字节，忽略 } } } private void doWrite(SocketChannel channel, String response) throws IOException { if (response != null &amp;&amp; response.trim().length() &gt; 0) { byte[] bytes = response.getBytes(); ByteBuffer writeBuffer = ByteBuffer.allocate(bytes.length); writeBuffer.put(bytes); writeBuffer.flip(); channel.write(writeBuffer); } } } client public class TimeClient { public static void main(String[] args) { int port = 8080; if (args != null &amp;&amp; args.length &gt; 0) { try { port = Integer.valueOf(args[0]); } catch (NumberFormatException e) { // 采用默认值 } } new Thread(new TimeClientHandle(&quot;127.0.0.1&quot;, port), &quot;TimeClient-001&quot;) .start(); } } class TimeClientHandle implements Runnable { private String host; private int port; private Selector selector; private SocketChannel socketChannel; private volatile boolean stop; public TimeClientHandle(String host, int port) { this.host = host == null ? &quot;127.0.0.1&quot; : host; this.port = port; try { selector = Selector.open(); socketChannel = SocketChannel.open(); socketChannel.configureBlocking(false); } catch (IOException e) { e.printStackTrace(); System.exit(1); } } /* * (non-Javadoc) * * @see java.lang.Runnable#run() */ public void run() { try { doConnect(); } catch (IOException e) { e.printStackTrace(); System.exit(1); } while (!stop) { try { selector.select(1000); Set&lt;SelectionKey&gt; selectedKeys = selector.selectedKeys(); Iterator&lt;SelectionKey&gt; it = selectedKeys.iterator(); SelectionKey key = null; while (it.hasNext()) { key = it.next(); it.remove(); try { handleInput(key); } catch (Exception e) { if (key != null) { key.cancel(); if (key.channel() != null) key.channel().close(); } } } } catch (Exception e) { e.printStackTrace(); System.exit(1); } } // 多路复用器关闭后，所有注册在上面的Channel和Pipe等资源都会被自动去注册并关闭，所以不需要重复释放资源 if (selector != null) try { selector.close(); } catch (IOException e) { e.printStackTrace(); } } private void handleInput(SelectionKey key) throws IOException { if (key.isValid()) { // 判断是否连接成功 SocketChannel sc = (SocketChannel) key.channel(); if (key.isConnectable()) { if (sc.finishConnect()) { sc.register(selector, SelectionKey.OP_READ); doWrite(sc); } else System.exit(1);// 连接失败，进程退出 } if (key.isReadable()) { ByteBuffer readBuffer = ByteBuffer.allocate(1024); int readBytes = sc.read(readBuffer); if (readBytes &gt; 0) { readBuffer.flip(); byte[] bytes = new byte[readBuffer.remaining()]; readBuffer.get(bytes); String body = new String(bytes, &quot;UTF-8&quot;); System.out.println(&quot;Now is : &quot; + body); this.stop = true; } else if (readBytes &lt; 0) { // 对端链路关闭 key.cancel(); sc.close(); } else ; // 读到0字节，忽略 } } } private void doConnect() throws IOException { // 如果直接连接成功，则注册到多路复用器上，发送请求消息，读应答 if (socketChannel.connect(new InetSocketAddress(host, port))) { socketChannel.register(selector, SelectionKey.OP_READ); doWrite(socketChannel); } else socketChannel.register(selector, SelectionKey.OP_CONNECT); } private void doWrite(SocketChannel sc) throws IOException { byte[] req = &quot;QUERY TIME ORDER&quot;.getBytes(); ByteBuffer writeBuffer = ByteBuffer.allocate(req.length); writeBuffer.put(req); writeBuffer.flip(); sc.write(writeBuffer); if (!writeBuffer.hasRemaining()) System.out.println(&quot;Send order 2 server succeed.&quot;); } }]]></content>
      <categories>
        <category>NIO</category>
      </categories>
      <tags>
        <tag>Selector</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java面试之dubbo]]></title>
    <url>%2F2017%2F10%2F12%2Fjava%E9%9D%A2%E8%AF%95%E4%B9%8Bdubbo%2F</url>
    <content type="text"><![CDATA[什么是dubbodubbo是一个分布式框架，远程服务调用的分布式框架，其核心部分包含： **集群容错**：提供基于接口方法的透明远程过程调用，包括多协议支持，以及软负载均衡，失败容错，地址路由，动态配置等集群支持。 **远程通讯**： 提供对多种基于长连接的NIO框架抽象封装，包括多种线程模型，序列化，以及“请求-响应”模式的信息交换方式。 **自动发现**：基于注册中心目录服务，使服务消费方能动态的查找服务提供方，使地址透明，使服务提供方可以平滑增加或减少机器。 dubbo可以做什么 透明化的远程方法调用，就像调用本地方法一样调用远程方法，只需简单配置，没有任何API侵入。 软负载均衡及容错机制，可在内网替代F5等硬件负载均衡器，降低成本，减少单点。 服务自动注册与发现，不再需要写死服务提供方地址，注册中心基于接口名查询服务提供者的IP地址，并且能够平滑添加或删除服务提供者。 dubbo的架构 图中节点角色说明：Provider: 暴露服务的服务提供方。Consumer: 调用远程服务的服务消费方。Registry: 服务注册与发现的注册中心。Monitor: 统计服务的调用次调和调用时间的监控中心。Container: 服务运行容器。对于这些角色来说，其他都还好，Monitor可能猿友们前期使用会把它忽略，但是后期会发现它的作用十分明显哦，如服务的调用量越来越大，服务的容量问题就暴露出来，这个服务需要多少机器支撑？什么时候该加机器？为了解决这个问题，第一步，要将服务现在每天的调用量，响应时间，都统计出来，作为容量规划的参考指标。其次，要可以动态调整权重，在线上，将某台机器的权重一直加大，并在加大的过程中记录响应时间的变化，直到响应时间到达阀值，记录此时的访问量，再以此访问量乘以机器数反推总容量。 调用关系说明：0 服务容器负责启动，加载，运行服务提供者。1 服务提供者在启动时，向注册中心注册自己提供的服务。2 服务消费者在启动时，向注册中心订阅自己所需的服务。3 注册中心返回服务提供者地址列表给消费者，如果有变更，注册中心将基于长连接推送变更数据给消费者。4 服务消费者，从提供者地址列表中，基于软负载均衡算法，选一台提供者进行调用，如果调用失败，再选另一台调用。5 服务消费者和提供者，在内存中累计调用次数和调用时间，定时每分钟发送一次统计数据到监控中心。 dubbo的使用框架的搭建自己去google，有的博客讲的特别细。有的会在部署中出问题，有的会在打包出问题，这个需要多google去解决 dubbo的一些面试题dubbo默认使用什么通信协议dubbo共支持如下几种通信协议： dubbo:// Dubbo缺省协议采用单一长连接和NIO异步通讯，适合于小数据量大并发的服务调用，以及服务消费者机器数远大于服务提供者机器数的情况。 rmi:// RMI协议采用JDK标准的java.rmi.*实现，采用阻塞式短连接和JDK标准序列化方式 hessian:// http:// webservice:// thrift:// memcached:// redis:// 服务调用超时问题怎么解决dubbo在调用服务不成功时，默认是会重试两次的。这样在服务端的处理时间超过了设定的超时时间时，就会有重复请求，比如在发邮件时，可能就会发出多份重复邮件，执行注册请求时，就会插入多条重复的注册数据，那么怎么解决超时问题呢？1.对于核心的服务中心，去除dubbo超时重试机制，并重新评估设置超时时间。2.业务处理代码必须放在服务端，客户端只做参数验证和服务调用，不涉及业务流程处理代码配置：&lt;dubbo:provider delay=&quot;-1&quot; timeout=&quot;6000&quot; retries=&quot;0&quot;/&gt;当然Dubbo的重试机制其实是非常好的QOS保证，它的路由机制，是会帮你把超时的请求路由到其他机器上，而不是本机尝试，所以 dubbo的重试机器也能一定程度的保证服务的质量。但是请一定要综合线上的访问情况，给出综合的评估。 一般使用什么注册中心，还有其他的选择吗？Multicast注册中心 Zookeeper注册中心 Redis注册中心 Simple注册中心 正常情况下我们使用zookeeper注册中心 ZooKeeper的节点是通过像树一样的结构来进行维护的，并且每一个节点通过路径来标示以及访问。除此之外，每一个节点还拥有自身的一些信息，包括：数据、数据长度、创建时间、修改时间等等。 从这样一类既含有数据，又作为路径表标示的节点的特点中，可以看出，ZooKeeper的节点既可以被看做是一个文件，又可以被看做是一个目录，它同时具有二者的特点。为了简单我们可以Znode来表示所讨论的ZooKeeper节点。 具体地说，Znode维护着数据、ACL（access controllist，访问控制列表）、时间戳等交换版本号等数据结构，它通过对这些数据的管理来让缓存生效并且令协调更新。每当Znode中的数据更新后它所维护的版本号将增加，这非常类似于数据库中计数器时间戳的操作方式。 另外Znode还具有原子性操作的特点：命名空间中，每一个Znode的数据将被原子地读写。读操作将读取与Znode相关的所有数据，写操作将替换掉所有的数据。除此之外，每一个节点都有一个访问控制列表，这个访问控制列表规定了用户操作的权限。 ZooKeeper中同样存在临时节点。这些节点与session同时存在，当session生命周期结束，这些临时节点也将被删除。临时节点在某些场合也发挥着非常重要的作用。 了解了Zookeeper的命名空间和节点之后我们需要跟上一篇文章中提到的内部逻辑联系起来.在上篇介绍到的内部流程中,拿到这里看看Zookeeper是如何处理的,流程如下图: 1 当服务提供者启动时,Zookeeper向/dubbo/com.foo.BarService/providers目录下写入自己的URL地址。2 当服务消费者启动时,这时候有两个动作: 订阅/dubbo/com.foo.BarService/providers目录下的提供者URL地址。 并向/dubbo/com.foo.BarService/consumers目录下写入自己的URL地址。 3当监控中心启动时,订阅/dubbo/com.foo.BarService目录下的所有提供者和消费者URL地址。 默认使用什么序列化框架Dubbo默认使用的是Hessian序列化。hessian是一个采用二进制格式传输的服务框架，相对传统soap web service，更轻量，更快速。 Hessian原理与协议简析：http的协议约定了数据传输的方式，hessian也无法改变太多： 1) hessian中client与server的交互，基于http-post方式。 2) hessian将辅助信息，封装在http header中，比如“授权token”等，我们可以基于http-header来封装关于“安全校验”“meta数据”等。hessian提供了简单的&quot;校验&quot;机制。 3) 对于hessian的交互核心数据，比如“调用的方法”和参数列表信息，将通过post请求的body体直接发送，格式为字节流。 4) 对于hessian的server端响应数据，将在response中通过字节流的方式直接输出。 hessian的协议本身并不复杂，在此不再赘言；所谓协议(protocol)就是约束数据的格式，client按照协议将请求信息序列化成字节序列发送给server端，server端根据协议，将数据反序列化成“对象”，然后执行指定的方法，并将方法的返回值再次按照协议序列化成字节流，响应给client，client按照协议将字节流反序列话成”对象”。 服务提供者能实现失效踢出的原理 ConfigServer（配置中心）每个Server/Client之间会作一个实时的心跳检测（因为它们都是建立的Socket长连接），比如几秒钟检测一次。收集每个Server提供的服务的信息，每个Client的信息，整理出一个服务列表，如： serviceName serverAddressList clientAddressList UserService 192.168.0.1，192.168.0.2，192.168.0.3，192.168.0.4 172.16.0.1，172.16.0.2 ProductService 192.168.0.3，192.168.0.4，192.168.0.5，192.168.0.6 172.16.0.2，172.16.0.3 OrderService 192.168.0.10，192.168.0.12，192.168.0.5，192.168.0.6 172.16.0.3，172.16.0.4 当某个Server不可用，那么就更新受影响的服务对应的serverAddressList，即把这个Server从serverAddressList中踢出去（从地址列表中删除），同时将推送serverAddressList给这些受影响的服务的clientAddressList里面的所有Client。如：192.168.0.3挂了，那么UserService和ProductService的serverAddressList都要把192.168.0.3删除掉，同时把新的列表告诉对应的Client 172.16.0.1，172.16.0.2，172.16.0.3；当某个Client挂了，那么更新受影响的服务对应的clientAddressListConfigServer根据服务列表，就能提供一个web管理界面，来查看管理服务的提供者和使用者。新加一个Server时，由于它会主动与ConfigServer取得联系，而ConfigServer又会将这个信息主动发送给Client，所以新加一个Server时，只需要启动Server，然后几秒钟内，Client就会使用上它提供的服务 Client（调用服务的机器） 每个Client启动时，主动与ConfigServer建立Socket长连接，并将自己的IP等相应信息发送给ConfigServer。Client在使用服务的时候根据服务名称去ConfigServer中获取服务提供者信息（这样ConfigServer就知道某个服务是当前哪几个Client在使用），Client拿到这些服务提供者信息后，与它们都建立连接，后面就可以直接调用服务了，当有多个服务提供者的时候，Client根据一定的规则来进行负载均衡，如轮询，随机，按权重等。一旦Client使用的服务它对应的服务提供者有变化（服务提供者有新增，删除的情况），ConfigServer就会把最新的服务提供者列表推送给Client，Client就会依据最新的服务提供者列表重新建立连接，新增的提供者建立连接，删除的提供者丢弃连接 Server（真正提供服务的机器） 每个Server启动时，主动与ConfigServer建立Scoket长连接，并将自己的IP，提供的服务名称，端口等信息直接发送给ConfigServer，ConfigServer就会收集到每个Server提供的服务的信息。 优点： 只要在Client和Server启动的时候，ConfigServer是好的，服务就可调用了，如果后面ConfigServer挂了，那只影响ConfigServer挂了以后服务提供者有变化，而Client还无法感知这一变化。 Client每次调用服务是不经过ConfigServer的，Client只是与它建立联系，从它那里获取提供服务者列表而已 调用服务-负载均衡：Client调用服务时，可以根据规则在多个服务提供者之间轮流调用服务。 服务提供者-容灾：某一个Server挂了，Client依然是可以正确的调用服务的，当前提是这个服务有至少2个服务提供者，Client能很快的感知到服务提供者的变化，并作出相应反应。 服务提供者-扩展：添加一个服务提供者很容易，而且Client会很快的感知到它的存在并使用它。 服务上线怎么不影响旧版本dubbo的文档中说到： 当一个接口实现，出现不兼容升级时，可以用版本号过渡，版本号不同的服务相互间不引用。 在低压力时间段，先升级一半提供者为新版本，再将所有消费者升级为新版本，然后将剩下的一半提供者升级为新版本 &lt;dubbo:service interface=&quot;com.foo.BarService&quot; version=&quot;1.0.0&quot; /&gt; &lt;dubbo:service interface=&quot;com.foo.BarService&quot; version=&quot;2.0.0&quot; /&gt; &lt;dubbo:reference id=&quot;barService&quot; interface=&quot;com.foo.BarService&quot; version=&quot;1.0.0&quot; /&gt; &lt;dubbo:reference id=&quot;barService&quot; interface=&quot;com.foo.BarService&quot; version=&quot;2.0.0&quot; /&gt; 不区分版本：(2.2.0以上版本支持) &lt;dubbo:reference id=&quot;barService&quot; interface=&quot;com.foo.BarService&quot; version=&quot;*&quot; /&gt; dubbo协议下的单一长连接与多线程并发如何协同工作底层采用netty。 集群容错怎么做dubbo的容错方案当我们的系统中用到Dubbo的集群环境,因为各种原因在集群调用失败时，Dubbo提供了多种容错方案，缺省为failover重试。Dubbo的集群容错在这里想说说他是因为我们实际的项目中出现了此类的问题,因为依赖的第三方项目出现异常,导致dubbo调用超时,此时使用的是默认的集群容错方式,而配置的reties=’3’,这样前段系统连续掉用了三次服务。 通过上面dubbo架构图这里的Invoker是Provider的一个可调用Service的抽象，Invoker封装了Provider地址及Service接口信息。Directory代表多个Invoker，可以把它看成List，但与List不同的是，它的值可能是动态变化的，比如注册中心推送变更。Cluster将Directory中的多个Invoker伪装成一个Invoker，对上层透明，伪装过程包含了容错逻辑，调用失败后，重试另一个。Router负责从多个Invoker中按路由规则选出子集，比如读写分离，应用隔离等。LoadBalance负责从多个Invoker中选出具体的一个用于本次调用，选的过程包含了负载均衡算法，调用失败后，需要重选。集群容错模式：Failover Cluster失败自动切换，当出现失败，重试其它服务器。(缺省)通常用于读操作，但重试会带来更长延迟。可通过retries=”2”来设置重试次数(不含第一次)。正是文章刚开始说的那种情况.Failfast Cluster快速失败，只发起一次调用，失败立即报错。通常用于非幂等性的写操作，比如新增记录。Failsafe Cluster失败安全，出现异常时，直接忽略。通常用于写入审计日志等操作。Failback Cluster失败自动恢复，后台记录失败请求，定时重发。通常用于消息通知操作。Forking Cluster并行调用多个服务器，只要一个成功即返回。通常用于实时性要求较高的读操作，但需要浪费更多服务资源。可通过forks=”2”来设置最大并行数。Broadcast Cluster广播调用所有提供者，逐个调用，任意一台报错则报错。(2.1.0开始支持)通常用于通知所有提供者更新缓存或日志等本地资源信息。重试次数配置如：(failover集群模式生效)&lt;dubbo:serviceretries=&quot;2&quot;/&gt;或：&lt;dubbo:referenceretries=&quot;2&quot;/&gt;或：&lt;dubbo:reference&gt; &lt;dubbo:methodname=&quot;findFoo&quot;retries=&quot;2&quot;/&gt; &lt;/dubbo:reference&gt; 集群模式配置如：&lt;dubbo:servicecluster=&quot;failsafe&quot;/&gt;或：&lt;dubbo:referencecluster=&quot;failsafe&quot;/&gt; dubbo是如何实现负载均衡dubbo负载均衡策略：在集群负载均衡时，Dubbo提供了多种均衡策略，缺省为random随机调用。RandomLoadBalance随机，按权重设置随机概率。在一个截面上碰撞的概率高，但调用量越大分布越均匀，而且按概率使用权重后也比较均匀，有利于动态调整提供者权重。RoundRobin LoadBalance轮循，按公约后的权重设置轮循比率。存在慢的提供者累积请求问题，比如：第二台机器很慢，但没挂，当请求调到第二台时就卡在那，久而久之，所有请求都卡在调到第二台上。LeastActive LoadBalance最少活跃调用数，相同活跃数的随机，活跃数指调用前后计数差。使慢的提供者收到更少请求，因为越慢的提供者的调用前后计数差会越大。ConsistentHashLoadBalance一致性Hash，相同参数的请求总是发到同一提供者。当某一台提供者挂时，原本发往该提供者的请求，基于虚拟节点，平摊到其它提供者，不会引起剧烈变动。Dubbo的集群容错和负载均衡同样也是Dubbo本身的高级特性.正如我们在说自定义扩展的时候一样,这两个特征同样也可以进行自定义扩展,用户可以根据自己实际的需求来扩展他们从而满足项目的实际需求. 遇到的问题场景描述：客户端远程异步调用ServiceA，ServiceA在处理客户端请求的过程中需要远程同步调用ServiceB，ServiceA从ServiceB的响应中取数据时，得到的是null。对于上面的问题，解决办法有三个：1.方法调用两次 ServiceA调用ServiceB的地方写两次一样的调用，这个方法原理就像ServiceB调用ServiceC一样，即清除attachements。 这个方法最简单，但是可能对不了解的人来说，这块业务代码写重复了，会不小心删除掉，而且从写代码的角度来说，这个很鸡肋，所以不推荐。 2.修改Dubbo源码 修改AbstractInvoker第137行，改成每次都对async进行实际赋值， boolean isAsync = getUrl().getMethodParameter(invocation.getMethodName(), Constants.ASYNC_KEY, false); invocation.setAttachment(Constants.ASYNC_KEY, String.valueOf(isAsync)); 3.自定义Filter实现com.alibaba.dubbo.rpc.Filter，在RpcContext中清除这个async， @Activate(group = {Constants.PROVIDER}) public class AsyncFilter implements Filter { @Override public Result invoke(Invoker&lt;?&gt; invoker, Invocation invocation) throws RpcException { RpcContext.getContext().getAttachments().remove(Constants.ASYNC_KEY); return invoker.invoke(invocation); } } 同时在src/main/resources/META-INF/dubbo/下添加com.alibaba.dubbo.rpc.Filter文件，内容文件如下： asyncFilter=com.abc.filter.AsyncFilter根据n多的博客整理出来的一些，以后有其他东西再加进去]]></content>
      <categories>
        <category>面试</category>
      </categories>
      <tags>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Channel]]></title>
    <url>%2F2017%2F10%2F11%2FChannel%2F</url>
    <content type="text"><![CDATA[Channel基础Channel 用于在字节缓冲区和位于通道另一侧的实体（通常是一个文件或套接字）之间有效地传输数据。Java NIO的通道类似流，但又有些不同 既可以从通道中读取数据，也可以写数据到通道。但是流的读写通常是单向的 通道可以异步读写 通道中的数据通常总是要先读到一个Buffer，或者总是从Buffer中写入 Channel的源码 import java.io.Closeable; import java.io.IOException; public interface Channel extends Closeable { boolean isOpen();//打开通道 void close() throws IOException;//关闭通道 } Channel的实现类 FileChannel：从文件中读取数据DatagramChannel：能通过UDP读写网络中的数据SockeChannel：能通过TCP读写网络中的数据ServerSocketChannel：可以监听新进来的TCP连接，像WEB服务器那样。对每一个新进来的连接都会创建一个SocketChannel。 Channel的实例FileChannel读文件import java.io.RandomAccessFile; import java.nio.ByteBuffer; import java.nio.channels.FileChannel; public class FileChannelDemo{ public static void main(String[] args) throws Exception { RandomAccessFile rFile = new RandomAccessFile(&quot;D:\\test_gc.log&quot;,&quot;rw&quot;); //从文件中读取数据，打开通道 FileChannel inChannel = rFile.getChannel(); //创建48字节的缓冲区 ByteBuffer buf = ByteBuffer.allocate(48); //从通道读取数据到缓冲区 int bytesRead = inChannel.read(buf); while(bytesRead != -1){ //写模式改成读模式 buf.flip(); System.out.println(&quot;Read &quot;+bytesRead); while(buf.hasRemaining()){ System.out.println((char)buf.get()); System.out.println(buf.position()+&quot;=========&quot;); } buf.clear(); bytesRead = inChannel.read(buf); } rFile.close(); } } FileChannel写文件import java.io.RandomAccessFile; import java.nio.ByteBuffer; import java.nio.channels.FileChannel; public class FileChannelDemo{ public static void main(String[] args) throws Exception { String date = &quot;test insert...&quot;; RandomAccessFile rFile = new RandomAccessFile(&quot;D:\\test_gc.log&quot;,&quot;rw&quot;); //从文件中读取数据，打开通道 FileChannel inChannel = rFile.getChannel(); //创建48字节的缓冲区,如果分配4个字节，而date比较长，那么在buf.put的时候就会报错。 ByteBuffer buf = ByteBuffer.allocate(48); //指定position为文件大小的值，即在channel的末尾追加内容,如果没有，则直接覆盖原来的数据 inChannel.position(inChannel.size()); buf.clear(); buf.put(date.getBytes()); buf.flip(); while(buf.hasRemaining()) { inChannel.write(buf); } inChannel.close(); rFile.close(); } } DatagramChannel由于DatagramChannel通过UDP读取数据，需要一个接受方，和一个发送方。接收方代码： import java.io.IOException; import java.net.InetSocketAddress; import java.nio.ByteBuffer; import java.nio.channels.DatagramChannel; import java.nio.charset.Charset; public class Reveiver { public static void main(String[] args) { try { receive(); } catch (IOException e) { e.printStackTrace(); } } private static void receive() throws IOException{ //指定端口 DatagramChannel channel =DatagramChannel.open(); channel.socket().bind(new InetSocketAddress(10022)); ByteBuffer buffer =ByteBuffer.allocate(60); //接受数据 while(channel.receive(buffer)==null){ try { Thread.sleep(1000); } catch (InterruptedException e) { e.printStackTrace(); } } buffer.flip(); String recStr =Charset.forName(&quot;utf-8&quot;).newDecoder().decode(buffer).toString(); System.out.println(recStr); channel.close(); } } 发送方代码： import java.io.IOException; import java.net.InetSocketAddress; import java.nio.ByteBuffer; import java.nio.channels.DatagramChannel; public class Sender { public static void main(String[] args) { try { send(); } catch (IOException e) { e.printStackTrace(); } } private static void send() throws IOException{ DatagramChannel channel =DatagramChannel.open(); ByteBuffer buffer =ByteBuffer.wrap(&quot;测试DatagramChannel&quot;.getBytes(&quot;utf-8&quot;)); //通过send发送数据 channel.send(buffer, new InetSocketAddress(&quot;localhost&quot;,10022)); channel.close(); } } SocketChannel 和ServerSocketChannel可以用非阻塞的SocketChannel和ServerSocketChannel代替阻塞的Socket和ServerSocket。这个后期学到选择器的时候再具体研究。]]></content>
      <categories>
        <category>NIO</category>
      </categories>
      <tags>
        <tag>Channel</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Buffer]]></title>
    <url>%2F2017%2F10%2F10%2FBuffer%2F</url>
    <content type="text"><![CDATA[缓冲区缓冲区基础缓冲区概念缓冲区是包在一个对象内的基本数据元素数组。Buffer 类相比一个简单数组的优点是它将关于数据的数据内容和信息包含在一个单一的对象中。Buffer 类以及它专有的子类定义了一个用于处理数据缓冲区的 API。如下图，还有一些其他的子类这就不列举了 通过上图可以看出，都是基本类型对应的Buffer。上图的几个Buffer都提供了读和写的方法get()和put()。 属性所有的缓冲区都具有四个属性来提供关于其所包含的数据元素的信息。 容量（Capacity）：缓冲区能够容纳的数据元素的最大数量。这一容量在缓冲区创建时被设定，并且永远不能被改变。 上界（Limit）：缓冲区的第一个不能被读或写的元素。或者说，缓冲区中现存元素的计数。 位置（Position）：下一个要被读或写的元素的索引。位置会自动由相应的 get( )和 put( )函数更新。 标记（Mark）：一个备忘位置。调用 mark( )来设定 mark = postion。调用 reset( )设定 position = mark。标记在设定前是未定义的( undefined) 。 缓冲区的创建想要获得一个Buffer对象首先要进行分配。每一个Buffer类都有一个allocate()方法这是一个可储存100字符的CharBuffer CharBuffer buf = CharBuffer.allocate(100);或者用以下wrap方法 char [] myArray = new char [100]; CharBuffer charbuffer = CharBuffer.wrap (myArray);通过创建缓冲区我们再来看看capacity，limit，positioncapacity作为一个内存块，Buffer有一个固定的大小值,一般创建Buffer时初始化写入–&gt;ByteBuffer.allocate(capacity)，你只能往capacity里写byte、long、char等类型。一旦Buffer满了，需要将其清空（通过读数据或者清除数据）才能继续往里面写数据pisition当你写数据到Buffer中，position表示当前的位置。初始位置的position值为0，当一个byte、long等数据写到Buffer后，position会向前移动到下一个可插入数据的Buffer单元。position最大可为capacity-1(因为position的初始值为0)当读取数据时，也是从某个特定位置读，当Buffer从写模式切换到读模式，position会被重置为0，当从Buffer的position处读取数据时，position向前移动到下一个可读位置。limit在写模式中，Buffer的limit表示你最多往Buffer中写多少数据。写模式下，limit=capacity在读模式中，limit表示你最多能读多少数据。因此，当切换读模式，limit会被设置成写模式下的position值（你能读到之前写入的所有数据）如下图，我插入了1,2,3,4四个数据进这个Buffer 下面通过一个例子来看看 import java.nio.Buffer; import java.nio.ByteBuffer; import java.nio.CharBuffer; import java.nio.ByteOrder; public class BufferCharView { public static void main (String [] argv) throws Exception { ByteBuffer byteBuffer = ByteBuffer.allocate (7).order (ByteOrder.BIG_ENDIAN); CharBuffer charBuffer = byteBuffer.asCharBuffer( ); // Load the ByteBuffer with some bytes byteBuffer.put (0, (byte)0); byteBuffer.put (1, (byte)&apos;H&apos;); byteBuffer.put (2, (byte)0); byteBuffer.put (3, (byte)&apos;i&apos;); byteBuffer.put (4, (byte)0); byteBuffer.put (5, (byte)&apos;!&apos;); byteBuffer.put (6, (byte)0); println (byteBuffer); println (charBuffer); } // Print info about a buffer private static void println (Buffer buffer) { System.out.println (&quot;pos=&quot; + buffer.position( ) + &quot;, limit=&quot; + buffer.limit( ) + &quot;, capacity=&quot; + buffer.capacity( ) + &quot;: &apos;&quot; + buffer.toString( ) + &quot;&apos;&quot;); } } 运行结果： 函数Buffer的实现类自带了几个函数，也是我们经常用的flip()该方法是将Buffer从写模式切换到读模式。调用flip()方法会将position设回0，并将limit设置成之前position的值（position表示标记读的位置，limit表示之前写进多少个字节等—》现在能读多少个字节） public final Buffer flip() { limit = position; position = 0; mark = -1; return this; } rewind()Buffer.rewind()将position设回0，所以你可以重读Buffer中的所有数据。limit保持不变，仍然表示能从Buffer中读取多少个元素（byte、char等）。 public final Buffer rewind() { position = 0; mark = -1; return this; } clear()和compact()一旦读完Buffer中的数据，需要让Buffer准备好再次被写入，可以通过clear()或者compact()来完成。 如果调用的是clear()，position将被设为0，limit将被设为capacity的值，换句话说，Buffer被清空来，Buffer中的数据并未清除，只说这些标记告诉我们可以从哪里开始往Buffer中写数据了。如果里面还有数据，调用clear()，这些数据将被遗忘，意味着不再有任何标记会告诉你哪些数据被读过，哪些没有。 public final Buffer clear() { position = 0; limit = capacity; mark = -1; return this; } 如果Buffer中未读的数据，并且以后还需要，那么使用compact()方法。 compact方法将所有未读的数据copy到Buffer起始处，然后将position设到最后一个未读数据的后面。limit属性仍然和clear()方法一样，设置成capacity。现在Buffer准备好写数据了，但是不会覆盖未读的数据。mark()与reset()通过Buffer.mark()方法，可以标记Buffer中的一个特定的position，之后可以通过调用Buffer.reset()恢复到这个position。 public final Buffer mark() { mark = position; return this; } public final Buffer reset() { int m = mark; if (m &lt; 0) throw new InvalidMarkException(); position = m; return this; } 下面通过一个例子来看看mark和rest的方法 import java.io.BufferedInputStream; import java.io.ByteArrayInputStream; import java.io.IOException; public class MarkDemo { public static void main(String[] args) { try { // 初始化一个字节数组，内有5个字节的数据 byte[] bytes = { 1, 2, 3, 4, 5 }; // 用一个ByteArrayInputStream来读取这个字节数组 ByteArrayInputStream in = new ByteArrayInputStream(bytes); // 将ByteArrayInputStream包含在一个BufferedInputStream，并初始化缓冲区大小为2。 BufferedInputStream bis = new BufferedInputStream(in, 2); // 读取字节1 System.out.print(bis.read() + &quot;,&quot;); // 在字节2处做标记，同时设置readlimit参数为1 // 根据JAVA文档mark以后最多只能读取1个字节，否则mark标记失效，但实际运行结果不是这样 System.out.println(&quot;mark&quot;); bis.mark(1); /* * 连续读取两个字节，超过了readlimit的大小，mark标记仍有效 */ // 连续读取两个字节 System.out.print(bis.read() + &quot;,&quot;); System.out.print(bis.read() + &quot;,&quot;); // 调用reset方法，未发生异常，说明mark标记仍有效。 // 因为，虽然readlimit参数为1，但是这个BufferedInputStream类的缓冲区大小为2， // 所以允许读取2字节 System.out.println(&quot;reset&quot;); bis.reset(); /* * 连续读取3个字节，超过了缓冲区大小，mark标记失效。 * 在这个例子中BufferedInputStream类的缓冲区大小大于readlimit, mark标记由缓冲区大小决定 */ // reset重置后连续读取3个字节，超过了BufferedInputStream类的缓冲区大小 System.out.print(bis.read() + &quot;,&quot;); System.out.print(bis.read() + &quot;,&quot;); System.out.print(bis.read() + &quot;,&quot;); // 再次调用reset重置，抛出异常，说明mark后读取3个字节，mark标记失效 System.out.println(&quot;reset again&quot;); bis.reset(); } catch (IOException e) { // TODO Auto-generated catch block e.printStackTrace(); } } }]]></content>
      <categories>
        <category>NIO</category>
      </categories>
      <tags>
        <tag>NIO</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring源码之Autowired]]></title>
    <url>%2F2017%2F10%2F09%2FSpring%E6%BA%90%E7%A0%81%E4%B9%8BAutowired%2F</url>
    <content type="text"><![CDATA[#测试]]></content>
      <categories>
        <category>spring</category>
      </categories>
      <tags>
        <tag>spring Autowired</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[开篇]]></title>
    <url>%2F2017%2F09%2F27%2Ftest%2F</url>
    <content type="text"><![CDATA[开篇寄语一直想自己搭建一个博客，但是身为资深懒人，什么都不愿意去做，正好趁着闲时抓紧时间去做一下，不然肯定又拖了。主要分享一些工作中遇到的问题和一些面试问题。因为我本人是学java的，所以一般是java的代码。]]></content>
      <categories>
        <category>随笔</category>
      </categories>
  </entry>
</search>
