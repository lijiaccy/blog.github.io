<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title></title>
      <url>/2017/12/29/java%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%EF%BC%88%E8%BD%AC%EF%BC%89/</url>
      <content type="html"><![CDATA[<p>看了群主的java体系结构 <a href="http://cmsblogs.com/wp-content/images/share/chenssy_juc_201712.png，但是图看着太不方便了。就把这个弄成了一篇文章。" target="_blank" rel="external">http://cmsblogs.com/wp-content/images/share/chenssy_juc_201712.png，但是图看着太不方便了。就把这个弄成了一篇文章。</a></p>
<h1 id="JMM"><a href="#JMM" class="headerlink" title="JMM"></a>JMM</h1><h2 id="线程通信机制"><a href="#线程通信机制" class="headerlink" title="线程通信机制"></a>线程通信机制</h2><p>java中采用的是共享内存的方式（<strong>wait和notify都要获得锁</strong>）</p>
<h2 id="内存模型"><a href="#内存模型" class="headerlink" title="内存模型"></a>内存模型</h2><h3 id="重排序"><a href="#重排序" class="headerlink" title="重排序"></a>重排序</h3><p><strong>定义：</strong>为了程序的性能，处理器、编译器都会对程序进行重排序处理。<br><strong>条件：</strong></p>
<ol>
<li>在单线程环境下不能改变程序运行的结果</li>
<li>存在数据依赖关系的不允许重排序<h3 id="顺序一致性和数据竞争"><a href="#顺序一致性和数据竞争" class="headerlink" title="顺序一致性和数据竞争"></a>顺序一致性和数据竞争</h3><strong>顺序一致性</strong>内存模型是一个被计算机科学家理想化了的理论参考模型，它为程序员提供了极强的内存可见性保证。顺序一致性内存模型有两大特性：</li>
<li>一个线程中的所有操作必须按照程序的顺序来执行。</li>
<li>（不管程序是否同步）所有线程都只能看到一个单一的操作执行顺序。在顺序一致性内存模型中，每个操作都必须原子执行且立刻对所有线程可见。</li>
</ol>
<p><strong>数据竞争的定义：</strong></p>
<ol>
<li>在一个线程中写一个变量，</li>
<li>在另一个线程读同一个变量，</li>
<li>而且写和读没有通过同步来排序。<h3 id="happens-before"><a href="#happens-before" class="headerlink" title="happens-before"></a>happens-before</h3><strong>定义：</strong>在JMM中，如果一个操作执行的结果需要对另一个操作可见，那么这两个操作之间必须存在happens-before关系。<strong>保证内存可见性</strong>。<br><strong>理论：</strong></li>
<li>如果一个操作happens-before另一个操作，那么第一个操作的执行结果将对第二个操作可见，而且第一个操作的执行顺序排在第二个操作之前</li>
<li><p>两个操作之间存在happens-before关系，并不意味着一定要按照happens-before原则制定的顺序来执行。如果重排序之后的执行结果与按照happens-before关系来执行的结果一致，那么这种重排序并不非法</p>
<h3 id="as-if-serial"><a href="#as-if-serial" class="headerlink" title="as-if-serial"></a>as-if-serial</h3><p><strong>定义：</strong>不管怎么重排序（编译器和处理器为了提高并行度），（单线程）程序的执行结果不能被改变。编译器，runtime 和处理器都必须遵守as-if-serial语义。</p>
<p> double pi  = 3.14;    //A<br> double r   = 1.0;     //B<br> double area = pi <em> r </em> r; //C<br>as-if-serial会保证C不会因为重排序安排在AB之前执行。</p>
<h2 id="synchronized（重中之重）"><a href="#synchronized（重中之重）" class="headerlink" title="synchronized（重中之重）"></a>synchronized（重中之重）</h2><p>synchronized为重量级锁，同步。<br><strong>synchronized可以保证方法或者代码块在运行时，同一时刻只有一个方法可以进入到临界区，同时它还可以保证共享变量的内存可见性。</strong></p>
<h3 id="synchronized的锁对象"><a href="#synchronized的锁对象" class="headerlink" title="synchronized的锁对象"></a>synchronized的锁对象</h3></li>
<li><p>同步普通方法，锁是当前实例对象</p>
</li>
<li>同步静态方法，锁是当前类的class对象</li>
<li>同步方法块，锁是括号里面的对象<h3 id="synchronized的实现机制"><a href="#synchronized的实现机制" class="headerlink" title="synchronized的实现机制"></a>synchronized的实现机制</h3>synchronized的锁就是保存在Java对象头中的。java对象头包括两部分数据：</li>
<li><strong>Mark Word（标记字段）：</strong>Mark Word被设计成一个非固定的数据结构以便在极小的空间内存存储尽量多的数据，它会根据对象的状态复用自己的存储空间（包括哈希码（HashCode）、GC分代年龄、锁状态标志、线程持有的锁、偏向线程 ID、偏向时间戳等）</li>
<li><strong>monitor</strong>：初始时为NULL表示当前没有任何线程拥有该monitor record，当线程成功拥有该锁后保存线程唯一标识，当锁被释放时又设置为NULL<h3 id="锁优化"><a href="#锁优化" class="headerlink" title="锁优化"></a>锁优化</h3><h4 id="自旋锁"><a href="#自旋锁" class="headerlink" title="自旋锁"></a>自旋锁</h4>该线程等待一段时间，不会被立即挂起，看持有锁的线程是否会很快释放锁（循环方式）。<br>自旋字数较难控制（-XX:preBlockSpin）。<br>存在理论：线程的频繁挂起、唤醒负担较重，可以认为每个线程占有锁的时间很短，线程挂起再唤醒得不偿失<br>缺点：自旋次数无法确定<h4 id="适应性自旋锁"><a href="#适应性自旋锁" class="headerlink" title="适应性自旋锁"></a>适应性自旋锁</h4>自旋的次数不再是固定的，它是由前一次在同一个锁上的自旋时间及锁的拥有者的状态来决定<br>自旋成功，则可以增加自旋次数，如果获取锁经常失败，那么自旋次数会减少<h4 id="锁消除"><a href="#锁消除" class="headerlink" title="锁消除"></a>锁消除</h4>若不存在数据竞争的情况，JVM会消除锁机制（根据变量逃逸）<h4 id="锁粗化"><a href="#锁粗化" class="headerlink" title="锁粗化"></a>锁粗化</h4>将多个连续的加锁、解锁操作连接在一起，扩展成一个范围更大的锁。例如for循环内部获取锁<h4 id="轻量级锁"><a href="#轻量级锁" class="headerlink" title="轻量级锁"></a>轻量级锁</h4>在没有多线程竞争的前提下，减少传统的重量级锁使用操作系统互斥量产生的性能消耗。<br>通过CAS来获取锁和释放锁。<br>性能依据：对于绝大部分的锁，在整个生命周期内都是不会存在竞争的<br>缺点：在多线程环境下，其运行效率比重量级锁还会慢<h4 id="偏向锁"><a href="#偏向锁" class="headerlink" title="偏向锁"></a>偏向锁</h4>为了在无多线程竞争的情况下尽量减少不必要的轻量级锁执行路径。<br>主要尽可能避免不必须要的CAS操作，如果竞争锁失败，则升级为轻量级锁。<h2 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a>volatile</h2><strong>volatile特性：</strong></li>
<li>volatile可见性：对一个volatile的读，总可以看到对这个变量最终的写</li>
<li>volatile原子性：volatile对单个读/写具有原子性（32位Long、Double），但是复合操作除外，例如i++;</li>
</ol>
<p>实现机制：用的内存屏障<br>内存语义：</p>
<ol>
<li>当写一个volatile变量时，JMM会把该线程对应的本地内存中的共享变量值立即刷新到主内存中</li>
<li>当读一个volatile变量时，JMM会把该线程对应的本地内存设置为无效，直接从主内存中读取共享变量</li>
</ol>
<p>操作系统语义：<br>主存、高速缓存（线程私有）缓存一致？<br>解决方案：通过在总线加LOCK#锁的方式，</p>
<p><strong>使用volatile修饰的变量有禁止指令重排序和内存可见性。但是不能保证原子性</strong></p>
<h1 id="并发基础"><a href="#并发基础" class="headerlink" title="并发基础"></a>并发基础</h1><h2 id="AQS"><a href="#AQS" class="headerlink" title="AQS"></a>AQS</h2><p>AbstractQueuedSynchronizer（AQS），同步器，实现JUC核心基础组件。<br>解决了子类实现同步器时涉及的大量细节问题，例如获取同步状态、FIFO同步队列。<br>采用模板方法模式，AQS实现大量通用方法，子类通过继承方式实现其抽象方法来管理同步状态。<br>CLH同步队列：</p>
<ol>
<li>FIFO双向队列，AQS依赖它来解决同步状态的管理问题</li>
<li>首节点唤醒，等待队列加入到CLH同步队列的尾部</li>
</ol>
<p><strong>同步状态获取与释放</strong>，分为独占锁和共享锁：<br>独占锁方式：获取同步状态（acquire），响应中断（acquireInterruptibly），超时获取（tryAcquireNanos）<br>共享锁方式：获取锁（acquireShared），释放锁（releaseShared）</p>
<p><strong>线程阻塞和唤醒</strong><br>当有线程获取锁了，其他再次获取时需要阻塞，当线程释放锁后，AQS负责唤醒线程。<br><strong>LockSupport：</strong></p>
<ol>
<li>是用来创建锁和其他同步类的基本线程阻塞原语</li>
<li>每个使用LockSupport的线程都会与一个许可关联，如果该许可可用，并且可在进程中使用，则调用park()将会立即返回，否则可能阻塞。如果许可尚不可用，则可以调用 unpark 使其可用</li>
<li>park()、unpark()<h2 id="CAS"><a href="#CAS" class="headerlink" title="CAS"></a>CAS</h2>Compare And Swap，整个JUC体系最核心、最基础理论。<br><code>compareAndSwapInt(Object var1, long var2, int var4, int var5);</code><br>内存值var2、旧的预期值var4、要更新的值var1，当且仅当内存值var2的值等于旧的预期值var4时才会将内存值var5的值修改为var1，否则什么都不干<br>缺点：</li>
<li>循环时间太长</li>
<li>只能保证一个共享变量原子操作</li>
<li>ABA问题（加版本号，用AtomicStampedReference解决）<h1 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h1><h2 id="ReentrantLock"><a href="#ReentrantLock" class="headerlink" title="ReentrantLock"></a>ReentrantLock</h2>可重入锁，是一种递归无阻塞的同步机制。<br>比synchronized更强大、灵活的锁机制，可以减少死锁发生的概率。<br>分为公平锁、非公平锁。<br>底层采用AQS实现，通过内部Sync继承AQS。<br><strong>Lock和synchronized的区别：</strong><br>Lock能完成synchronized的功能。<br>Lock需要手动释放锁。<br>如果获取对象。synchronized等待里面的任务完成，不然会一直阻塞。而lock有多种选择，可以立即返回，不需要等待。在多线程下效率更高。<h2 id="ReentrantReadWriteLock"><a href="#ReentrantReadWriteLock" class="headerlink" title="ReentrantReadWriteLock"></a>ReentrantReadWriteLock</h2>读写锁，两把锁：共享锁：读锁、排他锁：写锁<br>支持公平性、非公平性，可重入和锁降级<br>锁降级：遵循获取写锁、获取读锁在释放写锁的次序，写锁能够降级成为读锁<h2 id="Condition"><a href="#Condition" class="headerlink" title="Condition"></a>Condition</h2>Lock 提供条件Condition，对线程的等待、唤醒操作更加详细和灵活<br>内部维护一个Condition队列。当前线程调用await()方法，将会以当前线程构造成一个节点（Node），并将节点加入到该队列的尾部<h1 id="并发工具类"><a href="#并发工具类" class="headerlink" title="并发工具类"></a>并发工具类</h1><h2 id="CyclicBarrier"><a href="#CyclicBarrier" class="headerlink" title="CyclicBarrier"></a>CyclicBarrier</h2>它允许一组线程互相等待，直到到达某个公共屏障点 (common barrier point)。<br>通俗讲：让一组线程到达一个屏障时被阻塞，直到最后一个线程到达屏障时，屏障才会开门，所有被屏障拦截的线程才会继续干活。<br>底层采用ReentrantLock + Condition实现。<br>应用场景：多线程结果合并的操作，用于多线程计算数据，最后合并计算结果的应用场景<h2 id="CountDownLatch"><a href="#CountDownLatch" class="headerlink" title="CountDownLatch"></a>CountDownLatch</h2>在完成一组正在其他线程中执行的操作之前，它允许一个或多个线程一直等待。<br>用给定的计数 初始化 CountDownLatch。由于调用了 countDown() 方法，所以在当前计数到达零之前，await 方法会一直受阻塞。之后，会释放所有等待的线程，await 的所有后续调用都将立即返回。这种现象只出现一次——计数无法被重置。如果需要重置计数，请考虑使用 CyclicBarrier。<br>内部采用共享锁来实现。<br><strong>与CyclicBarrier区别：</strong><br>CountDownLatch的作用是允许1或N个线程等待其他线程完成执行；而CyclicBarrier则是允许N个线程相互等待而没有线程完成。<br>CountDownLatch的计数器无法被重置；CyclicBarrier的计数器可以被重置后使用，因此它被称为是循环的barrier。<h2 id="Semaphore"><a href="#Semaphore" class="headerlink" title="Semaphore"></a>Semaphore</h2>Semaphore（信号量）一个控制访问多个共享资源的计数器。<br>从概念上讲，信号量维护了一个许可集。如有必要，在许可可用前会阻塞每一个 acquire()，然后再获取该许可。每个 release() 添加一个许可，从而可能释放一个正在阻塞的获取者。但是，不使用实际的许可对象，Semaphore 只对可用许可的号码进行计数，并采取相应的行动。<br>信号量Semaphore是一个非负整数（&gt;=1）。当一个线程想要访问某个共享资源时，它必须要先获取Semaphore，当Semaphore &gt;0时，获取该资源并使Semaphore – 1。如果Semaphore值 = 0，则表示全部的共享资源已经被其他线程全部占用，线程必须要等待其他线程释放资源。当线程释放资源时，Semaphore则+1。<br>内部采用共享锁实现。<br>应用场景：通常用于限制可以访问某些资源（物理或逻辑的）的线程数目<h2 id="Exchanger"><a href="#Exchanger" class="headerlink" title="Exchanger"></a>Exchanger</h2>可以在对中对元素进行配对和交换的线程的同步点。<br>允许在并发任务之间交换数据。具体来说，Exchanger类允许在两个线程之间定义同步点。当两个线程都到达同步点时，他们交换数据结构，因此第一个线程的数据结构进入到第二个线程中，第二个线程的数据结构进入到第一个线程中。<h1 id="ThreadLocal"><a href="#ThreadLocal" class="headerlink" title="ThreadLocal"></a>ThreadLocal</h1>一种解决多线程环境下成员变量的问题的方案，但是与线程同步无关。其思路是为每一个线程创建一个单独的变量副本，从而每个线程都可以独立地改变自己所拥有的变量副本，而不会影响其他线程所对应的副本。<br>ThreadLocal 不是用于解决共享变量的问题的，也不是为了协调线程同步而存在，而是为了方便每个线程处理自己的状态而引入的一个机制。<br><strong>主要方法：</strong><br>get()：返回此线程局部变量的当前线程副本中的值<br>initialValue()：返回此线程局部变量的当前线程的“初始值”<br>remove()：移除此线程局部变量当前线程的值<br>set(T value)：将此线程局部变量的当前线程副本中的值设置为指定值</li>
</ol>
<p><strong>ThreadLocalMap：</strong><br>实现线程隔离机制的关键。<br>每个Thread内部都有一个ThreadLocal.ThreadLocalMap类型的成员变量，该成员变量用来存储实际的ThreadLocal变量副本。<br>提供了一种用键值对方式存储每一个线程的变量副本的方法，key为当前ThreadLocal对象，value则是对应线程的变量副本<br><strong>注意点：</strong><br>ThreadLocal实例本身是不存储值，它只是提供了一个在当前线程中找到副本值得key。<br>是ThreadLocal包含在Thread中，而不是Thread包含在ThreadLocal中。<br>ThreadLocalMap中，key 是弱引用 ，而value 是强引用，无法回收造成内存泄露。（解决方法，手动调用remove()）</p>
<h1 id="Fork-Join框架"><a href="#Fork-Join框架" class="headerlink" title="Fork/Join框架"></a>Fork/Join框架</h1><p>一个用于并行执行任务的框架， 是一个把大任务分割成若干个小任务，最终汇总每个小任务结果后得到大任务结果的框架<br>核心思想<strong>分治</strong>：fork分解任务，join收集数据<br><strong>工作窃取：</strong></p>
<ol>
<li>某个线程从其他队列里窃取任务来执行</li>
<li>执行块的线程帮助执行慢的线程执行任务，提升整个任务效率</li>
<li>队列要采用双向队列<br><strong>核心类</strong><br>ForkJoinPool：执行任务的线程池<br>ForkJoinTask：表示任务，用于ForkJoinPool的任务抽象<br>ForkJoinWorkerThread：执行任务的工作线程<h1 id="atomic"><a href="#atomic" class="headerlink" title="atomic"></a>atomic</h1>这个用的都是<strong>CAS</strong><h1 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h1><h2 id="线程池好处"><a href="#线程池好处" class="headerlink" title="线程池好处"></a>线程池好处</h2>降低资源消耗 ：通过重复利用已创建的线程降低线程创建和销毁造成的消耗<br>提高响应速度 ：当任务到达时，任务可以不需要等到线程创建就能立即执行<br>提高线程的可管理性：进行统一分配、调优和监控  <h2 id="Future"><a href="#Future" class="headerlink" title="Future"></a>Future</h2>Future提供异步计算，提供的操作如下</li>
<li>执行任务的取消</li>
<li>查询任务是否完成</li>
<li>获取任务的执行结果</li>
</ol>
<p>FutureTask实现RunnableFuture接口，既可以作为Runnable被执行，也可以作为Future得到Callable的返回值，内部基于AQS实现</p>
<h2 id="Executor"><a href="#Executor" class="headerlink" title="Executor"></a>Executor</h2><h3 id="ThreadPoolExecutor"><a href="#ThreadPoolExecutor" class="headerlink" title="ThreadPoolExecutor"></a>ThreadPoolExecutor</h3><p><img src="http://upload-images.jianshu.io/upload_images/4714843-7ff634064c2bb355.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><br><strong>corePoolSize：</strong>线程池中核心线程的数量<br><strong>maximumPoolSize：</strong>线程池中允许的最大线程数<br><strong>keepAliveTime：</strong>线程空闲的时间<br><strong>unit：</strong>keepAliveTime的单位<br><strong>workQueue：</strong>用来保存等待执行的任务的阻塞队列，可以有</p>
<blockquote>
<p>ArrayBlockingQueue<br>LinkedBlockingQueue<br>SynchronousQueue<br>PriorityBlockingQueue</p>
</blockquote>
<p><strong>threadFactory：</strong>用于设置创建线程的工厂,DefaultThreadFactory<br><strong>handler：</strong>RejectedExecutionHandler，线程池的拒绝策略,可以分类</p>
<blockquote>
<p>AbortPolicy：直接抛出异常，默认策略<br>CallerRunsPolicy：用调用者所在的线程来执行任务<br>DiscardOldestPolicy：丢弃阻塞队列中靠最前的任务，并执行当前任务<br>DiscardPolicy：直接丢弃任务</p>
</blockquote>
<h3 id="Executors"><a href="#Executors" class="headerlink" title="Executors"></a>Executors</h3><p><img src="http://upload-images.jianshu.io/upload_images/4714843-81bffca66d68a4a2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Executors的结构图"><br>提供了一些静态方法等。</p>
<h4 id="newFixedThreadPool"><a href="#newFixedThreadPool" class="headerlink" title="newFixedThreadPool"></a>newFixedThreadPool</h4><p><code>return new ThreadPoolExecutor(var0, var0, 0L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue());</code><br>可重用固定线程数的线程池<br>corePoolSize和maximumPoolSize一致<br>使用“无界”队LinkedBlockingQueue<br>maximumPoolSize、keepAliveTime、RejectedExecutionHandler 无效   </p>
<h4 id="newCachedThreadPool"><a href="#newCachedThreadPool" class="headerlink" title="newCachedThreadPool"></a>newCachedThreadPool</h4><p>会根据需要创建新线程的线程池<br><code>return new ThreadPoolExecutor(0, 2147483647, 60L, TimeUnit.SECONDS, new SynchronousQueue());</code><br>corePoolSize被设置为0<br>maximumPoolSize被设置为Integer.MAX_VALUE<br>SynchronousQueue 作为WorkerQueue<br>如果主线程提交任务的速度高于maximumPool中线程处理任务的速度时，CachedThreadPool会不断创建新线程 ，可能会耗尽CPU和内存资源</p>
<h4 id="newSingleThreadExecutor"><a href="#newSingleThreadExecutor" class="headerlink" title="newSingleThreadExecutor"></a>newSingleThreadExecutor</h4><p><code>return new Executors.FinalizableDelegatedExecutorService(new ThreadPoolExecutor(1, 1, 0L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue()));</code><br>使用单个worker线程的Executor 。<br>corePoolSize和maximumPoolSize被设置为1<br>使用LinkedBlockingQueue作为workerQueue</p>
<h4 id="ScheduledThreadPoolExecutor"><a href="#ScheduledThreadPoolExecutor" class="headerlink" title="ScheduledThreadPoolExecutor"></a>ScheduledThreadPoolExecutor</h4><p>继承自ThreadPoolExecutor<br>给定的延迟之后运行任务，或者定期执行任务<br>内部使用DelayQueue来实现 ，会把调度的任务放入DelayQueue中。DelayQueue内部封装PriorityQueue，这个PriorityQueue会对队列中的ScheduledFutureTask进行排序  </p>
<h3 id="任务提交"><a href="#任务提交" class="headerlink" title="任务提交"></a>任务提交</h3><p>Executor.execute()和ExecutorService.submit()</p>
<h3 id="线程池调优"><a href="#线程池调优" class="headerlink" title="线程池调优"></a>线程池调优</h3><p>对上面的几个参数进行调优</p>
<h1 id="阻塞队列"><a href="#阻塞队列" class="headerlink" title="阻塞队列"></a>阻塞队列</h1><h2 id="ArrayBlockingQueue"><a href="#ArrayBlockingQueue" class="headerlink" title="ArrayBlockingQueue"></a>ArrayBlockingQueue</h2><p>一个由数组实现的FIFO有界阻塞队列<br>ArrayBlockingQueue有界且固定，在构造函数时确认大小，确认后不支持改变<br>在多线程环境下不保证“公平性”<br>底层实现：ReentrantLock和Condition</p>
<h2 id="LinkedBlockingQueue"><a href="#LinkedBlockingQueue" class="headerlink" title="LinkedBlockingQueue"></a>LinkedBlockingQueue</h2><p>基于链接，无界的FIFO阻塞队列</p>
<h2 id="PriorityBlockingQueue"><a href="#PriorityBlockingQueue" class="headerlink" title="PriorityBlockingQueue"></a>PriorityBlockingQueue</h2><p>支持优先级的无界阻塞队列<br>默认情况下元素采用自然顺序升序排序，可以通过指定Comparator来对元素进行排序<br>最大堆：父节点的键值总是大于或等于任何一个子节点的键值<br>最小堆：父节点的键值总是小于或等于任何一个子节点的键值<br>添加操作则是不断“上冒”，而删除操作则是不断“下掉”<br>底层实现：ReentrantLock和Condition和二叉堆</p>
<h2 id="DelayQueue"><a href="#DelayQueue" class="headerlink" title="DelayQueue"></a>DelayQueue</h2><p>支持延时获取元素的无界阻塞队列<br>应用：</p>
<blockquote>
<p>缓存：清掉缓存中超时的缓存数据<br>任务超时处理</p>
</blockquote>
<p>实现:</p>
<blockquote>
<p>ReentrantLock + Condition<br>根据Delay时间排序的优先级队列：PriorityQueue</p>
</blockquote>
<p>Delayed接口:</p>
<blockquote>
<p>用来标记那些应该在给定延迟时间之后执行的对象<br>该接口要求实现它的实现类必须定义一个compareTo 方法，该方法提供与此接口的 getDelay 方法一致的排序。</p>
<h2 id="SynchronousQueue"><a href="#SynchronousQueue" class="headerlink" title="SynchronousQueue"></a>SynchronousQueue</h2><p>一个没有容量的阻塞队列<br>应用：交换工作，生产者的线程和消费者的线程同步以传递某些信息、事件或者任务</p>
<h2 id="LinkedTransferQueue"><a href="#LinkedTransferQueue" class="headerlink" title="LinkedTransferQueue"></a>LinkedTransferQueue</h2><p>链表组成的的无界阻塞队列<br>相当于ConcurrentLinkedQueue、SynchronousQueue (公平模式下)、无界的LinkedBlockingQueues等的超集<br>预占模式：有就直接拿走，没有就占着这个位置直到拿到或者超时或者中断</p>
<h2 id="LinkedBlockingDeque"><a href="#LinkedBlockingDeque" class="headerlink" title="LinkedBlockingDeque"></a>LinkedBlockingDeque</h2><p>由链表组成的双向阻塞队列<br>容量可选，在初始化时可以设置容量防止其过度膨胀，如果不设置，默认容量大小为Integer.MAX_VALUE<br>应用：“工作窃取”模式</p>
<h1 id="并发集合"><a href="#并发集合" class="headerlink" title="并发集合"></a>并发集合</h1><h2 id="ConcurrentHashMap"><a href="#ConcurrentHashMap" class="headerlink" title="ConcurrentHashMap"></a>ConcurrentHashMap</h2><p>CAS + Synchronized 来保证并发更新的安全，底层采用数组+链表/红黑树的存储结构</p>
<h3 id="重要内部类"><a href="#重要内部类" class="headerlink" title="重要内部类"></a>重要内部类</h3><p>Node：key-value键值对<br>TreeNode：红黑树节点<br>TreeBin：就相当于一颗红黑树，其构造方法其实就是构造红黑树的过程<br>ForwardingNode：<br>辅助节点，用于ConcurrentHashMap扩容操作<br>控制标识符，用来控制table初始化和扩容操作的<br>负数代表正在进行初始化或扩容操作<br>-1代表正在初始化<br>-N 表示有N-1个线程正在进行扩容操作<br>正数或0代表hash表还没有被初始化，这个数值表示初始化或下一次进行扩容的大小</p>
<h3 id="重要方法"><a href="#重要方法" class="headerlink" title="重要方法"></a>重要方法</h3><p><strong>initTable</strong><br>ConcurrentHashMap初始化方法，只能有一个线程参与初始化过程，其他线程必须挂起，构造函数不做初始化过程，初始化真正是在put操作触发。具体步骤是</p>
<ol>
<li>sizeCtl &lt; 0 表示正在进行初始化，线程挂起</li>
<li>线程获取初始化资格（CAS(SIZECTL, sc, -1)）进行初始化过程</li>
<li>初始化步骤完成后，设置sizeCtl = 0.75 * n（下一次扩容阈值），表示下一次扩容的大小</li>
</ol>
</blockquote>
<p><strong>put</strong><br>思想：根据hash值计算节点插入在table的位置，如果该位置为空，则直接插入，否则插入到链表或者树中<br>步骤：</p>
<ol>
<li>table为null，线程进入初始化步骤，如果有其他线程正在初始化，该线程挂起</li>
<li>如果插入的当前 i 位置 为null，说明该位置是第一次插入，利用CAS插入节点即可，插入成功，则调用addCount判断是否需要扩容。若插入失败，则继续匹配（自旋）</li>
<li>若该节点的hash == MOVED（-1），表示有线程正在进行扩容，则进入扩容进程中</li>
<li>其余情况就是按照链表或者红黑树结构插入节点，但是这个过程需要加锁（synchronized）</li>
</ol>
<p><strong>get</strong><br>根据key的hash值去找对应的数组，然后通过去如果有冲突，用equals去匹配</p>
<p><strong>扩容</strong><br>多线程扩容</p>
<blockquote>
<p>构建一个nextTable，其大小为原来大小的两倍，这个步骤是在单线程环境下完成的<br>将原来table里面的内容复制到nextTable中，这个步骤是允许多线程操作</p>
</blockquote>
<p><strong>链表转换为红黑树过程</strong><br>所在链表的元素个数达到了阈值 8，则将链表转换为红黑树</p>
<p><strong>1.8 与 1.7的区别</strong></p>
<h2 id="ConcurrentLinkedQueue"><a href="#ConcurrentLinkedQueue" class="headerlink" title="ConcurrentLinkedQueue"></a>ConcurrentLinkedQueue</h2><p>基于链接节点的无边界的线程安全队列，采用FIFO原则对元素进行排序，内部采用CAS算法实现.<br>不变性</p>
<blockquote>
<p>在入队的最后一个元素的next为null<br>队列中所有未删除的节点的item都不能为null且都能从head节点遍历到<br>对于要删除的节点，不是直接将其设置为null，而是先将其item域设置为null（迭代器会跳过item为null的节点）<br>允许head和tail更新滞后。</p>
</blockquote>
<p>head的不变性和可变性<br>tail的不变性和可变性<br>精妙之处：利用CAS来完成数据操作，同时允许队列的不一致性，弱一致性表现淋漓尽致</p>
]]></content>
      
        
    </entry>
    
  
  
</search>
