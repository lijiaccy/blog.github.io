<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Netty之ByteBuf源码(二)]]></title>
    <url>%2F2017%2F10%2F30%2FNetty%E4%B9%8BByteBuf%E6%BA%90%E7%A0%81-%E4%BA%8C%2F</url>
    <content type="text"><![CDATA[UnpooledHeapByteBufUnpooledHeapByteBuf是一个非线程池实现的在堆内存进行内存分配的字节缓冲区，在每次IO操作的都会去创建一个UnpooledHeapByteBuf对象，如果频繁地对内存进行分配或者释放会对性能造成影响。 成员变量 ByteBufAllocator 用于内存分配 array 字节数组作为缓冲区，用于存储字节数据 ByteBuffer 用来实现Netty ByteBuf 到Nio ByteBuffer的变换动态扩展缓冲区调用capacity方法动态扩展缓冲区，首先要对扩展容量进行校验，如果新容量的大小小于0或者大于最大可扩展容量maxCapacity的话，抛出IllegalArgumentException异常。通过校验之后，如果新扩展容量比原来大的话，则创建一个新的容量为新扩展容量的字节数组缓冲区，然后调用System.arraycopy进行内存复制，将旧的数据复制到新数组中去，然后用setArray进行数组替换。动态扩展之后需要原来的视图tmpNioBuffer设置为控。如果新的容量小于当前缓冲区容量的话，不需要进行动态扩展，但是需要截取部分数据作为子缓冲区。 首先对当前的readerIndex是否小于newCapacity，如果小于的话继续对writerIndex跟newCapacity进行比较，如果writerIndex大于newCapacity的话，就将writerIndex设置为newCapacity，更新完索引之后就通过System.arrayCopy内存复制将当前可读的数据复制到新的缓冲区字节数组中。 如果newCapacity小于readerIndex的话，说明没有新的可读数据要复制到新的字节数组缓冲区中，只需要把writerIndex跟readerIndex都更新为newCapacity既可，最后调用setArray更换字节数组。 public ByteBuf capacity(int newCapacity) { ensureAccessible(); if (newCapacity &lt; 0 || newCapacity &gt; maxCapacity()) { throw new IllegalArgumentException(&quot;newCapacity: &quot; + newCapacity); } int oldCapacity = array.length; if (newCapacity &gt; oldCapacity) { byte[] newArray = new byte[newCapacity]; System.arraycopy(array, 0, newArray, 0, array.length); setArray(newArray); } else if (newCapacity &lt; oldCapacity) { byte[] newArray = new byte[newCapacity]; int readerIndex = readerIndex(); if (readerIndex &lt; newCapacity) { int writerIndex = writerIndex(); if (writerIndex &gt; newCapacity) { writerIndex(writerIndex = newCapacity); } System.arraycopy(array, readerIndex, newArray, readerIndex, writerIndex - readerIndex); } else { setIndex(newCapacity, newCapacity); } setArray(newArray); } return this; } setBytes字节数组复制，首先对数据进行合法性检验，如果srcIndex或者index的值小于0，就会抛出IllegalArgumentException，如果index+length的值大于capacity的值或者srcIndex+length的值大于src.length的话，就会抛出IndexOutOfBoundsException异常。通过校验之后，就调用System.arraycopy进行字节数组复制。 public ByteBuf setBytes(int index, byte[] src, int srcIndex, int length) { checkSrcIndex(index, length, srcIndex, src.length); System.arraycopy(src, srcIndex, array, index, length); return this; } protected final void checkSrcIndex(int index, int length, int srcIndex, int srcCapacity) { checkIndex(index, length); if (srcIndex &lt; 0 || srcIndex &gt; srcCapacity - length) { throw new IndexOutOfBoundsException(String.format( &quot;srcIndex: %d, length: %d (expected: range(0, %d))&quot;, srcIndex, length, srcCapacity)); } } Netty ByteBuf与Nio ByteBuffer转换要将Netty的ByteBuf转化为Nio ByteBuffer，在ByteBuffer中有wrap静态方法，只需要传入对应的字节数组即可创建转化为ByteBuffer，在nioBuffer方法还调用了slice方法，它可以创建一个从原ByteBuffer的position开始缓冲区，与原缓冲区共享同一段数据元素。nioBuffer方法不会重用缓冲区，只能保证writerIndex跟readerIndex的独立性。 public ByteBuffer nioBuffer(int index, int length) { ensureAccessible(); return ByteBuffer.wrap(array, index, length).slice(); } PooledByteBuf在Netty4之后加入内存池管理，通过内存池管理比之前ByteBuf的创建性能得到了极大提高。 PoolChunk Page 可以用来分配的最小内存块单位 Chunk page的集合 PoolChunk主要负责内存块的分配及释放，chunk中的page会构建成一颗二叉树，默认情况下page的大小是8K,chunk的大小是2^11 page，即16M，构成了11层的二叉树，最下面一层的叶子节点有8192个，与page的数目一样，每一次内存的分配必须保证连续性，方便内存操作。每个节点会记录自己在Memory Area的偏移地址，当一个节点表示的内存区域被分配之后，那么该节点会被标志为已分配，该节点的所有子节点的内存请求都会忽略。每次内存分配的都是8k(2^n)大小的内存块，当需要分配大小为chunkSize/(2^k)的内存端时，为了找到可用的内存段，会从第K层左边开始寻找可用节点。 PoolArena在内存分配中，为了能够集中管理内存的分配及释放，同时提供分配和释放内存的性能，一般都是会先预先分配一大块连续的内存，不需要重复频繁地进行内存操作，那一大块连续的内存就叫做memory Arena，而PoolArena是Netty的内存池实现类。在Netty中，PoolArena是由多个Chunk组成的，而每个Chunk则由多个Page组成。PoolArena是由Chunk和Page共同组织和管理的。 PoolSubpage当对于小于一个Page的内存分配的时候，每个Page会被划分为大小相等的内存块，它的大小是根据第一次申请内存分配的内存块大小来决定的。一个Page只能分配与第一次内存内存的内存块的大小相等的内存块，如果想要想要申请大小不想等的内存块，只能在新的Page上申请内存分配了。Page中的存储区域的使用情况是通过一个long数组bitmap来维护的,每一位表示一个区域的占用情况。 PooledDirectByteBuf创建字节缓冲区由于内存池实现，每次创建字节缓冲区的时候，不是直接new，而是从内存池中去获取，然后设置引用计数器跟读写Index，跟缓冲区最大容量返回。 static PooledHeapByteBuf newInstance(int maxCapacity) { PooledHeapByteBuf buf = RECYCLER.get(); buf.reuse(maxCapacity); return buf; } final void reuse(int maxCapacity) { maxCapacity(maxCapacity); setRefCnt(1); setIndex0(0, 0); discardMarks(); } 复制字节缓冲区实例copy方法可以复制一个字节缓冲区实例，与原缓冲区独立。首先要对index和length进行合法性判断，然后调用PooledByteBufAllocator的directBuffer方法分配一个新的缓冲区。newDirectBuffer方法是一个抽象方法，对于不同的子类有不同的实现。如果是unpooled的话，会直接创建一个新的缓冲区，如果是pooled的话，它会从内存池中获取一个可用的缓冲区。 public ByteBuf copy(int index, int length) { checkIndex(index, length); ByteBuf copy = alloc().directBuffer(length, maxCapacity()); copy.writeBytes(this, index, length); return copy; } public ByteBuf directBuffer(int initialCapacity, int maxCapacity) { if (initialCapacity == 0 &amp;&amp; maxCapacity == 0) { return emptyBuf; } validate(initialCapacity, maxCapacity); return newDirectBuffer(initialCapacity, maxCapacity); } // PooledByteBufAllocator protected ByteBuf newDirectBuffer(int initialCapacity, int maxCapacity) { PoolThreadCache cache = threadCache.get(); PoolArena&lt;ByteBuffer&gt; directArena = cache.directArena; ByteBuf buf; if (directArena != null) { buf = directArena.allocate(cache, initialCapacity, maxCapacity); } else { if (PlatformDependent.hasUnsafe()) { buf = new UnpooledUnsafeDirectByteBuf(this, initialCapacity, maxCapacity); } else { buf = new UnpooledDirectByteBuf(this, initialCapacity, maxCapacity); } } return toLeakAwareBuffer(buf); } //UnpooledByteBufAllocator protected ByteBuf newDirectBuffer(int initialCapacity, int maxCapacity) { ByteBuf buf; if (PlatformDependent.hasUnsafe()) { buf = new UnpooledUnsafeDirectByteBuf(this, initialCapacity, maxCapacity); } else { buf = new UnpooledDirectByteBuf(this, initialCapacity, maxCapacity); } return toLeakAwareBuffer(buf); } ByteBuf辅助类ByteBufHolderByteBufHolder是ByteBuf的一个容器，它可以更方便地访问ByteBuf中的数据，在使用不同的协议进行数据传输的时候，不同的协议消息体包含的数据格式和字段不一样，所以抽象一个ByteBufHolder对ByteBuf进行包装，不同的子类有不同的实现，使用者可以根据自己的需要进行实现。Netty提供了一个默认实现DefaultByteBufHolder。 ByteBufAllocatorByteBufAllocator是字节缓冲区分配器，根据Netty字节缓冲区的实现不同，分为两种不同的分配器PooledByteBufAllocator和UnpooledByteBufAllocator。他们提供了不同ByteBuf的分配方法。 CompositeByteBufCompositeByteBuf是一个虚拟的Buffer，它可以将多个ByteBuf组装为一个ByteBuf视图。 ByteBufUtilByteBufUtil是ByteBuf的工具类，它提供了一系列的静态方法来操作ByteBuf。]]></content>
      <categories>
        <category>netty</category>
      </categories>
      <tags>
        <tag>netty</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Netty之ByteBuf源码(一)]]></title>
    <url>%2F2017%2F10%2F27%2FNetty%E4%B9%8BByteBuf%E6%BA%90%E7%A0%81-%E4%B8%80%2F</url>
    <content type="text"><![CDATA[了解ByteBuf之前应先了解Java NIO的Buffer。而且主要使用的是Buffer的实现类ByteBuffer。这里主要以ByteBuffer。 NIO的ByteBuffer参考 http://www.jianshu.com/p/d67129097a88里面的四个属性 容量（Capacity）：缓冲区能够容纳的数据元素的最大数量。这一容量在缓冲区创建时被设定，并且永远不能被改变。 上界（Limit）：缓冲区的第一个不能被读或写的元素。或者说，缓冲区中现存元素的计数。 位置（Position）：下一个要被读或写的元素的索引。位置会自动由相应的 get( )和 put( )函数更新。 标记（Mark）：一个备忘位置。调用 mark( )来设定 mark = postion。调用 reset( )设定 position = mark。标记在设定前是未定义的( undefined) 。由于NIO复杂性，Buffer的实现类ByteBuffer也有其局限性，（1）、ByteBuffer长度固定，一旦分配完成，它的容量不能动态扩展和收缩，当需要编码的POJO对象大于ByteBuffer的容量时，会报索引越界异常。（2）、ByteBuffer只有一个标识位置的指针position，读写的时候需要手工调用flip()和rewind()，使用者必须小心谨慎的处理这些API，否则会导致程序处理失败。（3）、ByteBuffer的API功能有限，一个高级和实用的特性它不支持，需要自己去实现。 Netty的ByteBufNetty的ByteBuf在ByteBuffer上做了修改，区分了读写，引入了两个位置属性，readIndex和writeIndex来取代position。这样就可以不用切换flip了。a、首先初始化一个ByteBuf，b、开始的时候readIndex=writeIndex=0，c、写数据，writeIndex向后移动d、读数据，readIndex向后移，但是不能超过writeIndexe、从0-readIndex这部分叫做discard，调用discardReadBytes方法，可以释放这部分空间。类似于ByteBuffer的compact方法。回收之后，0 = readIndex，writeIndex= writeIndex-discard。可写的区域变大了。从readIndex到writeIndex这之间的数据可读，从writeIndex到capacity这之间的数据可写。 ByteBuf的继承关系 从内存分配角度看：（1）堆内存（HeapByteBuf）字节缓冲区：特点是内存的分配和回收速度快，可以被JVM自动回收；缺点是如果进行Socket的I/O读写，需要额外做一次内存复制，将堆内存对应的缓冲区复制到内核Channel中，性能有一定的下降（2）直接内存（DirectByteBuf）字节缓冲区：非堆内存，它在堆外进行内存分配，相比于堆内存，它的分配和回收会慢一点，但是将它写入和从SocketChannel中读取时，相当于少一次内存复制，速度比对内存快。**经验表明：ByteBuf最佳实践是在I/O通信线程读写缓冲区使用DirectByteBuf，后端业务消息的编解码模块使用HeapByteBuf，这样组合可以达到性能最优。 从内存回收角度看对象池的ByteBuf和普通ByteBuf。两者的主要区别是就是基于对象池的ByteBuf可以重用ByteBuf对象，它自己维护一个内存池，可以循环利用创建的ByteBuf，提升内存使用效率，降低由于高负载导致的频繁GC。测试标明使用内存池后的Netty在高负载，大并发的冲击下内存和GC更加平稳。尽管推荐使用基于内存池的ByteBuf，但是内存池的管理和维护更加复杂，使用起来更加谨慎。 ByteBuf的动态扩展正常情况下，NIO对ByteBuffer进行put操作时，如果缓冲区剩余可写空间不够，会发生BufferOverflowException。为了避免这个问题，通常在put时会对剩余可用空间进行校验，如果剩余空间不足，需要重新创建一个新的ByteBuffer，并将之前的ByteBuffer复制到新创建的ByteBuffer中，最后释放老的ByteBuffer。而由ByteBuf的write操作负责剩余的可用空间检验，如果可用缓冲区不足，ByteBuf会自动扩容。对于使用者而言，不需要关系底层的校验和扩展。代码如下。三个参数，src写的数据，srcIndex就是writeIndex，长度。 public ByteBuf writeBytes(byte[] src, int srcIndex, int length) { this.ensureAccessible(); this.ensureWritable(length); this.setBytes(this.writerIndex, src, srcIndex, length); this.writerIndex += length; return this; } public ByteBuf ensureWritable(int minWritableBytes) { if (minWritableBytes &lt; 0) { throw new IllegalArgumentException(String.format(&quot;minWritableBytes: %d (expected: &gt;= 0)&quot;, minWritableBytes)); } else if (minWritableBytes &lt;= this.writableBytes()) { return this; } else if (minWritableBytes &gt; this.maxCapacity - this.writerIndex) { throw new IndexOutOfBoundsException(String.format(&quot;writerIndex(%d) + minWritableBytes(%d) exceeds maxCapacity(%d): %s&quot;, this.writerIndex, minWritableBytes, this.maxCapacity, this)); } else { int newCapacity = this.alloc().calculateNewCapacity(this.writerIndex + minWritableBytes, this.maxCapacity); this.capacity(newCapacity); return this; } } ByteBuf的主要API以AbstractByteBuf为例来看，除了上面的write方法之外，还有readBytes：缓冲区的内容 public ByteBuf readBytes(byte[] dst, int dstIndex, int length) { //对缓冲区的可用空间进行校验 this.checkReadableBytes(length); this.getBytes(this.readerIndex, dst, dstIndex, length); this.readerIndex += length; return this; } slice：获取调用者的子缓冲区，且与原缓冲区共享缓冲区 public ByteBuf slice() { return this.slice(this.readerIndex, this.readableBytes()); } public SlicedByteBuf(ByteBuf buffer, int index, int length) { super(length); if (index &gt;= 0 &amp;&amp; index &lt;= buffer.capacity() - length) { if (buffer instanceof SlicedByteBuf) { this.buffer = ((SlicedByteBuf)buffer).buffer; this.adjustment = ((SlicedByteBuf)buffer).adjustment + index; } else if (buffer instanceof DuplicatedByteBuf) { this.buffer = buffer.unwrap(); this.adjustment = index; } else { this.buffer = buffer; this.adjustment = index; } this.length = length; this.writerIndex(length); } else { throw new IndexOutOfBoundsException(buffer + &quot;.slice(&quot; + index + &quot;, &quot; + length + &apos;)&apos;); } } copy：复制一份全新的对象，内容和缓冲区都不是共享的 public ByteBuf copy(int index, int length) { this.checkIndex(index, length); return this.buffer.copy(index + this.adjustment, length); } duplicate：复制当前对象，复制后的对象与前对象共享缓冲区，且维护自己的独立索引 public ByteBuf duplicate() { return new DuplicatedByteBuf(this); } public DuplicatedByteBuf(ByteBuf buffer) { super(buffer.maxCapacity()); if (buffer instanceof DuplicatedByteBuf) { this.buffer = ((DuplicatedByteBuf)buffer).buffer; } else { this.buffer = buffer; } this.setIndex(buffer.readerIndex(), buffer.writerIndex()); } discardReadBytes和discardSomeReadBytes：重用缓冲区设置读写索引的同时需要调用adjustMarkers()调整markedReaderIndex和markedWriterIndex public ByteBuf discardReadBytes() { this.ensureAccessible(); if (this.readerIndex == 0) { return this; } else { if (this.readerIndex != this.writerIndex) { this.setBytes(0, this, this.readerIndex, this.writerIndex - this.readerIndex); this.writerIndex -= this.readerIndex; this.adjustMarkers(this.readerIndex); this.readerIndex = 0; } else { this.adjustMarkers(this.readerIndex); this.writerIndex = this.readerIndex = 0; } return this; } } public ByteBuf discardSomeReadBytes() { this.ensureAccessible(); if (this.readerIndex == 0) { return this; } else if (this.readerIndex == this.writerIndex) { this.adjustMarkers(this.readerIndex); this.writerIndex = this.readerIndex = 0; return this; } else { if (this.readerIndex &gt;= this.capacity() &gt;&gt;&gt; 1) { this.setBytes(0, this, this.readerIndex, this.writerIndex - this.readerIndex); this.writerIndex -= this.readerIndex; this.adjustMarkers(this.readerIndex); this.readerIndex = 0; } return this; } } protected final void adjustMarkers(int decrement) { int markedReaderIndex = this.markedReaderIndex; if (markedReaderIndex &lt;= decrement) { this.markedReaderIndex = 0; int markedWriterIndex = this.markedWriterIndex; if (markedWriterIndex &lt;= decrement) { this.markedWriterIndex = 0; } else { this.markedWriterIndex = markedWriterIndex - decrement; } } else { this.markedReaderIndex = markedReaderIndex - decrement; this.markedWriterIndex -= decrement; } } skipBytes：丢弃非法的数据报 public ByteBuf skipBytes(int length) { this.checkReadableBytes(length); this.readerIndex += length; return this; } 代码示例import io.netty.buffer.ByteBuf; import io.netty.buffer.Unpooled; public class Test { public static void main(String[] args) { ByteBuf byteBuf = Unpooled.buffer(4); //ByteBuf byteBuf = Unpooled.directBuffer(4); byteBuf.writeByte(1); byteBuf.writeByte(2); //结果为1 System.out.println(byteBuf.readByte()); //结果为2 System.out.println(byteBuf.readByte()); byteBuf.writeByte(3); //结果为2 System.out.println(byteBuf.readerIndex()); //结果为3 System.out.println(byteBuf.writerIndex()); byteBuf.discardReadBytes(); //结果为0 System.out.println(byteBuf.readerIndex()); //结果为1 System.out.println(byteBuf.writerIndex()); byteBuf.writeByte(3); byteBuf.writeByte(3); byteBuf.writeByte(3); byteBuf.writeByte(3); byteBuf.writeByte(3); byteBuf.writeByte(3); //结果为0 System.out.println(byteBuf.readerIndex()); //结果为7 System.out.println(byteBuf.writerIndex()); //结果为64 System.out.println(byteBuf.capacity()); //slice是重新复制了一个对象 ByteBuf slice = byteBuf.slice(); //结果为7 System.out.println(slice.writerIndex()); //UnpooledHeapByteBuf(ridx: 0, widx: 7, cap: 64) System.out.println(byteBuf.markReaderIndex()); //SlicedByteBuf(ridx: 0, widx: 7, cap: 7/7, unwrapped: UnpooledHeapByteBuf(ridx: 0, widx: 7, cap: 64)) System.out.println(slice.markReaderIndex()); ByteBuf copy = byteBuf.copy(); //copy是复制了byteBuf //结果是UnpooledHeapByteBuf(ridx: 0, widx: 7, cap: 7) System.out.println(copy.markReaderIndex()); } } 其他的以后再慢慢熟悉吧。]]></content>
      <categories>
        <category>netty</category>
      </categories>
      <tags>
        <tag>netty</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[netty之客户端创建]]></title>
    <url>%2F2017%2F10%2F25%2Fnetty%E4%B9%8B%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%88%9B%E5%BB%BA%2F</url>
    <content type="text"><![CDATA[其实客户端创建和服务端流程差不多，但是更加复杂，有线程模型，异步连接，客户端连接超时，各种异常处理。 客户端的实例代码如下：import io.netty.bootstrap.Bootstrap; import io.netty.channel.ChannelFuture; import io.netty.channel.ChannelInitializer; import io.netty.channel.ChannelOption; import io.netty.channel.EventLoopGroup; import io.netty.channel.nio.NioEventLoopGroup; import io.netty.channel.socket.SocketChannel; import io.netty.channel.socket.nio.NioSocketChannel; import io.netty.handler.codec.string.StringDecoder; public class TimeClient { public void connect(int port, String host) throws Exception { // 配置客户端NIO线程组 EventLoopGroup group = new NioEventLoopGroup(); try { Bootstrap b = new Bootstrap(); b.group(group).channel(NioSocketChannel.class) .option(ChannelOption.TCP_NODELAY, true) .handler(new ChannelInitializer&lt;SocketChannel&gt;() { @Override public void initChannel(SocketChannel ch) throws Exception { ch.pipeline().addLast(new StringDecoder()); ch.pipeline().addLast(new TimeClientHandler()); } }); // 发起异步连接操作 ChannelFuture f = b.connect(host, port).sync(); // 当代客户端链路关闭 f.channel().closeFuture().sync(); } finally { // 优雅退出，释放NIO线程组 group.shutdownGracefully(); } } public static void main(String[] args) throws Exception { int port = 8080; if (args != null &amp;&amp; args.length &gt; 0) { try { port = Integer.valueOf(args[0]); } catch (NumberFormatException e) { // 采用默认值 } } new TimeClient().connect(port, &quot;127.0.0.1&quot;); } } 客户端创建步骤根据上面的代码：1、用户线程创建Bootstrap实例，通过API设置创建客户端相关的参数，异步发起客户端连接。 Bootstrap b = new Bootstrap(); 源码是： private static final NameResolverGroup&lt;?&gt; DEFAULT_RESOLVER; public Bootstrap() { this.resolver = DEFAULT_RESOLVER; } 2、创建处理客户端连接，I/O读写的Reactor线程组NioEventLoopGroup。可以通过构造行数指定I/O的个数，默认是CPU内核数的2倍。 EventLoopGroup group = new NioEventLoopGroup(); 3、通过Bootstrap的ChannelFactory和用户指定的Channel类型创建用于客户端连接的NioSocketChannel，它的功能类似于Jdk的SocketChannel b.group(group).channel(NioSocketChannel.class) 源码如下： private volatile EventLoopGroup group; public B group(EventLoopGroup group) { if (group == null) { throw new NullPointerException(&quot;group&quot;); } else if (this.group != null) { throw new IllegalStateException(&quot;group set already&quot;); } else { this.group = group; return this; } } public B channel(Class&lt;? extends C&gt; channelClass) { if (channelClass == null) { throw new NullPointerException(&quot;channelClass&quot;); } else { //用反射创建一个ChannelFactory对象 return this.channelFactory((io.netty.channel.ChannelFactory)(new ReflectiveChannelFactory(channelClass))); } } 4、创建默认的ChannelHandler Pipeline。用于调度和执行网络事件 5、异步发起TCP连接，判断连接是否成功如果成功，则直接将NioSocketChannel注册到多路复用器上，监听读操作位，用于数据报读取和消息发送。如果没有立即连接成功，则注册到连接监听位到多路复用器，等待连接结果。Channel配置参数: //ByteBuf的分配器，默认值为ByteBufAllocator.DEFAULT，4.0版本为UnpooledByteBufAllocator，4.1版本为PooledByteBufAllocator。该值也可以使用系统参数io.netty.allocator.type配置，使用字符串值：&quot;unpooled&quot;，&quot;pooled&quot; public static final ChannelOption&lt;ByteBufAllocator&gt; ALLOCATOR = valueOf(&quot;ALLOCATOR&quot;); //用于Channel分配接受Buffer的分配器，默认值为AdaptiveRecvByteBufAllocator.DEFAULT，是一个自适应的接受缓冲区分配器，能根据接受到的数据自动调节大小。可选值为FixedRecvByteBufAllocator，固定大小的接受缓冲区分配器。 public static final ChannelOption&lt;RecvByteBufAllocator&gt; RCVBUF_ALLOCATOR = valueOf(&quot;RCVBUF_ALLOCATOR&quot;); //消息大小估算器，默认为DefaultMessageSizeEstimator.DEFAULT。估算ByteBuf、ByteBufHolder和FileRegion的大小，其中ByteBuf和ByteBufHolder为实际大小，FileRegion估算值为0。该值估算的字节数在计算水位时使用，FileRegion为0可知FileRegion不影响高低水位。 public static final ChannelOption&lt;MessageSizeEstimator&gt; MESSAGE_SIZE_ESTIMATOR = valueOf(&quot;MESSAGE_SIZE_ESTIMATOR&quot;); //客户端连接超时时间,默认值30000毫秒即30秒。 public static final ChannelOption&lt;Integer&gt; CONNECT_TIMEOUT_MILLIS = valueOf(&quot;CONNECT_TIMEOUT_MILLIS&quot;); public static final ChannelOption&lt;Integer&gt; MAX_MESSAGES_PER_READ = valueOf(&quot;MAX_MESSAGES_PER_READ&quot;); //一次Loop读取的最大消息数，对于ServerChannel或者NioByteChannel，默认值为16，其他Channel默认值为1。默认值这样设置，是因为：ServerChannel需要接受足够多的连接，保证大吞吐量，NioByteChannel可以减少不必要的系统调用select。 public static final ChannelOption&lt;Integer&gt; WRITE_SPIN_COUNT = valueOf(&quot;WRITE_SPIN_COUNT&quot;); //写高水位标记，默认值64KB。如果Netty的写缓冲区中的字节超过该值，Channel的isWritable()返回False。 public static final ChannelOption&lt;Integer&gt; WRITE_BUFFER_HIGH_WATER_MARK = valueOf(&quot;WRITE_BUFFER_HIGH_WATER_MARK&quot;); //写低水位标记，默认值32KB。当Netty的写缓冲区中的字节超过高水位之后若下降到低水位，则Channel的isWritable()返回True。写高低水位标记使用户可以控制写入数据速度，从而实现流量控制 public static final ChannelOption&lt;Integer&gt; WRITE_BUFFER_LOW_WATER_MARK = valueOf(&quot;WRITE_BUFFER_LOW_WATER_MARK&quot;); //一个连接的远端关闭时本地端是否关闭，默认值为False。值为False时，连接自动关闭；为True时，触发ChannelInboundHandler的userEventTriggered()方法，事件为ChannelInputShutdownEvent。 public static final ChannelOption&lt;Boolean&gt; ALLOW_HALF_CLOSURE = valueOf(&quot;ALLOW_HALF_CLOSURE&quot;); //自动读取，默认值为True。Netty只在必要的时候才设置关心相应的I/O事件。 public static final ChannelOption&lt;Boolean&gt; AUTO_READ = valueOf(&quot;AUTO_READ&quot;); //Socket参数，设置广播模式。 public static final ChannelOption&lt;Boolean&gt; SO_BROADCAST = valueOf(&quot;SO_BROADCAST&quot;); //Socket参数，连接保活，默认值为False。启用该功能时，TCP会主动探测空闲连接的有效性。可以将此功能视为TCP的心跳机制，需要注意的是：默认的心跳间隔是7200s即2小时。Netty默认关闭该功能。 public static final ChannelOption&lt;Boolean&gt; SO_KEEPALIVE = valueOf(&quot;SO_KEEPALIVE&quot;); //套接字使用的发送缓存区大小 public static final ChannelOption&lt;Integer&gt; SO_SNDBUF = valueOf(&quot;SO_SNDBUF&quot;); //套接字使用的接收缓存区大小 public static final ChannelOption&lt;Integer&gt; SO_RCVBUF = valueOf(&quot;SO_RCVBUF&quot;); //用于决定如果网络上仍然有数据向旧的ServerSocket传输数据，是否允许新的ServerSocket绑定到旧的ServerSocket通用的端口上 public static final ChannelOption&lt;Boolean&gt; SO_REUSEADDR = valueOf(&quot;SO_REUSEADDR&quot;); //Netty对底层Socket参数的简单封装，关闭Socket的延迟时间，默认值为-1，表示禁用该功能。-1以及所有&lt;0的数表示socket.close()方法立即返回，但OS底层会将发送缓冲区全部发送到对端。0表示socket.close()方法立即返回，OS放弃发送缓冲区的数据直接向对端发送RST包，对端收到复位错误。非0整数值表示调用socket.close()方法的线程被阻塞直到延迟时间到或发送缓冲区中的数据发送完毕，若超时，则对端会收到复位错误。 public static final ChannelOption&lt;Integer&gt; SO_LINGER = valueOf(&quot;SO_LINGER&quot;); //Socket参数，服务端接受连接的队列长度，如果队列已满，客户端连接将被拒绝。默认值，Windows为200，其他为128。 public static final ChannelOption&lt;Integer&gt; SO_BACKLOG = valueOf(&quot;SO_BACKLOG&quot;); //控制读取操作将阻塞多少毫秒，如果返回0，计时器就禁止了，改线程无限期阻塞 public static final ChannelOption&lt;Integer&gt; SO_TIMEOUT = valueOf(&quot;SO_TIMEOUT&quot;); //IP参数，设置IP头部的Type-of-Service字段，用于描述IP包的优先级和QoS选项。 public static final ChannelOption&lt;Integer&gt; IP_TOS = valueOf(&quot;IP_TOS&quot;); //对应IP参数IP_MULTICAST_IF，设置对应地址的网卡为多播模式。 public static final ChannelOption&lt;InetAddress&gt; IP_MULTICAST_ADDR = valueOf(&quot;IP_MULTICAST_ADDR&quot;); //对应IP参数IP_MULTICAST_IF2，同上但支持IPV6。 public static final ChannelOption&lt;NetworkInterface&gt; IP_MULTICAST_IF = valueOf(&quot;IP_MULTICAST_IF&quot;); //IP参数，多播数据报的time-to-live即存活跳数。 public static final ChannelOption&lt;Integer&gt; IP_MULTICAST_TTL = valueOf(&quot;IP_MULTICAST_TTL&quot;); //对应IP参数IP_MULTICAST_LOOP，设置本地回环接口的多播功能。由于IP_MULTICAST_LOOP返回True表示关闭，所以Netty加上后缀_DISABLED防止歧义。 public static final ChannelOption&lt;Boolean&gt; IP_MULTICAST_LOOP_DISABLED = valueOf(&quot;IP_MULTICAST_LOOP_DISABLED&quot;); //激活或者禁止TCP_NODELAY 套接字选项，决定是否使用Nagle算法 public static final ChannelOption&lt;Boolean&gt; TCP_NODELAY = valueOf(&quot;TCP_NODELAY&quot;); 6、注册对应的网络监听状态位到多路复用器 ChannelFuture f = b.connect(host, port).sync(); 7、由多路复用器在I/O现场中轮询各Channel，处理连接结果8、如果连接成功，设置Future结果，发送连接成功实践，触发ChannelPipeline执行9、由ChannelPipeline调度执行系统和用户的ChannelHandler，执行业务逻辑。其实，这个大体和服务端一致，只是有些细微的区别。]]></content>
      <categories>
        <category>netty</category>
      </categories>
      <tags>
        <tag>netty</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java面试之垃圾回收机制]]></title>
    <url>%2F2017%2F10%2F25%2Fjava%E9%9D%A2%E8%AF%95%E4%B9%8B%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6%2F</url>
    <content type="text"><![CDATA[垃圾回收机制请先去看 http://www.jianshu.com/p/b3eff15b3f72 四种引用状态在JDK1.2之前，Java中引用的定义很传统：如果引用类型的数据中存储的数值代表的是另一块内存的起始地址，就称这块内存代表着一个引用。这种定义很纯粹，但是太过于狭隘，一个对象只有被引用或者没被引用两种状态。我们希望描述这样一类对象：当内存空间还足够时，则能保留在内存中；如果内存空间在进行垃圾收集后还是非常紧张，则可以抛弃这些对象。很多系统的缓存功能都符合这样的应用场景。在JDK1.2之后，Java对引用的概念进行了扩充，将引用分为强引用、软引用、弱引用、虚引用4种，这4种引用强度依次减弱。1、强引用代码中普遍存在的类似”Object obj = new Object()”这类的引用，只要强引用还存在，垃圾收集器永远不会回收掉被引用的对象。2、软引用描述有些还有用但并非必需的对象。在系统将要发生内存溢出异常之前，将会把这些对象列进回收范围进行二次回收。如果这次回收还没有足够的内存，才会抛出内存溢出异常。Java中的类SoftReference表示软引用。3、弱引用描述非必需对象。被弱引用关联的对象只能生存到下一次垃圾回收之前，垃圾收集器工作之后，无论当前内存是否足够，都会回收掉只被弱引用关联的对象。Java中的类WeakReference表示弱引用。4、虚引用这个引用存在的唯一目的就是在这个对象被收集器回收时收到一个系统通知，被虚引用关联的对象，和其生存时间完全没关系。Java中的类PhantomReference表示虚引用。 垃圾回收算法标记-清除（Mark-Sweep）算法这是最基础的算法，标记-清除算法就如同它的名字样，分为“标记”和“清除”两个阶段：首先标记出所有需要回收的对象，标记完成后统一回收所有被标记的对象。这种算法的不足主要体现在效率和空间，从效率的角度讲，标记和清除两个过程的效率都不高；从空间的角度讲，标记清除后会产生大量不连续的内存碎片， 内存碎片太多可能会导致以后程序运行过程中在需要分配较大对象时，无法找到足够的连续内存而不得不提前触发一次垃圾收集动作。标记-清除算法执行过程如图： 复制（Copying）算法复制算法是为了解决效率问题而出现的，它将可用的内存分为两块，每次只用其中一块，当这一块内存用完了，就将还存活着的对象复制到另外一块上面，然后再把已经使用过的内存空间一次性清理掉。这样每次只需要对整个半区进行内存回收，内存分配时也不需要考虑内存碎片等复杂情况，只需要移动指针，按照顺序分配即可。复制算法的执行过程如图：不过这种算法有个缺点，内存缩小为了原来的一半，这样代价太高了。现在的商用虚拟机都采用这种算法来回收新生代，不过研究表明1:1的比例非常不科学，因此新生代的内存被划分为一块较大的Eden空间和两块较小的Survivor空间，每次使用Eden和其中一块Survivor。每次回收时，将Eden和Survivor中还存活着的对象一次性复制到另外一块Survivor空间上，最后清理掉Eden和刚才用过的Survivor空间。HotSpot虚拟机默认Eden区和Survivor区的比例为8:1，意思是每次新生代中可用内存空间为整个新生代容量的90%。当然，我们没有办法保证每次回收都只有不多于10%的对象存活，当Survivor空间不够用时，需要依赖老年代进行分配担保（Handle Promotion）。 标记-整理（Mark-Compact）算法复制算法在对象存活率较高的场景下要进行大量的复制操作，效率很低。万一对象100%存活，那么需要有额外的空间进行分配担保。老年代都是不易被回收的对象，对象存活率高，因此一般不能直接选用复制算法。根据老年代的特点，有人提出了另外一种标记-整理算法，过程与标记-清除算法一样，不过不是直接对可回收对象进行清理，而是让所有存活对象都向一端移动，然后直接清理掉边界以外的内存。标记-整理算法的工作过程如图： 分代收集算法根据上面的内容，用一张图概括一下堆内存的布局 现代商用虚拟机基本都采用分代收集算法来进行垃圾回收。这种算法没什么特别的，无非是上面内容的结合罢了，根据对象的生命周期的不同将内存划分为几块，然后根据各块的特点采用最适当的收集算法。大批对象死去、少量对象存活的（新生代），使用复制算法，复制成本低；对象存活率高、没有额外空间进行分配担保的（老年代），采用标记-清理算法或者标记-整理算法。 垃圾收集器垃圾收集器就是上面讲的理论知识的具体实现了。不同虚拟机所提供的垃圾收集器可能会有很大差别，我们使用的是HotSpot，HotSpot这个虚拟机所包含的所有收集器如图：上图展示了7种作用于不同分代的收集器，如果两个收集器之间存在连线，那说明它们可以搭配使用。虚拟机所处的区域说明它是属于新生代收集器还是老年代收集器。多说一句，我们必须明确一个观点：没有最好的垃圾收集器，更加没有万能的收集器，只能选择对具体应用最合适的收集器。这也是HotSpot为什么要实现这么多收集器的原因。 1、Serial收集器最基本、发展历史最久的收集器，这个收集器是一个采用复制算法的单线程的收集器，单线程一方面意味着它只会使用一个CPU或一条线程去完成垃圾收集工作，另一方面也意味着它进行垃圾收集时必须暂停其他线程的所有工作，直到它收集结束为止。后者意味着，在用户不可见的情况下要把用户正常工作的线程全部停掉，这对很多应用是难以接受的。不过实际上到目前为止，Serial收集器依然是虚拟机运行在Client模式下的默认新生代收集器，因为它简单而高效。用户桌面应用场景中，分配给虚拟机管理的内存一般来说不会很大，收集几十兆甚至一两百兆的新生代停顿时间在几十毫秒最多一百毫秒，只要不是频繁发生，这点停顿是完全可以接受的。Serial收集器运行过程如下图所示： 说明：1. 需要STW（Stop The World），停顿时间长。2. 简单高效，对于单个CPU环境而言，Serial收集器由于没有线程交互开销，可以获取最高的单线程收集效率。 2、ParNew收集器ParNew收集器其实就是Serial收集器的多线程版本，除了使用多条线程进行垃圾收集外，其余行为和Serial收集器完全一样，包括使用的也是复制算法。ParNew收集器除了多线程以外和Serial收集器并没有太多创新的地方，但是它却是Server模式下的虚拟机首选的新生代收集器，其中有一个很重要的和性能无关的原因是，除了Serial收集器外，目前只有它能与CMS收集器配合工作（看图）。CMS收集器是一款几乎可以认为有划时代意义的垃圾收集器，因为它第一次实现了让垃圾收集线程与用户线程基本上同时工作。ParNew收集器在单CPU的环境中绝对不会有比Serial收集器更好的效果，甚至由于线程交互的开销，该收集器在两个CPU的环境中都不能百分之百保证可以超越Serial收集器。当然，随着可用CPU数量的增加，它对于GC时系统资源的有效利用还是很有好处的。它默认开启的收集线程数与CPU数量相同，在CPU数量非常多的情况下，可以使用-XX:ParallelGCThreads参数来限制垃圾收集的线程数。ParNew收集器运行过程如下图所示： 3、Parallel Scavenge收集器Parallel Scavenge收集器也是一个新生代收集器，也是用复制算法的收集器，也是并行的多线程收集器，但是它的特点是它的关注点和其他收集器不同。介绍这个收集器主要还是介绍吞吐量的概念。CMS等收集器的关注点是尽可能缩短垃圾收集时用户线程的停顿时间，而Parallel Scavenge收集器的目标则是打到一个可控制的吞吐量。所谓吞吐量的意思就是CPU用于运行用户代码时间与CPU总消耗时间的比值，即吞吐量=运行用户代码时间/（运行用户代码时间+垃圾收集时间），虚拟机总运行100分钟，垃圾收集1分钟，那吞吐量就是99%。另外，Parallel Scavenge收集器是虚拟机运行在Server模式下的默认垃圾收集器。 停顿时间短适合需要与用户交互的程序，良好的响应速度能提升用户体验；高吞吐量则可以高效率利用CPU时间，尽快完成运算任务，主要适合在后台运算而不需要太多交互的任务。 虚拟机提供了-XX:MaxGCPauseMillis和-XX:GCTimeRatio两个参数来精确控制最大垃圾收集停顿时间和吞吐量大小。不过不要以为前者越小越好，GC停顿时间的缩短是以牺牲吞吐量和新生代空间换取的。由于与吞吐量关系密切，Parallel Scavenge收集器也被称为“吞吐量优先收集器”。Parallel Scavenge收集器有一个-XX:+UseAdaptiveSizePolicy参数，这是一个开关参数，这个参数打开之后，就不需要手动指定新生代大小、Eden区和Survivor参数等细节参数了，虚拟机会根据当前系统的运行情况手机性能监控信息，动态调整这些参数以提供最合适的停顿时间或者最大的吞吐量。如果对于垃圾收集器运作原理不太了解，以至于在优化比较困难的时候，使用Parallel Scavenge收集器配合自适应调节策略，把内存管理的调优任务交给虚拟机去完成将是一个不错的选择**。 4、Serial Old收集器Serial收集器的老年代版本，同样是一个单线程收集器，使用“标记-整理算法”，这个收集器的主要意义也是在于给Client模式下的虚拟机使用。 5、Parallel Old收集器Parallel Scavenge收集器的老年代版本，使用多线程和“标记-整理”算法。这个收集器在JDK 1.6之后的出现，“吞吐量优先收集器”终于有了比较名副其实的应用组合，在注重吞吐量以及CPU资源敏感的场合，都可以优先考虑Parallel Scavenge收集器+Parallel Old收集器的组合。运行过程如下图所示： 6、CMS收集器CMS（Conrrurent Mark Sweep）收集器是以获取最短回收停顿时间为目标的收集器。使用标记 - 清除算法，收集过程分为如下四步：(1). 初始标记，标记GCRoots能直接关联到的对象，时间很短。(2). 并发标记，进行GCRoots Tracing（可达性分析）过程，时间很长。(3). 重新标记，修正并发标记期间因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录，时间较长。(4). 并发清除，回收内存空间，时间很长。其中，并发标记与并发清除两个阶段耗时最长，但是可以与用户线程并发执行。运行过程如下图所示:说明：1. 对CPU资源非常敏感，可能会导致应用程序变慢，吞吐率下降。2. 无法处理浮动垃圾，因为在并发清理阶段用户线程还在运行，自然就会产生新的垃圾，而在此次收集中无法收集他们，只能留到下次收集，这部分垃圾为浮动垃圾，同时，由于用户线程并发执行，所以需要预留一部分老年代空间提供并发收集时程序运行使用。3. 由于采用的标记 - 清除算法，会产生大量的内存碎片，不利于大对象的分配，可能会提前触发一次Full GC。虚拟机提供了-XX:+UseCMSCompactAtFullCollection参数来进行碎片的合并整理过程，这样会使得停顿时间变长，虚拟机还提供了一个参数配置，-XX:+CMSFullGCsBeforeCompaction，用于设置执行多少次不压缩的Full GC后，接着来一次带压缩的GC。 7、G1收集器G1是目前技术发展的最前沿成果之一，HotSpot开发团队赋予它的使命是未来可以替换掉JDK1.5中发布的CMS收集器。与其他GC收集器相比，G1收集器有以下特点：(1). 并行和并发。使用多个CPU来缩短Stop The World停顿时间，与用户线程并发执行。(2). 分代收集。独立管理整个堆，但是能够采用不同的方式去处理新创建对象和已经存活了一段时间、熬过多次GC的旧对象，以获取更好的收集效果。(3). 空间整合。基于标记 - 整理算法，无内存碎片产生。(4). 可预测的停顿。能简历可预测的停顿时间模型，能让使用者明确指定在一个长度为M毫秒的时间片段内，消耗在垃圾收集上的时间不得超过N毫秒。 在G1之前的垃圾收集器，收集的范围都是整个新生代或者老年代，而G1不再是这样。使用G1收集器时，Java堆的内存布局与其他收集器有很大差别，它将整个Java堆划分为多个大小相等的独立区域（Region），虽然还保留有新生代和老年代的概念，但新生代和老年代不再是物理隔离的了，它们都是一部分（可以不连续）Region的集合。 GC日志的理解GC LOG 及Collector行为分析LOG分析包含前面文章所介绍的各个GC collector的行为分析。通过加入 -XX:+PrintGCDetails 参数则可以打印详细GC信息至控制台。参数-verbose:gc也是可以，但不够详细。通过加入-XX:+PrintGCDateStamps则可以记录GC发生的详细时间。通过加入 -Xloggc:/home/XX/gc/app_gc.log 可以把GC输出至文件，这对长时间服务器GC监控很有帮助。以下列出一些参数大致打印的信息如下： -verbose:gc： [GC 72104K-&gt;9650K(317952K), 0.0130635 secs] -XX:+PrintGCDetails: [GC [PSYoungGen: 142826K-&gt;10751K(274944K)] 162800K-&gt;54759K(450048K), 0.0609952 secs] [Times: user=0.13 sys=0.02, real=0.06 secs] -XX:+PrintGCDetails 加上-XX:+PrintGCDateStamps 参数则打印如下：2015-12-06T12:32:02.890+0800: [GC [PSYoungGen: 142833K-&gt;10728K(142848K)] 166113K-&gt;59145K(317952K), 0.0792023 secs] [Times: user=0.22 sys=0.00, real=0.08 secs] 可以看出，如果是想监控详细信息与GC发生时间，加上-XX:+PrintGCDateStamps -XX:+PrintGCDetails 参数会是一个比较好的选择。 首先来说明一段在各个GC中通用的字段含义说明：1、142826K-&gt;10751K(274944K) 分别代表回收前、回收后以及总内存大小。2、Times: user=0.46 sys=0.05, real=0.07 secs： user代表GC 需要的各个CPU总时间(各个CPU时间相加)，sys代表回收器自身的行为所占用CPU时间，real则代表本次GC所耗费的真正耗时(在多核CPU中并行回收，它通常小于user) 。 Serial GC (-XX:+UseSerialGC) 下面是一段的Serial GC日志含义依次分解： [GC[DefNew: 78656K-&gt;8704K(78656K), 0.0487492 secs] 135584K-&gt;80553K(253440K), 0.0488309 secs] [Times: user=0.05 sys=0.00, real=0.05 secs] [Full GC[Tenured: 62546K-&gt;60809K(174784K), 0.1600120 secs] 85931K-&gt;60809K(253440K), [Perm : 38404K-&gt;38404K(65536K)], 0.1600814 secs] [Times: user=0.16 sys=0.00, real=0.16 secs] 其中的DefNew代表单线程回收yong generation。 紧跟后面的 78656K-&gt;8704K(78656K) 中的 78656K 代表young generation 回收前大小，8704K 代表回收后大小，括号中的78656K 代表young generation总大小(包含2个survivor)。 135584K-&gt;80553K(253440K) 则代表整个Heap(young+old)的变化与总量，含义参照前面所述(Perm也一样)。 Full GC 即代表 major GC, Tenured: 62546K-&gt;60809K(174784K)则表示 old generation变化及总量 ParallelGC-XX:-UseParallelGC：Use parallel garbage collection for scavenges. (Introduced in 1.4.1)-XX:-UseParallelOldGC：Use parallel garbage collection for the full collections. Enabling this option automatically sets -XX:+UseParallelGC. (Introduced in 5.0 update 6.)[GC [PSYoungGen: 88524K-&gt;10728K(274944K)] 133505K-&gt;61187K(450048K), 0.0374438 secs] [Times: user=0.08 sys=0.00, real=0.04 secs][Full GC [PSYoungGen: 10728K-&gt;0K(274944K)] [ParOldGen: 50459K-&gt;50210K(175104K)] 61187K-&gt;50210K(450048K) [PSPermGen: 38656K-&gt;38643K(77312K)], 0.3787131 secs] [Times: user=0.98 sys=0.02, real=0.38 secs] PSYoungGen 代表并行回收 young generation ParOldGen 代表并行回收 old generation. PSPermGen 代表并行回收 Permanent generation. 其他的参数与前面解释的类似。 CMS GCCMS GC相对来说比较复杂，通过使用 -XX:+UseConcMarkSweepGC 参数在指定，但是一般情况需要更多的其他参数来保证它能比较好地达到我们的低延时目的，下面就部分常用参数做介绍： -XX:+CMSIncrementalMode 采用增量式的标记方式，减少标记时应用停顿时间-XX:+CMSParallelRemarkEnabled 启用并行标记-XX:CMSInitiatingOccupancyFraction=70 Old generation消耗比例达到多少时进行回收，通常配置60-80之间-XX:CMSFullGCsBeforeCompaction=1 多少次Full GC 后压缩old generation一次-XX:+UseCMSInitiatingOccupancyOnly-XX:+ScavengeBeforeFullGC Old generation GC前对young generation GC一次，默认开启。-XX:+CMSScavengeBeforeRemark CMS remark之前进行一次young generation GC GC监控工具1、jstack 可以定位到具体的线程堆栈，定位cpu冲高 结合top实例： j&apos;s 2、jmap查看堆内存使用情况 3、jstat统计堆的使用情况 jstat用于实时监测 GC情况，如PID为7880的应用监测，每 1000毫秒打印一次： jstat -gc 7880 1000S0C S1C S0U S1U EC EU OC OU PC PU YGC YGCT FGC FGCT GCT8704.0 8704.0 8704.0 0.0 69952.0 14761.0 277100.0 181950.8 65536.0 37705.5 60 2.946 35 1.285 4.2318704.0 8704.0 8704.0 0.0 69952.0 14763.0 277100.0 181950.8 65536.0 37705.5 60 2.946 35 1.285 4.231 4、vivalueVM MAT]]></content>
      <categories>
        <category>netty</category>
      </categories>
      <tags>
        <tag>netty</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[netty之服务端创建]]></title>
    <url>%2F2017%2F10%2F24%2Fnetty%E4%B9%8B%E6%9C%8D%E5%8A%A1%E7%AB%AF%E5%88%9B%E5%BB%BA%2F</url>
    <content type="text"><![CDATA[服务端创建的时序图用户可以通过ServerBootstrap可以方便的创建Netty的服务端。 1、创建ServerBootstrap实例ServerBootstrap是Netty服务端的起动辅助类，它提供了一系列方法用于设置服务端的启动相关参数。底层通过门面模式对各种能力进行抽象和封装，尽量不需要用户跟过多的底层API打交道，以降低用户的开发难度。 ServerBootstrap b = new ServerBootstrap(); 创建ServerBootstrap的实例只需要一个无参的构造函数。因为ServerBootstrap需要的参数太多了，这里用了Builder设计模式。（遇到多个构造器参数时要考虑用构建器） 2、设置绑定Reactor线程池。Netty的Reactor线程池是EventLoopGroup，它实际就是EventLoop的数组。EvnetLoop的职责是处理所有注册到本线程多路复用器Selector上的Channel，Selector的轮询操作由绑定的EventLoop线程run方法驱动，在一个循环体内循环执行。EventLoop的职责不仅仅是处理网络I/O事件，用户自定义的Task和定时任务Task也由EventLoop负责处理，这样线程模型就实现了统一。从调度层看，也不存在从EventLoop线程中再启动其他类型的线程用于异步执行另外的任务，这样避免了多线程并发操作和锁竞争，提升了I/O线程的处理和调度性能。 EventLoopGroup bossGruop=new NioEventLoopGroup();//用于服务器端接受客户端的连接 EventLoopGroup workGroup=new NioEventLoopGroup();//用于网络事件的处理 3、设置并绑定服务端Channel作为服务端，需要创建ServerSocketChannel。Netty对原生的NIO进行了封装，对应的实现类是NioServerSocketChannel。 b.group(bossGruop, workGroup).channel(NioServerSocketChannel.class) 4、TCP链路建立的时候创建并初始化ChannelPipelineb.group(bossGroup, workGroup) .channel(NioServerSocketChannel.class) .option(ChannelOption.SO_BACKLOG, 1024) .childHandler(new ChannelInitializer&lt;SocketChannel&gt;(){ @Override protected void initChannel(SocketChannel ch) throws Exception { ChannelPipeline pipeline = ch.pipeline(); } } ChannelPipeline的本质是一个负责处理网络事件的职责链，负责管理和执行ChannelHandler。网络事件以事件流的形式在ChannelPipeline中流转，由ChannelPipeline根据Channel|Handler的执行策略调度ChannelHandler的执行。典型的网络事件有： 链路注册 链路激活 链路断开 接收到请求信息 请求信息接收并处理完毕 发送应答消息 链路发生异常 用户自定义事件 5、添加并设置ChannelHandlerChannelHandler是提供用户定制或扩展的关键接口。利用ChannelHandler可以完成大多数功能定制。比较常用的ChannelHandler有：（1）系统编解码框架—–ByteToMessageCodec（2）通用基于长度的半包解码器—–LengthFieldBasedFrameDecoder（3）码流日志打印—–LoggingHandler（4）SSL安全认证—–SslHander（5）链路空闲检测—–IdleStateHandler（6）流量整形—–ChannelTrafficShapingHandler（7）Base64编解码—–Base64Decoder和Base64Encoder @Override protected void initChannel(SocketChannel ch) throws Exception { ChannelPipeline pipeline = ch.pipeline(); //Msgpack编解码 pipeline.addLast(new MsgpackEncoder()); pipeline.addLast(new MsgpackDecoder()); //自定义EchoServerHandler ch.pipeline().addLast(new EchoServerHandler()); } 6、绑定并启动监听窗口在绑定监听端口之前系统回去做一系列的初始化和检测工作，完成之后，会启动监听端口，并将ServerSocketChannel注册到Selector上监听客户端连接。 ChannelFuture f = b.bind(port).sync(); 7、Selector轮询由Reactor线程NioEventLoop负责调度和执行Selector轮询操作，选择准备就绪的Channel集合。 8、网络事件通知当轮询到准备就绪的Channel之后，就由Reactor线程NioEventLoop执行ChannelPipeline的相应方法，最终调度并执行ChannelHandler。 9、执行Netty系统和业务HandlerChannel()public class EchoServerHandler extends ChannelInboundHandlerAdapter{} 示例代码Netty服务器端HelloServer： import io.netty.bootstrap.ServerBootstrap; import io.netty.channel.ChannelFuture; import io.netty.channel.ChannelInitializer; import io.netty.channel.ChannelOption; import io.netty.channel.EventLoopGroup; import io.netty.channel.nio.NioEventLoopGroup; import io.netty.channel.socket.SocketChannel; import io.netty.channel.socket.nio.NioServerSocketChannel; //Netty服务器端 public class HelloServer { private int port; public HelloServer(int port) { super(); this.port = port; } private void bind() throws InterruptedException { EventLoopGroup bossGruop=new NioEventLoopGroup();//用于服务器端接受客户端的连接 EventLoopGroup workGroup=new NioEventLoopGroup();//用于网络事件的处理 try { ServerBootstrap b=new ServerBootstrap(); b.group(bossGruop, workGroup).channel(NioServerSocketChannel.class).childHandler(new ChannelInitializer&lt;SocketChannel&gt;() { @Override protected void initChannel(SocketChannel arg0) throws Exception { arg0.pipeline().addLast(new HelloServerHandler()); } }).option(ChannelOption.SO_BACKLOG, 1024);//指定此套接口排队的最大连接个数 ChannelFuture f=b.bind(port).sync(); f.channel().closeFuture().sync(); } finally { bossGruop.shutdownGracefully(); workGroup.shutdownGracefully(); } } public static void main(String[] args) throws InterruptedException { new HelloServer(8080).bind(); } } 自定义的ChannelHandler： import io.netty.buffer.ByteBuf; import io.netty.channel.ChannelHandlerAdapter; import io.netty.channel.ChannelHandlerContext; //自定义的ChannelHandler public class HelloServerHandler extends ChannelHandlerAdapter { @Override public void channelActive(ChannelHandlerContext ctx) throws Exception { System.out.println(&quot;客户端连上了...&quot;); } @Override public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception { ByteBuf buf=(ByteBuf) msg; byte[] req=new byte[buf.readableBytes()]; buf.readBytes(req); System.out.println(&quot;服务器端接收的消息：&quot;+new String(req)); } @Override public void channelReadComplete(ChannelHandlerContext ctx) throws Exception { ctx.flush(); } @Override public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception { ctx.close(); } } 然后启动HelloServer。在telnet中连接localhost 8080输入字符串，会在控制台显示]]></content>
      <categories>
        <category>netty</category>
      </categories>
      <tags>
        <tag>netty</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java面试之类加载机制和双亲委派]]></title>
    <url>%2F2017%2F10%2F24%2Fjava%E9%9D%A2%E8%AF%95%E4%B9%8B%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6%E5%92%8C%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%2F</url>
    <content type="text"><![CDATA[什么是类的加载类的加载指的是将类的.class文件中的二进制数据读入到内存中，将其放在运行时数据区的方法区内，然后在堆区创建一个java.lang.Class对象，用来封装类在方法区内的数据结构。类的加载的最终产品是位于堆区中的Class对象，Class对象封装了类在方法区内的数据结构，并且向Java程序员提供了访问方法区内的数据结构的接口。 类的生命周期其种类的加载过程包括加载，验证，准备，解析，初始化五个阶段。在这五个阶段中，加载，验证，准备，初始化的顺序是固定的，而解析阶段则不一定，它在某些情况下可以在初始化阶段之后工作，这是为了支持java的运行时绑定（动态绑定）。这里的几个阶段是按顺序开始的，而不是按顺序进行或者完成，因为这些阶段通常交叉进行的。 加载查找并加载类的二进制数据，在这个阶段，虚拟机需要完成以下三件事情： 通过一个类的全限定名来获取其定义的二进制字节流 将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构 在Java堆中生成一个代表这个类的java.lang.Class对象作为对方法区中这些数据的访问入口相对于类加载的其他阶段而言，加载阶段是可控性最强的阶段，因为程序猿既可以使用系统提供的类加载器来完成加载，也可以自定义自己的类加载器加载。双亲委派机制①加载完成之后，虚拟机外部的二进制字节流就按照虚拟机所需的格式存储在方法区中，而在堆中也创建一个java.lang.Class对象，这样可以通过该对象访问方法区中的这些数据。验证验证是连接的第一步，这一阶段是为了确保Class文件的字节流包含的信息符合当前虚拟机的要求，冰球不会危害虚拟机自身的安全。验证阶段大致完成4个检验动作： 文件格式验证：验证字节流是否符合Class文件格式的规范。 元数据验证：对字节码描述的信息进行语义分析，以保证其描述的信息符合java语言规范的要求。 字节码验证：通过数据流和控制流的分析，确定程序语义是合法的、符合逻辑的。 符号引用验证：确保解析动作能正确执行。验证阶段非常重要，但不是必须的，这个对程序运行期没有影响。如果所应用的类经过反复验证，可以考虑采用-Xverifynone参数来关闭大部分的类验证措施，以缩短虚拟机类加载时间。 准备准备阶段是正式为类变量分配内存并设置泪变量初始值的阶段，这些内存都将在方法区中分配。选哟注意以下几点：1、这个阶段的内存分配仅仅是static变量，而不是实例变量。实例变量会在对象实例化的时候随着对象一起分配在java队中。2、这里所设置的初始值通常情况下是数据默认值，而不是java代码中所显式设置的值。 int a = 1;//这个阶段a的初始值就是0，而不是1另外还需注意下面几点： 对基本数据类型来说，对于类变量（static）和全局变量，如果不显式地对其赋值而直接使用，则系统会为其赋予默认的零值，而对于局部变量来说，在使用前必须显式地为其赋值，否则编译时不通过。 对于同时被static和final修饰的常量，必须在声明的时候就为其显式地赋值，否则编译时不通过；而只被final修饰的常量则既可以在声明时显式地为其赋值，也可以在类初始化时显式地为其赋值，总之，在使用前必须为其显式地赋值，系统不会为其赋予默认零值。 对于引用数据类型reference来说，如数组引用、对象引用等，如果没有对其进行显式地赋值而直接使用，系统都会为其赋予默认的零值，即null。 如果在数组初始化时没有对数组中的各元素赋值，那么其中的元素将根据对应的数据类型而被赋予默认的值3、也就是第二点中，如果一个属性同时被final和static修饰，准备阶段就会初始化为指定的值并放入常量池。解析解析阶段是虚拟机将常量池中的符号引用转换为直接引用的过程，解析动作主要针对类或者接口、字段、类方法、接口方法、方法类型、方法句柄、调用点限定符7类符号引用进行。符号引用就是一组符号来描述目标，可以是任何字符。初始化为类的静态变量赋予正确的初始值，JVM负责对类进行初始化，主要对类变量进行初始化。在Java中对类变量进行初始值设定有两种方式：①声明类变量是指定初始值②使用静态代码块为类变量指定初始值JVM初始化步骤：1、假如这个类还没有被加载和连接，则程序先加载并连接该类2、假如该类的直接父类还没有被初始化，则先初始化其直接父类3、假如类中有初始化语句，则系统依次执行这些初始化语句类初始化时机：只有当对类的主动使用的时候才会导致类的初始化，类的主动使用包括以下六种： 创建类的实例，也就是new的方式 访问某个类或接口的静态变量，或者对该静态变量赋值 调用类的静态方法 反射（如Class.forName(“com.shengsiyuan.Test”)） 初始化某个类的子类，则其父类也会被初始化 Java虚拟机启动时被标明为启动类的类（Java Test），直接使用java.exe命令来运行某个主类结束生命周期在如下几种情况下，Java虚拟机将结束生命周期 执行了System.exit()方法 程序正常执行结束 程序在执行过程中遇到了异常或错误而异常终止 由于操作系统出现错误而导致Java虚拟机进程终止 类加载器 public class Test { public static void main(String[] args) { ClassLoader classLoader = Thread.currentThread().getContextClassLoader(); System.out.println(classLoader); System.out.println(classLoader.getParent()); System.out.println(classLoader.getParent().getParent()); } } 结果： sun.misc.Launcher$AppClassLoader@7d4991ad sun.misc.Launcher$ExtClassLoader@677327b6 null最后的null是由于Bootstrap Loader（引导类加载器）是用C语言实现的，找不到一个确定的返回父Loader的方式，于是就返回null。通过一个图看类加载器： 注意：这里父类加载器并不是通过继承关系来实现的，而是采用组合实现的。站在Java虚拟机的角度来讲，只存在两种不同的类加载器：启动类加载器：它使用C++实现（这里仅限于Hotspot，也就是JDK1.5之后默认的虚拟机，有很多其他的虚拟机是用Java语言实现的），是虚拟机自身的一部分；所有其他的类加载器：这些类加载器都由Java语言实现，独立于虚拟机之外，并且全部继承自抽象类java.lang.ClassLoader，这些类加载器需要由启动类加载器加载到内存中之后才能去加载其他的类。 站在Java开发人员的角度来看，类加载器可以大致划分为以下三类： 启动类加载器：Bootstrap ClassLoader，负责加载存放在JDK\jre\lib(JDK代表JDK的安装目录，下同)下，或被-Xbootclasspath参数指定的路径中的，并且能被虚拟机识别的类库（如rt.jar，所有的java.开头的类均被Bootstrap ClassLoader加载）。启动类加载器是无法被Java程序直接引用的。扩展类加载器：Extension ClassLoader，该加载器由sun.misc.Launcher$ExtClassLoader实现，它负责加载DK\jre\lib\ext目录中，或者由java.ext.dirs系统变量指定的路径中的所有类库（如javax.开头的类），开发者可以直接使用扩展类加载器。应用程序类加载器：Application ClassLoader，该类加载器由sun.misc.Launcher$AppClassLoader来实现，它负责加载用户类路径（ClassPath）所指定的类，开发者可以直接使用该类加载器，如果应用程序中没有自定义过自己的类加载器，一般情况下这个就是程序中默认的类加载器。 应用程序都是由这三种类加载器互相配合进行加载的，如果有必要，我们还可以加入自定义的类加载器。因为JVM自带的ClassLoader只是懂得从本地文件系统加载标准的java class文件，因此如果编写了自己的ClassLoader，便可以做到如下几点： 1）在执行非置信代码之前，自动验证数字签名。2）动态地创建符合用户特定需要的定制化构建类。3）从特定的场所取得java class，例如数据库中和网络中。 JVM类加载机制全盘负责，当一个类加载器负责加载某个Class时，该Class所依赖的和引用的其他Class也将由该类加载器负责载入，除非显示使用另外一个类加载器来载入父类委托，先让父类加载器试图加载该类，只有在父类加载器无法加载该类时才尝试从自己的类路径中加载该类缓存机制，缓存机制将会保证所有加载过的Class都会被缓存，当程序中需要使用某个Class时，类加载器先从缓存区寻找该Class，只有缓存区不存在，系统才会读取该类对应的二进制数据，并将其转换成Class对象，存入缓存区。这就是为什么修改了Class后，必须重启JVM，程序的修改才会生效 类加载有三种方式：1、命令行启动应用时候由JVM初始化加载2、通过Class.forName()方法动态加载3、通过ClassLoader.loadClass()方法动态加载 Class.forName()和ClassLoader.loadClass()区别Class.forName()：将类的.class文件加载到jvm中之外，还会对类进行解释，执行类中的static块；ClassLoader.loadClass()：只干一件事情，就是将.class文件加载到jvm中，不会执行static中的内容,只有在newInstance才会去执行static块。注：Class.forName(name, initialize, loader)带参函数也可控制是否加载static块。并且只有调用了newInstance()方法采用调用构造函数，创建类的对象 。 双亲委派模型双亲委派模型的工作流程是：如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把请求委托给父加载器去完成，依次向上，因此，所有的类加载请求最终都应该被传递到顶层的启动类加载器中，只有当父加载器在它的搜索范围中没有找到所需的类时，即无法完成该加载，子加载器才会尝试自己去加载该类。双亲委派机制:1、当AppClassLoader加载一个class时，它首先不会自己去尝试加载这个类，而是把类加载请求委派给父类加载器ExtClassLoader去完成。2、当ExtClassLoader加载一个class时，它首先也不会自己去尝试加载这个类，而是把类加载请求委派给BootStrapClassLoader去完成。3、如果BootStrapClassLoader加载失败（例如在$JAVA_HOME/jre/lib里未查找到该class），会使用ExtClassLoader来尝试加载；4、若ExtClassLoader也加载失败，则会使用AppClassLoader来加载，如果AppClassLoader也加载失败，则会报出异常ClassNotFoundException。ClassLoader源码分析： public Class&lt;?&gt; loadClass(String name)throws ClassNotFoundException { return loadClass(name, false); } protected synchronized Class&lt;?&gt; loadClass(String name, boolean resolve)throws ClassNotFoundException { // 首先判断该类型是否已经被加载 Class c = findLoadedClass(name); if (c == null) { //如果没有被加载，就委托给父类加载或者委派给启动类加载器加载 try { if (parent != null) { //如果存在父类加载器，就委派给父类加载器加载 c = parent.loadClass(name, false); } else { //如果不存在父类加载器，就检查是否是由启动类加载器加载的类，通过调用本地方法native Class findBootstrapClass(String name) c = findBootstrapClass0(name); } } catch (ClassNotFoundException e) { // 如果父类加载器和启动类加载器都不能完成加载任务，才调用自身的加载功能 c = findClass(name); } } if (resolve) { resolveClass(c); } return c; } 双亲委派模型意义： 系统类防止内存中出现多份同样的字节码 保证Java程序安全稳定运行]]></content>
      <categories>
        <category>面试</category>
      </categories>
      <tags>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[netty之私有栈]]></title>
    <url>%2F2017%2F10%2F23%2Fnetty%E4%B9%8B%E7%A7%81%E6%9C%89%E6%A0%88%2F</url>
    <content type="text"><![CDATA[协议栈功能设计Netty协议栈用于内部各模块间的通信，基于TCP/IP协议栈。 协议栈功能描述 基于Netty的NIO通信框架，提供高性能的异步通信能力 提供消息的编解码框架，可以实现POJO的序列化和反序列化 提供基于IP地址的白名单接入认证机制 链路的有效校验机制 链路的断连机制通信模型 （1） Netty协议栈客户端发送握手请求消息，携带节点ID等有效身份认证信息（2） Netty协议栈服务端对握手请求消息进行合法性验证。校验通过后，返回登陆成功的应答信息。（3） 链路建立成功之后，客户端发送业务消息。（4） 链路成功之后，服务端发送心跳消息。（5） 链路成功之后，客户端发送心跳消息。（6） 链路建立成功之后，服务端发送业务消息。（7） 服务端退出时，服务器关闭连接，客户端感知对方关闭，被动关闭客户端。注意：Netty协议通信双方链路建立成功之后，双发可以进行全双工通信，无论是客户端还是服务端，都可以主动发送消息给对方。双方之间的心跳采用Ping-Pong机制，当链路空闲时，客户端主动发送ping消息给服务端，服务端收到后发送Pong返回给客户端，如果客户端连续发送N条ping消息都没有收到服务端返回的pong消息，说明链路已经挂死或者对方处于异常，客户端应主动关闭连接，间隔周期T后发起重连操作，直到重连成功。 消息的定义Netty协议栈消息定义包含了两部分：消息头和消息体 Netty协议支持的字段类型java所有的基本类型还有String，map，set，array，list Netty协议的编解码使用同一的编解码类型 链路的建立Netty协议栈是支持服务端和客户端的，但是对于使用Netty协议栈的应用程序中，不需要刻意的去区别服务端和客户端。在分布式组网环境中，一个节点可能是服务端，也可能是客户端。Netty协议栈对客户端的说明如下，如果A节点需要调用B节点的服务，而A节点和B节点还没有建立物理链路，则由调用方主动发起连接。调用方称为客户端，被调用方称为服务端。注意链路建立的安全机制 链路的关闭由于采用长连接通信，在正常业务运行期间，双方通过心跳和业务消息维护链路，任何一方不需要主动关闭连接。在以下情况下，需要客户端和服务端关闭连接。 当双方关机或者重启时，会主动关闭链路，另一方读取到操作系统的通知信号，得知双方的REST链路，需要关闭连接，释放自身的 句柄等资源。由于采用TCP全双工通信，通信双方都需要关闭连接，释放资源。 消息读写过程中，发生了I/0异常，需要主动关闭连接 心跳超时，需要主动关闭连接 发生编码异常等不可恢复错误时，需要主动关闭连接可靠性设计1、心跳机制（1）当网络处于空闲状态达到T时，客户端主动发送Ping心跳消息给服务端。（2）如果在下一个周期T到来时客户端没有收到对方发送的Pong心跳应答消息或者读取到服务端发送的其他业务消息，则心跳失败计数器加1（3）每当客户端接收到服务的业务消息或者Pong应答消息，将心跳失败计数器清零；（4）服务端网络空闲状态时间达到T后，服务端将心跳失败计数器加1；只要连接到客户端发送的Ping消息或者其他业务消息，计数器清零；（5）服务端连续N次没有接收到客户端的Ping消息或者其他业务消息，则关闭链路，释放资源，等待客户端重连。2、重连机制要注意的只有一点，不是失败后立即重连，需要确保句柄资源释放，如果重连失败，必须打印异常堆栈信息。3、重复登录保护在缓存地址表中查看客户端死否已经登录，如果已经登录，则拒绝重复登录。如果客户有ID，看此客户ID是否登录。以上两个如果有一个验证未通过，返回-1安全设计IP白名单验证实例代码参考 http://www.cnblogs.com/carl10086/p/6195568.html]]></content>
      <categories>
        <category>netty</category>
      </categories>
      <tags>
        <tag>netty</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[netty之WebSocket]]></title>
    <url>%2F2017%2F10%2F19%2Fnetty%E4%B9%8BWebSocket%2F</url>
    <content type="text"><![CDATA[Http的弊端HTTP的生命周期通过Request来界定，也就是一个Request 一个Response。那么在HTTP1.0中，这次HTTP请求就结束了。在HTTP1.1中进行了改进，使得有一个keep-alive，也就是说，在一个HTTP连接中，可以发送多个Request，接收多个Response。但是请记住 Request 和 Response ， 在HTTP中永远是这样，也就是说一个request只能有一个response。而且这个response也是被动的，不能主动发起。 ajax轮询其实ajax轮询就是在js上加上一个定时器 window.setInterval(function(){$.ajax(getting)},1000);//1秒执行一次 由于ajax轮询采用的是http协议，而http协议是无状态的，每次轮询都需要去建立连接，然后去判断。浪费带宽和服务器资源。 长连接获取资源，没有获取到资源就不断开。在无消息的情况下不会频繁的请求，耗费资源小。但是服务器hold连接会消耗资源，返回数据顺序无保证，难于管理维护。 Websocket传统HTTP客户端与服务器请求响应模式如下图所示： WebSocket模式客户端与服务器请求响应模式如下图： 上图对比可以看出，相对于传统HTTP每次请求-应答都需要客户端与服务端建立连接的模式，WebSocket是类似Socket的TCP长连接通讯模式。 一旦WebSocket连接建立后，后续数据都以帧序列的形式传输。在客户端断开WebSocket连接或Server端中断连接前，不需要客户端和服务端重新发起连接请求。在海量并发及客户端与服务器交互负载流量大的情况下，极大的节省了网络带宽资源的消耗，有明显的性能优势，且客户端发送和接受消息是在同一个持久连接上发起，实时性优势明显。 相比HTTP长连接，WebSocket有以下特点： 是真正的全双工方式，建立连接后客户端与服务器端是完全平等的，可以互相主动请求。而HTTP长连接基于HTTP，是传统的客户端对服务器发起请求的模式。 HTTP长连接中，每次数据交换除了真正的数据部分外，服务器和客户端还要大量交换HTTP header，信息交换效率很低。Websocket协议通过第一个request建立了TCP连接之后，之后交换的数据都不需要发送 HTTP header就能交换数据，这显然和原有的HTTP协议有区别所以它需要对服务器和客户端都进行升级才能实现（主流浏览器都已支持HTML5）。此外还有 multiplexing、不同的URL可以复用同一个WebSocket连接等功能。这些都是HTTP长连接不能做到的。 下面再通过客户端和服务端交互的报文对比WebSocket通讯与传统HTTP的不同点：在客户端，new WebSocket实例化一个新的WebSocket客户端对象，请求类似 ws://yourdomain:port/path 的服务端WebSocket URL，客户端WebSocket对象会自动解析并识别为WebSocket请求，并连接服务端端口，执行双方握手过程，客户端发送数据格式类似： GET /webfin/websocket/ HTTP/1.1 Host: localhost Upgrade: websocket Connection: Upgrade Sec-WebSocket-Key: xqBt3ImNzJbYqRINxEFlkg== Origin: http://localhost:8080 Sec-WebSocket-Version: 13 可以看到，客户端发起的WebSocket连接报文类似传统HTTP报文，Upgrade：websocket参数值表明这是WebSocket类型请求，Sec-WebSocket-Key是WebSocket客户端发送的一个 base64编码的密文，要求服务端必须返回一个对应加密的Sec-WebSocket-Accept应答，否则客户端会抛出Error during WebSocket handshake错误，并关闭连接。 服务端收到报文后返回的数据格式类似： HTTP/1.1 101 Switching ProtocolsUpgrade: websocketConnection: UpgradeSec-WebSocket-Accept: K7DJLdLooIwIG/MOpvWFB3y3FE8= Sec-WebSocket-Accept的值是服务端采用与客户端一致的密钥计算出来后返回客户端的，HTTP/1.1 101 Switching Protocols表示服务端接受WebSocket协议的客户端连接，经过这样的请求-响应处理后，两端的WebSocket连接握手成功, 后续就可以进行TCP通讯了。用户可以查阅WebSocket协议栈了解WebSocket客户端和服务端更详细的交互数据格式。在开发方面，WebSocket API 也十分简单：只需要实例化 WebSocket，创建连接，然后服务端和客户端就可以相互发送和响应消息。在WebSocket 实现及案例分析部分可以看到详细的 WebSocket API 及代码实现。 Websocket其实是一个新协议，跟HTTP协议基本没有关系，只是为了兼容现有浏览器的握手规范而已，也就是说它是HTTP协议上的一种补充可以通过这样一张图理解有交集，但是并不是全部。另外Html5是指的一系列新的API，或者说新规范，新技术。Http协议本身只有1.0和1.1，而且跟Html本身没有直接关系。 WebSocket特点总结 单一的TCP连接，采用全双工模式通信 对代理，防火墙和路由器透明 无头部信息，Cookie和身份验证 无安全开销 通过“ping/pong”帧保持链路激活 度武器可以主动传递消息给客户端用Netty实现WebSocketWebSocketServer import io.netty.bootstrap.ServerBootstrap; import io.netty.channel.Channel; import io.netty.channel.ChannelInitializer; import io.netty.channel.ChannelPipeline; import io.netty.channel.EventLoopGroup; import io.netty.channel.nio.NioEventLoopGroup; import io.netty.channel.socket.SocketChannel; import io.netty.channel.socket.nio.NioServerSocketChannel; import io.netty.handler.codec.http.HttpObjectAggregator; import io.netty.handler.codec.http.HttpServerCodec; import io.netty.handler.stream.ChunkedWriteHandler; public class WebSocketServer { public void run(int port) throws Exception { EventLoopGroup bossGroup = new NioEventLoopGroup(); EventLoopGroup workerGroup = new NioEventLoopGroup(); try { ServerBootstrap b = new ServerBootstrap(); b.group(bossGroup, workerGroup) .channel(NioServerSocketChannel.class) .childHandler(new ChannelInitializer&lt;SocketChannel&gt;() { @Override protected void initChannel(SocketChannel ch) throws Exception { ChannelPipeline pipeline = ch.pipeline(); pipeline.addLast(&quot;http-codec&quot;, new HttpServerCodec()); pipeline.addLast(&quot;aggregator&quot;, new HttpObjectAggregator(65536)); ch.pipeline().addLast(&quot;http-chunked&quot;, new ChunkedWriteHandler()); pipeline.addLast(&quot;handler&quot;, new WebSocketServerHandler()); } }); Channel ch = b.bind(port).sync().channel(); System.out.println(&quot;Web socket server started at port &quot; + port + &apos;.&apos;); System.out .println(&quot;Open your browser and navigate to http://localhost:&quot; + port + &apos;/&apos;); ch.closeFuture().sync(); } finally { bossGroup.shutdownGracefully(); workerGroup.shutdownGracefully(); } } public static void main(String[] args) throws Exception { int port = 8080; if (args.length &gt; 0) { try { port = Integer.parseInt(args[0]); } catch (NumberFormatException e) { e.printStackTrace(); } } new WebSocketServer().run(port); } } WebSocketServerHandler import io.netty.buffer.ByteBuf; import io.netty.buffer.Unpooled; import io.netty.channel.ChannelFuture; import io.netty.channel.ChannelFutureListener; import io.netty.channel.ChannelHandlerContext; import io.netty.channel.SimpleChannelInboundHandler; import io.netty.handler.codec.http.DefaultFullHttpResponse; import io.netty.handler.codec.http.FullHttpRequest; import io.netty.handler.codec.http.FullHttpResponse; import io.netty.handler.codec.http.websocketx.*; import io.netty.util.CharsetUtil; import java.util.logging.Level; import java.util.logging.Logger; import static io.netty.handler.codec.http.HttpHeaderUtil.setContentLength; import static io.netty.handler.codec.http.HttpHeaderUtil.isKeepAlive; import static io.netty.handler.codec.http.HttpResponseStatus.BAD_REQUEST; import static io.netty.handler.codec.http.HttpVersion.HTTP_1_1; public class WebSocketServerHandler extends SimpleChannelInboundHandler&lt;Object&gt; { private static final Logger logger = Logger .getLogger(WebSocketServerHandler.class.getName()); private WebSocketServerHandshaker handshaker; @Override public void messageReceived(ChannelHandlerContext ctx, Object msg) throws Exception { // 传统的HTTP接入 if (msg instanceof FullHttpRequest) { handleHttpRequest(ctx, (FullHttpRequest) msg); } // WebSocket接入 else if (msg instanceof WebSocketFrame) { handleWebSocketFrame(ctx, (WebSocketFrame) msg); } } @Override public void channelReadComplete(ChannelHandlerContext ctx) throws Exception { ctx.flush(); } private void handleHttpRequest(ChannelHandlerContext ctx, FullHttpRequest req) throws Exception { // 如果HTTP解码失败，返回HHTP异常 if (!req.decoderResult().isSuccess() || (!&quot;websocket&quot;.equals(req.headers().get(&quot;Upgrade&quot;)))) { sendHttpResponse(ctx, req, new DefaultFullHttpResponse(HTTP_1_1, BAD_REQUEST)); return; } // 构造握手响应返回，本机测试 WebSocketServerHandshakerFactory wsFactory = new WebSocketServerHandshakerFactory( &quot;ws://localhost:8080/websocket&quot;, null, false); handshaker = wsFactory.newHandshaker(req); if (handshaker == null) { WebSocketServerHandshakerFactory.sendUnsupportedVersionResponse(ctx.channel()); } else { handshaker.handshake(ctx.channel(), req); } } private void handleWebSocketFrame(ChannelHandlerContext ctx, WebSocketFrame frame) { // 判断是否是关闭链路的指令 if (frame instanceof CloseWebSocketFrame) { handshaker.close(ctx.channel(), (CloseWebSocketFrame) frame.retain()); return; } // 判断是否是Ping消息 if (frame instanceof PingWebSocketFrame) { ctx.channel().write( new PongWebSocketFrame(frame.content().retain())); return; } // 本例程仅支持文本消息，不支持二进制消息 if (!(frame instanceof TextWebSocketFrame)) { throw new UnsupportedOperationException(String.format( &quot;%s frame types not supported&quot;, frame.getClass().getName())); } // 返回应答消息 String request = ((TextWebSocketFrame) frame).text(); if (logger.isLoggable(Level.FINE)) { logger.fine(String.format(&quot;%s received %s&quot;, ctx.channel(), request)); } ctx.channel().write( new TextWebSocketFrame(request + &quot; , 欢迎使用Netty WebSocket服务，现在时刻：&quot; + new java.util.Date().toString())); } private static void sendHttpResponse(ChannelHandlerContext ctx, FullHttpRequest req, FullHttpResponse res) { // 返回应答给客户端 if (res.status().code() != 200) { ByteBuf buf = Unpooled.copiedBuffer(res.status().toString(), CharsetUtil.UTF_8); res.content().writeBytes(buf); buf.release(); setContentLength(res, res.content().readableBytes()); } // 如果是非Keep-Alive，关闭连接 ChannelFuture f = ctx.channel().writeAndFlush(res); if (!isKeepAlive(req) || res.status().code() != 200) { f.addListener(ChannelFutureListener.CLOSE); } } @Override public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception { cause.printStackTrace(); ctx.close(); } } 然后启动WebSocketServer，控制台会出现下面地址：但是这个地址是无效的 最后给个html显示 &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; Netty WebSocket 时间服务器 &lt;/head&gt; &lt;br&gt; &lt;body&gt; &lt;br&gt; &lt;script type=&quot;text/javascript&quot;&gt; var socket; if (!window.WebSocket) { window.WebSocket = window.MozWebSocket; } if (window.WebSocket) { socket = new WebSocket(&quot;ws://localhost:8080/websocket&quot;); socket.onmessage = function(event) { var ta = document.getElementById(&apos;responseText&apos;); ta.value=&quot;&quot;; ta.value = event.data }; socket.onopen = function(event) { var ta = document.getElementById(&apos;responseText&apos;); ta.value = &quot;打开WebSocket服务正常，浏览器支持WebSocket!&quot;; }; socket.onclose = function(event) { var ta = document.getElementById(&apos;responseText&apos;); ta.value = &quot;&quot;; ta.value = &quot;WebSocket 关闭!&quot;; }; } else { alert(&quot;抱歉，您的浏览器不支持WebSocket协议!&quot;); } function send(message) { if (!window.WebSocket) { return; } if (socket.readyState == WebSocket.OPEN) { socket.send(message); } else { alert(&quot;WebSocket连接没有建立成功!&quot;); } } &lt;/script&gt; &lt;form onsubmit=&quot;return false;&quot;&gt; &lt;input type=&quot;text&quot; name=&quot;message&quot; value=&quot;Netty最佳实践&quot;/&gt; &lt;br&gt;&lt;br&gt; &lt;input type=&quot;button&quot; value=&quot;发送WebSocket请求消息&quot; onclick=&quot;send(this.form.message.value)&quot;/&gt; &lt;hr color=&quot;blue&quot;/&gt; &lt;h3&gt;服务端返回的应答消息&lt;/h3&gt; &lt;textarea id=&quot;responseText&quot; style=&quot;width:500px;height:300px;&quot;&gt;&lt;/textarea&gt; &lt;/form&gt; &lt;/body&gt; &lt;/html&gt; 运行这个html，会显示 这个时间是后台返回回来的。到此这个WebSocket也搭建完成。]]></content>
      <categories>
        <category>netty</category>
      </categories>
      <tags>
        <tag>netty</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Netty之Http协议]]></title>
    <url>%2F2017%2F10%2F18%2Fnetty%E4%B9%8BHttp%E5%8D%8F%E8%AE%AE%2F</url>
    <content type="text"><![CDATA[什么是HTTPHTTP是一个属于应用层的面向对象的协议，由于其简捷、快速的方式，适用于分布式超媒体信息系统。 HTTP协议的主要特点 支持客户/服务器模式。 简单快速：客户向服务器请求服务时，只需传送请求方法和路径。请求方法常用的有GET、HEAD、POST。每种方法规定了客户与服务器联系的类型不同。由于HTTP协议简单，使得HTTP服务器的程序规模小，因而通信速度很快。 灵活：HTTP允许传输任意类型的数据对象。正在传输的类型由Content-Type加以标记。 无连接：无连接的含义是限制每次连接只处理一个请求。服务器处理完客户的请求，并收到客户的应答后，即断开连接。采用这种方式可以节省传输时间。 无状态：HTTP协议是无状态协议。无状态是指协议对于事务处理没有记忆能力。缺少状态意味着如果后续处理需要前面的信息，则它必须重传，这样可能导致每次连接传送的数据量增大。另一方面，在服务器不需要先前信息时它的应答就较快。HTTP的url组成HTTP使用统一资源标识符（Uniform Resource Identifiers, URI）来传输数据和建立连接。URL是一种特殊类型的URI，包含了用于查找某个资源的足够的信息 URL全称是UniformResourceLocator, 中文叫统一资源定位符,是互联网上用来标识某一处资源的地址。以下面这个URL为例，介绍下普通URL的各部分组成：http://www.aspxfans.com:8080/news/index.asp?boardID=5&amp;ID=24618&amp;page=1#name 从上面的URL可以看出，一个完整的URL包括以下几部分：1.协议部分：该URL的协议部分为“http：”，这代表网页使用的是HTTP协议。在Internet中可以使用多种协议，如HTTP，FTP等等本例中使用的是HTTP协议。在”HTTP”后面的“//”为分隔符2.域名部分：该URL的域名部分为“www.aspxfans.com”。一个URL中，也可以使用IP地址作为域名使用3.端口部分：跟在域名后面的是端口，域名和端口之间使用“:”作为分隔符。端口不是一个URL必须的部分，如果省略端口部分，将采用默认端口4.虚拟目录部分：从域名后的第一个“/”开始到最后一个“/”为止，是虚拟目录部分。虚拟目录也不是一个URL必须的部分。本例中的虚拟目录是“/news/”5.文件名部分：从域名后的最后一个“/”开始到“？”为止，是文件名部分，如果没有“?”,则是从域名后的最后一个“/”开始到“#”为止，是文件部分，如果没有“？”和“#”，那么从域名后的最后一个“/”开始到结束，都是文件名部分。本例中的文件名是“index.asp”。文件名部分也不是一个URL必须的部分，如果省略该部分，则使用默认的文件名6.锚部分：从“#”开始到最后，都是锚部分。本例中的锚部分是“name”。锚部分也不是一个URL必须的部分7.参数部分：从“？”开始到“#”为止之间的部分为参数部分，又称搜索部分、查询部分。本例中的参数部分为“boardID=5&amp;ID=24618&amp;page=1”。参数可以允许有多个参数，参数与参数之间用“&amp;”作为分隔符。 HTTP之请求消息Requesthttp请求由三部分组成，分别是：请求行、消息报头、请求正文 请求行请求行以一个方法符号开头，以空格分开，后面跟着请求的URI和协议的版本。GET： 请求获取Request-URI所标识的资源POST： 在Request-URI所标识的资源后附加新的数据HEAD： 请求获取由Request-URI所标识的资源的响应消息报头PUT： 请求服务器存储一个资源，并用Request-URI作为其标识DELETE： 请求服务器删除Request-URI所标识的资源TRACE： 请求服务器回送收到的请求信息，主要用于测试或诊断CONNECT： 保留将来使用OPTIONS： 请求查询服务器的性能，或者查询与资源相关的选项和需求 通过一个简单的Socket来看看这个 import java.io.IOException; import java.io.InputStream; import java.io.InputStreamReader; import java.net.ServerSocket; import java.net.Socket; public class Test { public static void main(String[] args) throws IOException { // 服务器监听端口号9999 ServerSocket serverSocket = new ServerSocket(9999); // 等待接收请求，这是一个阻塞的方法，当请求到来的时候才会继续向下执行 Socket socket = serverSocket.accept(); // 获取请求内容 InputStream is = socket.getInputStream(); InputStreamReader reader = new InputStreamReader(is); // 输出请求内容 while (true) { System.out.print((char)reader.read()); } } } 然后运行main方法。在浏览器中输入http://localhost:9999/test?lijia=1231控制台会输出下面的结果： 请求行（第2行）：（请求方法GET，请求资源/test?lijia=1231，HTTP版本1.1）请求头部（第3-10行）：紧接着请求行（即第2行）之后的部分，用来说明服务器要使用的附加信息空行（第11行）：请求头部后面的空行是必须的请求数据（空行之后的）：为空，也必须有空行。这个例子的请求数据为空。 下图用POST传递：和GET差不多，不过请求数据放到最下面了 HTTP之响应消息ResponseHTTP响应也是由四个部分组成，分别是：状态行、消息报头、空行和响应正文 状态行：，由HTTP协议版本号， 状态码， 状态消息 三部分组成。第一行为状态行，（HTTP/1.1）表明HTTP版本为1.1版本，状态码为200，状态消息为（ok）消息报头：用来说明客户端要使用的一些附加信息第二行和第三行为消息报头，Date:生成响应的日期和时间；Content-Type:指定了MIME类型的HTML(text/html),编码类型是UTF-8空行：消息报头后面的空行是必须的响应正文：服务器返回给客户端的文本信息。空行后面的html部分为响应正文。 其中状态代码有三位数字组成，第一个数字定义了响应的类别，且有五种可能取值：1xx：指示信息–表示请求已接收，继续处理2xx：成功–表示请求已被成功接收、理解、接受3xx：重定向–要完成请求必须进行更进一步的操作4xx：客户端错误–请求有语法错误或请求无法实现5xx：服务器端错误–服务器未能实现合法的请求常见状态码： 200 OK //客户端请求成功 400 Bad Request //客户端请求有语法错误，不能被服务器所理解 401 Unauthorized //请求未经授权，这个状态代码必须和WWW-Authenticate报头域一起使用 403 Forbidden //服务器收到请求，但是拒绝提供服务 404 Not Found //请求资源不存在，eg：输入了错误的URL 500 Internal Server Error //服务器发生不可预期的错误 503 Server Unavailable //服务器当前不能处理客户端的请求，一段时间后可能恢复正常 更多状态码请看看 http://www.runoob.com/http/http-status-codes.html HTTP工作原理一次HTTP操作称为一个事务，其工作整个过程如下： 1）、地址解析 如用客户端浏览器请求这个页面：http://localhost.com:8080/index.htm 从中分解出协议名、主机名、端口、对象路径等部分，对于我们的这个地址，解析得到的结果如下： 协议名：http 主机名：localhost.com 端口：8080 对象路径：/index.html 在这一步，需要域名系统DNS解析域名localhost.com,得主机的IP地址。 2）、封装HTTP请求数据包 把以上部分结合本机自己的信息，封装成一个HTTP请求数据包 3）封装成TCP包，建立TCP连接（TCP的三次握手） 在HTTP工作开始之前，客户机（Web浏览器）首先要通过网络与服务器建立连接，该连接是通过TCP来完成的，该协议与IP协议共同构建Internet，即著名的TCP/IP协议族，因此Internet又被称作是TCP/IP网络。HTTP是比TCP更高层次的应用层协议，根据规则，只有低层协议建立之后才能，才能进行更层协议的连接，因此，首先要建立TCP连接，一般TCP连接的端口号是80。这里是8080端口 4）客户机发送请求命令 建立连接后，客户机发送一个请求给服务器，请求方式的格式为：统一资源标识符（URL）、协议版本号，后边是MIME信息包括请求修饰符、客户机信息和可内容。 5）服务器响应 服务器接到请求后，给予相应的响应信息，其格式为一个状态行，包括信息的协议版本号、一个成功或错误的代码，后边是MIME信息包括服务器信息、实体信息和可能的内容。 实体消息是服务器向浏览器发送头信息后，它会发送一个空白行来表示头信息的发送到此为结束，接着，它就以Content-Type应答头信息所描述的格式发送用户所请求的实际数据 6）服务器关闭TCP连接 一般情况下，一旦Web服务器向浏览器发送了请求数据，它就要关闭TCP连接，然后如果浏览器或者服务器在其头信息加入了这行代码 Connection:keep-alive TCP连接在发送后将仍然保持打开状态，于是，浏览器可以继续通过相同的连接发送请求。保持连接节省了为每个请求建立新连接所需的时间，还节约了网络带宽。 7） 服务器将响应信息传给客户端响应体中的内容可能是一个html页面，也可能是一张图片，通过输入流将其读出，并写回到显示器上。 用netty实现http的文件服务HttpServer启动类import io.netty.bootstrap.ServerBootstrap; import io.netty.channel.ChannelFuture; import io.netty.channel.ChannelInitializer; import io.netty.channel.EventLoopGroup; import io.netty.channel.nio.NioEventLoopGroup; import io.netty.channel.socket.SocketChannel; import io.netty.channel.socket.nio.NioServerSocketChannel; import io.netty.handler.codec.http.HttpObjectAggregator; import io.netty.handler.codec.http.HttpRequestDecoder; import io.netty.handler.codec.http.HttpResponseEncoder; import io.netty.handler.stream.ChunkedWriteHandler; public class HttpServer { private static final String DEFAULT_URL = &quot;/src/&quot;; public static void main(String[] args) { int port = 8888; String url = DEFAULT_URL; if(args.length &gt; 1){ url = args[1]; } new HttpServer().connect(port, url); } private void connect(int port, final String url) { EventLoopGroup bossGroup = new NioEventLoopGroup(); EventLoopGroup workerGroup = new NioEventLoopGroup(); try{ ServerBootstrap b = new ServerBootstrap(); b.group(bossGroup, workerGroup).channel(NioServerSocketChannel.class) .childHandler(new ChannelInitializer&lt;SocketChannel&gt;() { @Override protected void initChannel(SocketChannel ch) throws Exception { ch.pipeline().addLast(&quot;http-decoder&quot;, new HttpRequestDecoder()); ch.pipeline().addLast(&quot;http-aggregator&quot;, new HttpObjectAggregator(65536)); ch.pipeline().addLast(&quot;http-encoder&quot;, new HttpResponseEncoder()); ch.pipeline().addLast(&quot;http-chunked&quot;, new ChunkedWriteHandler()); ch.pipeline().addLast(&quot;fileServerHandler&quot;, new HttpFileServerHandler(url)); } }); ChannelFuture f = b.bind(&quot;localhost&quot;,port).sync(); System.out.println(&quot;HTTP 文件服务器启动, 地址是： &quot; + &quot;http://localhost:&quot; + port + url); f.channel().closeFuture().sync(); } catch (InterruptedException e) { e.printStackTrace(); } finally{ bossGroup.shutdownGracefully(); workerGroup.shutdownGracefully(); } } } HttpFileServerHandler（业务处理）import io.netty.buffer.ByteBuf; import io.netty.buffer.Unpooled; import io.netty.channel.*; import io.netty.handler.codec.http.*; import io.netty.handler.stream.ChunkedFile; import io.netty.util.CharsetUtil; import javax.activation.MimetypesFileTypeMap; import java.io.File; import java.io.FileNotFoundException; import java.io.RandomAccessFile; import java.io.UnsupportedEncodingException; import java.net.URLDecoder; import java.util.regex.Pattern; public class HttpFileServerHandler extends SimpleChannelInboundHandler&lt;FullHttpRequest&gt;{ private final String url; public HttpFileServerHandler(String url) { this.url = url; } @Override protected void messageReceived(ChannelHandlerContext ctx, FullHttpRequest request) throws Exception { //对解码结果进行判断 if(!request.decoderResult().isSuccess()) { sendError(ctx, HttpResponseStatus.BAD_REQUEST); return; } //判断是不是GET方法 if(request.method() != HttpMethod.GET) { sendError(ctx, HttpResponseStatus.METHOD_NOT_ALLOWED); return; } final String uri = request.uri(); //将uri解码 final String path = sanitizeUri(uri); if(path == null) { sendError(ctx, HttpResponseStatus.FORBIDDEN); return; } File file = new File(path); //文件隐藏或者不存在 if(file.isHidden() || !file.exists()) { sendError(ctx, HttpResponseStatus.NOT_FOUND); return; } //是不是一个目录 if(file.isDirectory()) { if(uri.endsWith(&quot;/&quot;)) { sendListing(ctx, file); }else{ sendRedirect(ctx, uri + &quot;/&quot;); } return; } //不是文件 if(!file.isFile()) { sendError(ctx, HttpResponseStatus.FORBIDDEN); return; } RandomAccessFile randomAccessFile = null; try{ randomAccessFile = new RandomAccessFile(file, &quot;r&quot;); }catch(FileNotFoundException fnfd){ sendError(ctx, HttpResponseStatus.NOT_FOUND); return; } //获取文件长度 long fileLength = randomAccessFile.length(); HttpResponse response = new DefaultHttpResponse(HttpVersion.HTTP_1_1, HttpResponseStatus.OK); HttpHeaderUtil.setContentLength(response, fileLength); setContentTypeHeader(response, file); if(HttpHeaderUtil.isKeepAlive(request)){ response.headers().set(HttpHeaderNames.CONNECTION, HttpHeaderValues.KEEP_ALIVE); } ctx.write(response); ChannelFuture sendFileFuture = null; sendFileFuture = ctx.write(new ChunkedFile(randomAccessFile, 0, fileLength, 8192), ctx.newProgressivePromise()); sendFileFuture.addListener(new ChannelProgressiveFutureListener() { @Override public void operationComplete(ChannelProgressiveFuture future) throws Exception { System.out.println(&quot;Transfer complete.&quot;); } @Override public void operationProgressed(ChannelProgressiveFuture future, long progress, long total) throws Exception { if(total &lt; 0){ System.err.println(&quot;Transfer progress: &quot; + progress); } else{ System.err.println(&quot;Transfer progress: &quot; + progress + &quot;/&quot; + total); } } }); ChannelFuture lastContentFuture = ctx.writeAndFlush(LastHttpContent.EMPTY_LAST_CONTENT); if(!HttpHeaderUtil.isKeepAlive(request)){ lastContentFuture.addListener(ChannelFutureListener.CLOSE); } } @Override public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception { cause.printStackTrace(); if(ctx.channel().isActive()){ sendError(ctx, HttpResponseStatus.INTERNAL_SERVER_ERROR); } } private static final Pattern INSECURE_URI = Pattern.compile(&quot;.*[&lt;&gt;&amp;\&quot;].*&quot;); private String sanitizeUri(String uri){ try{ uri = URLDecoder.decode(uri, &quot;UTF-8&quot;); }catch(UnsupportedEncodingException e){ try{ uri = URLDecoder.decode(uri, &quot;ISO-8859-1&quot;); }catch(UnsupportedEncodingException e1){ throw new Error(); } } if(!uri.startsWith(url)){ return null; } if(!uri.startsWith(&quot;/&quot;)){ return null; } uri = uri.replace(&apos;/&apos;, File.separatorChar); if(uri.contains(File.separator + &apos;.&apos;) || uri.contains(&apos;.&apos; + File.separator) || uri.startsWith(&quot;.&quot;) || uri.endsWith(&quot;.&quot;) || INSECURE_URI.matcher(uri).matches()){ return null; } return System.getProperty(&quot;user.dir&quot;) + File.separator + uri; } private static final Pattern ALLOWED_FILE_NAME = Pattern.compile(&quot;[A-Za-z0-9][-_A-Za-z0-9\\.]*&quot;); //返回并显示 private static void sendListing(ChannelHandlerContext ctx, File dir){ FullHttpResponse response = new DefaultFullHttpResponse(HttpVersion.HTTP_1_1, HttpResponseStatus.OK); response.headers().set(HttpHeaderNames.CONTENT_TYPE, &quot;text/html;charset=UTF-8&quot;); String dirPath = dir.getPath(); StringBuilder buf = new StringBuilder(); buf.append(&quot;&lt;!DOCTYPE html&gt;\r\n&quot;); buf.append(&quot;&lt;html&gt;&lt;head&gt;&lt;title&gt;&quot;); buf.append(dirPath); buf.append(&quot;目录:&quot;); buf.append(&quot;&lt;/title&gt;&lt;/head&gt;&lt;body&gt;\r\n&quot;); buf.append(&quot;&lt;h3&gt;&quot;); buf.append(dirPath).append(&quot; 目录：&quot;); buf.append(&quot;&lt;/h3&gt;\r\n&quot;); buf.append(&quot;&lt;ul&gt;&quot;); buf.append(&quot;&lt;li&gt;链接：&lt;a href=\&quot; ../\&quot;)..&lt;/a&gt;&lt;/li&gt;\r\n&quot;); for (File f : dir.listFiles()) { if(f.isHidden() || !f.canRead()) { continue; } String name = f.getName(); if (!ALLOWED_FILE_NAME.matcher(name).matches()) { continue; } buf.append(&quot;&lt;li&gt;链接：&lt;a href=\&quot;&quot;); buf.append(name); buf.append(&quot;\&quot;&gt;&quot;); buf.append(name); buf.append(&quot;&lt;/a&gt;&lt;/li&gt;\r\n&quot;); } buf.append(&quot;&lt;/ul&gt;&lt;/body&gt;&lt;/html&gt;\r\n&quot;); ByteBuf buffer = Unpooled.copiedBuffer(buf,CharsetUtil.UTF_8); response.content().writeBytes(buffer); buffer.release(); ctx.writeAndFlush(response).addListener(ChannelFutureListener.CLOSE); } private static void sendRedirect(ChannelHandlerContext ctx, String newUri){ FullHttpResponse response = new DefaultFullHttpResponse(HttpVersion.HTTP_1_1, HttpResponseStatus.FOUND); response.headers().set(HttpHeaderNames.LOCATION, newUri); ctx.writeAndFlush(response).addListener(ChannelFutureListener.CLOSE); } private static void sendError(ChannelHandlerContext ctx, HttpResponseStatus status){ FullHttpResponse response = new DefaultFullHttpResponse(HttpVersion.HTTP_1_1, status, Unpooled.copiedBuffer(&quot;Failure: &quot; + status.toString() + &quot;\r\n&quot;, CharsetUtil.UTF_8)); response.headers().set(HttpHeaderNames.CONTENT_TYPE, &quot;text/html;charset=UTF-8&quot;); ctx.writeAndFlush(response).addListener(ChannelFutureListener.CLOSE); } private static void setContentTypeHeader(HttpResponse response, File file){ MimetypesFileTypeMap mimetypesFileTypeMap = new MimetypesFileTypeMap(); response.headers().set(HttpHeaderNames.CONTENT_TYPE, mimetypesFileTypeMap.getContentType(file.getPath())); } } 然后启动HttpServer，控制台会出现 然后输入 http://localhost:8888/src/ ，会显示 看看上面的代码在HttpServer中加入了 ch.pipeline().addLast(&quot;http-decoder&quot;, new HttpRequestDecoder()); ch.pipeline().addLast(&quot;http-aggregator&quot;, new HttpObjectAggregator(65536)); ch.pipeline().addLast(&quot;http-encoder&quot;, new HttpResponseEncoder()); ch.pipeline().addLast(&quot;http-chunked&quot;, new ChunkedWriteHandler()); ch.pipeline().addLast(&quot;fileServerHandler&quot;, new HttpFileServerHandler(url)); 加入了请求消息解码器。HttpObjectAggregator这个作用是将多个消息转化成单一的FullHttpRequest或者FullHttpResponse。业务处理放在HttpFileServerHandler中]]></content>
      <categories>
        <category>netty</category>
      </categories>
      <tags>
        <tag>netty</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[netty编解码技术]]></title>
    <url>%2F2017%2F10%2F17%2Fnetty%E7%BC%96%E8%A7%A3%E7%A0%81%E6%8A%80%E6%9C%AF%2F</url>
    <content type="text"><![CDATA[java序列化序列化是干什么的为了保存在内存中的各种对象的状态（也就是实例变量，不是方法），并且可以把保存的对象状态再读出来。虽然你可以用你自己的各种各样的方法来保存object states，但是Java给你提供一种应该比你自己好的保存对象状态的机制，那就是序列化。 java序列化之后码流太大首先通过一个列子来看看 import java.io.ByteArrayOutputStream; import java.io.IOException; import java.io.ObjectOutputStream; import java.io.Serializable; import java.nio.ByteBuffer; public class UserInfo implements Serializable { /** * 默认的序列号 */ private static final long serialVersionUID = 1L; private String userName; private int id; public UserInfo buildUserName(String userName) { this.userName = userName; return this; } public UserInfo buildUserID(int id) { this.id = id; return this; } public final String getUserName() { return userName; } public final void setUserName(String userName) { this.userName = userName; } public final int getUserID() { return id; } public final void setUserID(int userID) { this.id = userID; } public byte[] codeC() { ByteBuffer buffer = ByteBuffer.allocate(1024); byte[] value = this.userName.getBytes(); buffer.putInt(value.length); buffer.put(value); buffer.putInt(this.id); buffer.flip(); value = null; byte[] result = new byte[buffer.remaining()]; buffer.get(result); return result; } public byte[] codeC(ByteBuffer buffer) { buffer.clear(); byte[] value = this.userName.getBytes(); buffer.putInt(value.length); buffer.put(value); buffer.putInt(this.id); buffer.flip(); value = null; byte[] result = new byte[buffer.remaining()]; buffer.get(result); return result; } public static void main(String[] args) throws IOException { System.out.println(&quot;------------大小----------&quot;); UserInfo info = new UserInfo(); info.buildUserID(100).buildUserName(&quot;Welcome to Netty&quot;); ByteArrayOutputStream bos = new ByteArrayOutputStream(); ObjectOutputStream os = new ObjectOutputStream(bos); os.writeObject(info); os.flush(); os.close(); byte[] b = bos.toByteArray(); System.out.println(&quot;The jdk serializable length is : &quot; + b.length); bos.close(); System.out.println(&quot;-------------------------------------&quot;); System.out.println(&quot;The byte array serializable length is : &quot; + info.codeC().length); System.out.println(&quot;------------时间----------&quot;); UserInfo info1 = new UserInfo(); info1.buildUserID(100).buildUserName(&quot;Welcome to Netty&quot;); int loop = 1000000; ByteArrayOutputStream bos1 = null; ObjectOutputStream os1 = null; long startTime = System.currentTimeMillis(); for (int i = 0; i &lt; loop; i++) { bos1 = new ByteArrayOutputStream(); os1 = new ObjectOutputStream(bos1); os1.writeObject(info1); os1.flush(); os1.close(); byte[] b1 = bos.toByteArray(); bos.close(); } long endTime = System.currentTimeMillis(); System.out.println(&quot;The jdk serializable cost time is : &quot; + (endTime - startTime) + &quot; ms&quot;); System.out.println(&quot;-------------------------------------&quot;); ByteBuffer buffer1 = ByteBuffer.allocate(1024); startTime = System.currentTimeMillis(); for (int i = 0; i &lt; loop; i++) { byte[] b1 = info.codeC(buffer1); } endTime = System.currentTimeMillis(); System.out.println(&quot;The byte array serializable cost time is : &quot; + (endTime - startTime) + &quot; ms&quot;); } } 运行结果是： 上面是两个测试结果前面都是默认序列化之后的数据大小和序列化的时间，下面都是使用NIO的编解码去对对象进行编码。可以看出默认的Serializable 接口还有一些瑕疵。 编码框架MessagePack编解码MessagePack的特点： 编解码高效，性能高 序列化之后的码流小 支持跨语言简单使用：POJO:需要加上@Message import org.msgpack.annotation.Message; @Message public class Student { private int id; private String name; public int getId() { return id; } public void setId(int id) { this.id = id; } public String getName() { return name; } public void setName(String name) { this.name = name; } @Override public String toString() { return &quot;Student [id=&quot; + id + &quot;, name=&quot; + name + &quot;]&quot;; } } 测试类： Student student = new Student(); student.setId(1); student.setName(&quot;lijia&quot;); MessagePack messagePack = new MessagePack(); try { byte[] write = messagePack.write(student); Value read = messagePack.read(write); System.out.println(read); } catch (IOException e) { e.printStackTrace(); } 运行结果： Protobuf编解码这个我弄了一天，找到一个windows版本的，但是在电脑上运行不了。大致了解一下吧1 .proto文件相当于确定数据协议，数据结构中存在哪些数据，数据类型是怎么样2 modifiers 2-1 required 不可以增加或删除的字段，必须初始化 2-2 optional 可选字段，可删除，可以不初始化 2-3 repeated 可重复字段， 对应到java文件里，生成的是List 3 Message在proto文件里，数据的协议时以Message的形式表现的。4 Build生成具体的java类时，例如Person.java，同时会存在build方法。文档的意思是对于转化后的数据，具有唯一性，build提供了便利的方法来初始化这些数据。这个先放着，以后回头好好研究这个协议。 Marshalling编解码由于Marshalling完全兼容java序列化。调用jboss的API对对象进行编解码。首先要引入jboss-marshalling的jar包。下面的代码是marshalling编解码 public final class MarshallingCodeCFactory { /** * 创建Jboss Marshalling解码器MarshallingDecoder * * @return */ public static MarshallingDecoder buildMarshallingDecoder() { final MarshallerFactory marshallerFactory = Marshalling .getProvidedMarshallerFactory(&quot;serial&quot;); final MarshallingConfiguration configuration = new MarshallingConfiguration(); configuration.setVersion(5); UnmarshallerProvider provider = new DefaultUnmarshallerProvider( marshallerFactory, configuration); MarshallingDecoder decoder = new MarshallingDecoder(provider, 1024); return decoder; } /** * 创建Jboss Marshalling编码器MarshallingEncoder * * @return */ public static MarshallingEncoder buildMarshallingEncoder() { final MarshallerFactory marshallerFactory = Marshalling .getProvidedMarshallerFactory(&quot;serial&quot;); final MarshallingConfiguration configuration = new MarshallingConfiguration(); configuration.setVersion(5); MarshallerProvider provider = new DefaultMarshallerProvider( marshallerFactory, configuration); MarshallingEncoder encoder = new MarshallingEncoder(provider); return encoder; } } 用法：还是以client为例 public class SubReqClient { public void connect(int port, String host) throws Exception { // 配置客户端NIO线程组 EventLoopGroup group = new NioEventLoopGroup(); try { Bootstrap b = new Bootstrap(); b.group(group).channel(NioSocketChannel.class) .option(ChannelOption.TCP_NODELAY, true) .handler(new ChannelInitializer&lt;SocketChannel&gt;() { @Override public void initChannel(SocketChannel ch) throws Exception { ch.pipeline().addLast(MarshallingCodeCFactory.buildMarshallingDecoder()); ch.pipeline().addLast(MarshallingCodeCFactory.buildMarshallingEncoder()); ch.pipeline().addLast(new SubReqClientHandler()); } }); // 发起异步连接操作 ChannelFuture f = b.connect(host, port).sync(); // 当代客户端链路关闭 f.channel().closeFuture().sync(); } finally { // 优雅退出，释放NIO线程组 group.shutdownGracefully(); } } /** * @param args * @throws Exception */ public static void main(String[] args) throws Exception { int port = 8080; if (args != null &amp;&amp; args.length &gt; 0) { try { port = Integer.valueOf(args[0]); } catch (NumberFormatException e) { // 采用默认值 } } new SubReqClient().connect(port, &quot;127.0.0.1&quot;); } } 还是在initChannel这个方法中添加 ch.pipeline().addLast(MarshallingCodeCFactory.buildMarshallingDecoder()); ch.pipeline().addLast(MarshallingCodeCFactory.buildMarshallingEncoder()); 服务端和这个一样。注意的是Marshalling支持拆包的处理。 总结性能对比 框架 字节大小（byte） 序列化时间 反序列化时间 messagepack 12793 2313335 529458 protebuf 6590 941790 408571 json 17181 1338371 1776519 讲了3中序列化框架和jdk自带的区别：MessagePack：在反序列化耗内存大小方面，msgpack远远超出json（1.6倍），由于内存是移动客户端场景下的重要指标，因此基本可以排除msgpack。protebuf：缺点是不支持半包处理，其余的都比megpack好marshalling：这个自带半包处理]]></content>
      <categories>
        <category>netty</category>
      </categories>
      <tags>
        <tag>netty</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[netty粘包拆包]]></title>
    <url>%2F2017%2F10%2F13%2Fnetty%E7%B2%98%E5%8C%85%E6%8B%86%E5%8C%85%2F</url>
    <content type="text"><![CDATA[什么是TCP粘包/拆包首先了解什么是长连接和短连接长连接： Client方与Server方先建立通讯连接，连接建立后不断开， 然后再进行报文发送和接收。短连接：Client方与Server每进行一次报文收发交易时才进行通讯连接，交易完毕后立即断开连接。 什么时候会出现粘包问题 如果用tcp每次发送数据，就与对方建立连接，然后双方发送完一段数据后，就关闭连接，这样就不会出现粘包问题（因为只有一种包结构,类似于http协议）。关闭连接主要要双方都发送close连接（参考tcp关闭协议）。如：A需要发送一段字符串给B，那么A与B建立连接，然后发送双方都默认好的协议字符如”hello，world”，然后B收到报文后，就将缓冲区数据接收,然后关闭连接，这样粘包问题不用考虑到，因为大家都知道是发送一段字符。 如果发送数据无结构，如文件传输，这样发送方只管发送，接收方只管接收存储就ok，也不用考虑粘包 在流传输中出现，UDP不会出现粘包，因为它有消息边界 如果双方建立连接，需要在连接后一段时间内发送不同结构数据，如连接后，有好几种结构： (1)：”Hello，world” (2)：”Hello，lijia”如果发送方连续将这两个包都发出去了，接收方接受的信息可能是”Hello，worldHello，lijia“。这就需要拆包，所以双方应该规定一个较好的包结构，所以一般可能会在头加一个数据长度之类的包，以确保接收。所以：粘包出现原因1 发送端需要等缓冲区满才发送出去，造成粘包2 接收方不及时接收缓冲区的包，造成多个包接收下面的图显示几种可能性 客服端发送两个包给服务端，服务端读取字节数不确定，可能是上面三种情况： a、分别获取两个独立的包，不存在粘包，拆包的情况 b、一次获取两个完整的数据包，这就是粘包 c、第一次获取D1和部分D2数据，第二次获取D2剩余内容，这就是拆包 还有一种可能，就是多次拆包，即服务端接收划窗小，而D1，D2又比较大 粘包的解决策略1、发送端给每个数据包添加包首部，首部中应该至少包含数据包的长度，这样接收端在接收到数据后，通过读取包首部的长度字段，便知道每一个数据包的实际长度了。2、发送端将每个数据包封装为固定长度（不够的可以通过补0填充），这样接收端每次从接收缓冲区中读取固定长度的数据就自然而然的把每个数据包拆分开来。3、可以在数据包之间设置边界，如添加特殊符号，这样，接收端通过这个边界就可以将不同的数据包拆分开。4、其他首先模拟去看着这个问题TimeServer import io.netty.bootstrap.ServerBootstrap; import io.netty.channel.ChannelFuture; import io.netty.channel.ChannelInitializer; import io.netty.channel.ChannelOption; import io.netty.channel.EventLoopGroup; import io.netty.channel.nio.NioEventLoopGroup; import io.netty.channel.socket.SocketChannel; import io.netty.channel.socket.nio.NioServerSocketChannel; public class TimeServer { public void bind(int port) throws Exception { // 配置服务端的NIO线程组 EventLoopGroup bossGroup = new NioEventLoopGroup(); EventLoopGroup workerGroup = new NioEventLoopGroup(); try { ServerBootstrap b = new ServerBootstrap(); b.group(bossGroup, workerGroup) .channel(NioServerSocketChannel.class) .option(ChannelOption.SO_BACKLOG, 1024) .childHandler(new ChildChannelHandler()); // 绑定端口，同步等待成功 ChannelFuture f = b.bind(port).sync(); // 等待服务端监听端口关闭 f.channel().closeFuture().sync(); } finally { // 优雅退出，释放线程池资源 bossGroup.shutdownGracefully(); workerGroup.shutdownGracefully(); } } private class ChildChannelHandler extends ChannelInitializer&lt;SocketChannel&gt; { @Override protected void initChannel(SocketChannel arg0) throws Exception { arg0.pipeline().addLast(new TimeServerHandler()); } } /** * @param args * @throws Exception */ public static void main(String[] args) throws Exception { int port = 8080; if (args != null &amp;&amp; args.length &gt; 0) { try { port = Integer.valueOf(args[0]); } catch (NumberFormatException e) { // 采用默认值 } } new TimeServer().bind(port); } }TimeServerHandler import io.netty.buffer.ByteBuf; import io.netty.buffer.Unpooled; import io.netty.channel.ChannelHandlerAdapter; import io.netty.channel.ChannelHandlerContext; public class TimeServerHandler extends ChannelHandlerAdapter { private int counter; @Override public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception { ByteBuf buf = (ByteBuf) msg; byte[] req = new byte[buf.readableBytes()]; buf.readBytes(req); String body = new String(req, &quot;UTF-8&quot;).substring(0, req.length - System.getProperty(&quot;line.separator&quot;).length()); System.out.println(&quot;The time server receive order : &quot; + body + &quot; ; the counter is : &quot; + ++counter); String currentTime = &quot;QUERY TIME ORDER&quot;.equalsIgnoreCase(body) ? new java.util.Date( System.currentTimeMillis()).toString() : &quot;BAD ORDER&quot;; currentTime = currentTime + System.getProperty(&quot;line.separator&quot;); ByteBuf resp = Unpooled.copiedBuffer(currentTime.getBytes()); ctx.writeAndFlush(resp); } @Override public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) { ctx.close(); } }TimeClient import io.netty.bootstrap.Bootstrap; import io.netty.channel.ChannelFuture; import io.netty.channel.ChannelInitializer; import io.netty.channel.ChannelOption; import io.netty.channel.EventLoopGroup; import io.netty.channel.nio.NioEventLoopGroup; import io.netty.channel.socket.SocketChannel; import io.netty.channel.socket.nio.NioSocketChannel; public class TimeClient { public void connect(int port, String host) throws Exception { // 配置客户端NIO线程组 EventLoopGroup group = new NioEventLoopGroup(); try { Bootstrap b = new Bootstrap(); b.group(group).channel(NioSocketChannel.class) .option(ChannelOption.TCP_NODELAY, true) .handler(new ChannelInitializer&lt;SocketChannel&gt;() { @Override public void initChannel(SocketChannel ch) throws Exception { ch.pipeline().addLast(new TimeClientHandler()); } }); // 发起异步连接操作 ChannelFuture f = b.connect(host, port).sync(); // 当代客户端链路关闭 f.channel().closeFuture().sync(); } finally { // 优雅退出，释放NIO线程组 group.shutdownGracefully(); } } /** * @param args * @throws Exception */ public static void main(String[] args) throws Exception { int port = 8080; if (args != null &amp;&amp; args.length &gt; 0) { try { port = Integer.valueOf(args[0]); } catch (NumberFormatException e) { // 采用默认值 } } new TimeClient().connect(port, &quot;127.0.0.1&quot;); } }TimeClientHandler import io.netty.buffer.ByteBuf; import io.netty.buffer.Unpooled; import io.netty.channel.ChannelHandlerAdapter; import io.netty.channel.ChannelHandlerContext; import java.util.logging.Logger; public class TimeClientHandler extends ChannelHandlerAdapter { private static final Logger logger = Logger .getLogger(TimeClientHandler.class.getName()); private int counter; private byte[] req; /** * Creates a client-side handler. */ public TimeClientHandler() { req = (&quot;QUERY TIME ORDER&quot; + System.getProperty(&quot;line.separator&quot;)) .getBytes(); } @Override public void channelActive(ChannelHandlerContext ctx) { ByteBuf message = null; for (int i = 0; i &lt; 100; i++) { message = Unpooled.buffer(req.length); message.writeBytes(req); ctx.writeAndFlush(message); } } @Override public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception { ByteBuf buf = (ByteBuf) msg; byte[] req = new byte[buf.readableBytes()]; buf.readBytes(req); String body = new String(req, &quot;UTF-8&quot;); System.out.println(&quot;Now is : &quot; + body + &quot; ; the counter is : &quot; + ++counter); } @Override public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) { // 释放资源 logger.warning(&quot;Unexpected exception from downstream : &quot; + cause.getMessage()); ctx.close(); } }执行结果： 服务端收到2条消息，理论上是100条，发生了粘包。客户端也只收到了2条消息 Netty如何去处理这个问题呢LineBasedFrameDecoder在上面代码的TimeServer和ClientServer的initChannel方法中，分别加上 arg0.pipeline().addLast(new LineBasedFrameDecoder(1024)); arg0.pipeline().addLast(new StringDecoder()); 和 ch.pipeline().addLast(new LineBasedFrameDecoder(1024)); ch.pipeline().addLast(new StringDecoder());如下图： 然后将TimeServerHandler和TimeClientHandler中channelRead方法的获取body字符串改成TimeServerHandler中修改： public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception { String body = (String) msg; System.out.println(&quot;The time server receive order : &quot; + body + &quot; ; the counter is : &quot; + ++counter); String currentTime = &quot;QUERY TIME ORDER&quot;.equalsIgnoreCase(body) ? new java.util.Date( System.currentTimeMillis()).toString() : &quot;BAD ORDER&quot;; currentTime = currentTime + System.getProperty(&quot;line.separator&quot;); ByteBuf resp = Unpooled.copiedBuffer(currentTime.getBytes()); ctx.writeAndFlush(resp); } TimeClientHandler中修改： @Override public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception { String body = (String) msg; System.out.println(&quot;Now is : &quot; + body + &quot; ; the counter is : &quot; + ++counter); } 那么再执行代码，会出现 这就是正确结果。 LineBasedFrameDecoder的原理LineBasedFrameDecoder的工作原理就是依次遍历ByteBuf中的可读字节，判断是否有”\n“或者”\r\n”，如果有，就以此为结束位置，从可读索引到结束位置区间的字节组成了一个字符串。它是以换行符为结束标志的解码器，支持携带结束符或者不携带两种方式，支持配置单行的最大长度。如果读到最大长度还没有发现换行符，就会抛出异常。同时忽略之前读到的字节。如果不是以换行结束呢，怎么解决？ DelimiterBasedFrameDecoderEchoServer : import io.netty.bootstrap.ServerBootstrap; import io.netty.buffer.ByteBuf; import io.netty.buffer.Unpooled; import io.netty.channel.ChannelFuture; import io.netty.channel.ChannelInitializer; import io.netty.channel.ChannelOption; import io.netty.channel.EventLoopGroup; import io.netty.channel.nio.NioEventLoopGroup; import io.netty.channel.socket.SocketChannel; import io.netty.channel.socket.nio.NioServerSocketChannel; import io.netty.handler.codec.DelimiterBasedFrameDecoder; import io.netty.handler.codec.string.StringDecoder; import io.netty.handler.logging.LogLevel; import io.netty.handler.logging.LoggingHandler; public class EchoServer { public void bind(int port) throws Exception { // 配置服务端的NIO线程组 EventLoopGroup bossGroup = new NioEventLoopGroup(); EventLoopGroup workerGroup = new NioEventLoopGroup(); try { ServerBootstrap b = new ServerBootstrap(); b.group(bossGroup, workerGroup) .channel(NioServerSocketChannel.class) .option(ChannelOption.SO_BACKLOG, 100) .handler(new LoggingHandler(LogLevel.INFO)) .childHandler(new ChannelInitializer&lt;SocketChannel&gt;() { @Override public void initChannel(SocketChannel ch) throws Exception { ByteBuf delimiter = Unpooled.copiedBuffer(&quot;$_&quot; .getBytes()); ch.pipeline().addLast( new DelimiterBasedFrameDecoder(1024, delimiter)); ch.pipeline().addLast(new StringDecoder()); ch.pipeline().addLast(new EchoServerHandler()); } }); // 绑定端口，同步等待成功 ChannelFuture f = b.bind(port).sync(); // 等待服务端监听端口关闭 f.channel().closeFuture().sync(); } finally { // 优雅退出，释放线程池资源 bossGroup.shutdownGracefully(); workerGroup.shutdownGracefully(); } } public static void main(String[] args) throws Exception { int port = 8080; if (args != null &amp;&amp; args.length &gt; 0) { try { port = Integer.valueOf(args[0]); } catch (NumberFormatException e) { // 采用默认值 } } new EchoServer().bind(port); } } EchoServerHandler : import io.netty.buffer.ByteBuf; import io.netty.buffer.Unpooled; import io.netty.channel.ChannelHandler.Sharable; import io.netty.channel.ChannelHandlerAdapter; import io.netty.channel.ChannelHandlerContext; @Sharable public class EchoServerHandler extends ChannelHandlerAdapter { int counter = 0; @Override public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception { String body = (String) msg; System.out.println(&quot;This is &quot; + ++counter + &quot; times receive client : [&quot; + body + &quot;]&quot;); body += &quot;$_&quot;; ByteBuf echo = Unpooled.copiedBuffer(body.getBytes()); ctx.writeAndFlush(echo); } @Override public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) { cause.printStackTrace(); ctx.close();// 发生异常，关闭链路 } } EchoClient : import io.netty.bootstrap.Bootstrap; import io.netty.buffer.ByteBuf; import io.netty.buffer.Unpooled; import io.netty.channel.ChannelFuture; import io.netty.channel.ChannelInitializer; import io.netty.channel.ChannelOption; import io.netty.channel.EventLoopGroup; import io.netty.channel.nio.NioEventLoopGroup; import io.netty.channel.socket.SocketChannel; import io.netty.channel.socket.nio.NioSocketChannel; import io.netty.handler.codec.DelimiterBasedFrameDecoder; import io.netty.handler.codec.string.StringDecoder; public class EchoClient { public void connect(int port, String host) throws Exception { // 配置客户端NIO线程组 EventLoopGroup group = new NioEventLoopGroup(); try { Bootstrap b = new Bootstrap(); b.group(group).channel(NioSocketChannel.class) .option(ChannelOption.TCP_NODELAY, true) .handler(new ChannelInitializer&lt;SocketChannel&gt;() { @Override public void initChannel(SocketChannel ch) throws Exception { ByteBuf delimiter = Unpooled.copiedBuffer(&quot;$_&quot; .getBytes()); ch.pipeline().addLast( new DelimiterBasedFrameDecoder(1024, delimiter)); ch.pipeline().addLast(new StringDecoder()); ch.pipeline().addLast(new EchoClientHandler()); } }); // 发起异步连接操作 ChannelFuture f = b.connect(host, port).sync(); // 当代客户端链路关闭 f.channel().closeFuture().sync(); } finally { // 优雅退出，释放NIO线程组 group.shutdownGracefully(); } } /** * @param args * @throws Exception */ public static void main(String[] args) throws Exception { int port = 8080; if (args != null &amp;&amp; args.length &gt; 0) { try { port = Integer.valueOf(args[0]); } catch (NumberFormatException e) { // 采用默认值 } } new EchoClient().connect(port, &quot;127.0.0.1&quot;); } } TimeClientHandler : import io.netty.buffer.Unpooled; import io.netty.channel.ChannelHandlerAdapter; import io.netty.channel.ChannelHandlerContext; public class TimeClientHandler extends ChannelHandlerAdapter { private int counter; static final String ECHO_REQ = &quot;Hi, Lilinfeng. Welcome to Netty.$_&quot;; /** * Creates a client-side handler. */ public TimeClientHandler () { } @Override public void channelActive(ChannelHandlerContext ctx) { // ByteBuf buf = UnpooledByteBufAllocator.DEFAULT.buffer(ECHO_REQ // .getBytes().length); // buf.writeBytes(ECHO_REQ.getBytes()); for (int i = 0; i &lt; 10; i++) { ctx.writeAndFlush(Unpooled.copiedBuffer(ECHO_REQ.getBytes())); } } @Override public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception { System.out.println(&quot;This is &quot; + ++counter + &quot; times receive server : [&quot;+ msg + &quot;]&quot;); } @Override public void channelReadComplete(ChannelHandlerContext ctx) throws Exception { ctx.flush(); } @Override public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) { cause.printStackTrace(); ctx.close(); } } 运行之后出现 如果把EchoServer的ch.pipeline().addLast(new DelimiterBasedFrameDecoder(1024,delimiter));注释掉那么server获取的字符串就是 由于没有分隔符解码器，导致了一次性读取客户端所有数据，就是典型的tcp粘包问题。 FixedLengthFrameDecoderEchoServer ： import io.netty.bootstrap.ServerBootstrap; import io.netty.channel.ChannelFuture; import io.netty.channel.ChannelInitializer; import io.netty.channel.ChannelOption; import io.netty.channel.EventLoopGroup; import io.netty.channel.nio.NioEventLoopGroup; import io.netty.channel.socket.SocketChannel; import io.netty.channel.socket.nio.NioServerSocketChannel; import io.netty.handler.codec.FixedLengthFrameDecoder; import io.netty.handler.codec.string.StringDecoder; import io.netty.handler.logging.LogLevel; import io.netty.handler.logging.LoggingHandler; public class EchoServer { public void bind(int port) throws Exception { // 配置服务端的NIO线程组 EventLoopGroup bossGroup = new NioEventLoopGroup(); EventLoopGroup workerGroup = new NioEventLoopGroup(); try { ServerBootstrap b = new ServerBootstrap(); b.group(bossGroup, workerGroup) .channel(NioServerSocketChannel.class) .option(ChannelOption.SO_BACKLOG, 100) .handler(new LoggingHandler(LogLevel.INFO)) .childHandler(new ChannelInitializer&lt;SocketChannel&gt;() { @Override public void initChannel(SocketChannel ch) throws Exception { ch.pipeline().addLast( new FixedLengthFrameDecoder(20)); ch.pipeline().addLast(new StringDecoder()); ch.pipeline().addLast(new EchoServerHandler()); } }); // 绑定端口，同步等待成功 ChannelFuture f = b.bind(port).sync(); // 等待服务端监听端口关闭 f.channel().closeFuture().sync(); } finally { // 优雅退出，释放线程池资源 bossGroup.shutdownGracefully(); workerGroup.shutdownGracefully(); } } public static void main(String[] args) throws Exception { int port = 8080; if (args != null &amp;&amp; args.length &gt; 0) { try { port = Integer.valueOf(args[0]); } catch (NumberFormatException e) { // 采用默认值 } } new EchoServer().bind(port); } } EchoServerHandler ： import io.netty.channel.ChannelHandler.Sharable; import io.netty.channel.ChannelHandlerAdapter; import io.netty.channel.ChannelHandlerContext; @Sharable public class EchoServerHandler extends ChannelHandlerAdapter { @Override public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception { System.out.println(&quot;Receive client : [&quot; + msg + &quot;]&quot;); } @Override public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) { cause.printStackTrace(); ctx.close();// 发生异常，关闭链路 } } 启动EchoServer然后从cmd中启动telnet localhost 8080,我以1234567890一直循环输入，但是由于FixedLengthFrameDecoder设置的大小为20，那么每次不超过20就不会返回，如果超过20，输出20个字符，剩下的以另一个包形式返回。 总结LineBasedFrameDecoder:以换行处理粘包DelimiterBasedFrameDecoder：设置固定的分隔符，然后解码去解决粘包问题FixedLengthFrameDecoder：对固定长度的消息进行自动解码]]></content>
      <categories>
        <category>netty</category>
      </categories>
      <tags>
        <tag>netty</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[netty入门]]></title>
    <url>%2F2017%2F10%2F13%2Fnetty%E5%85%A5%E9%97%A8%2F</url>
    <content type="text"><![CDATA[什么是nettyNetty 是一个基于 JAVA NIO 类库的异步通信框架，它的架构特点是：异步非阻塞、基于事件驱动、高性能、高可靠性和高可定制性。 Netty 能够做什么 开发异步、非阻塞的 TCP 网络应用程序； 开发异步、非阻塞的 UDP 网络应用程序； 开发异步文件传输应用程序； 开发异步 HTTP 服务端和客户端应用程序； 提供对多种编解码框架的集成，包括谷歌的 Protobuf、Jbossmarshalling、Java 序列化、压缩编解码、XML 解码、字符串编解码等，这些编解码框架可以被用户直接使用； 提供形式多样的编解码基础类库，可以非常方便的实现私有协议栈编解码框架的二次定制和开发； 基于职责链模式的 Pipeline-Handler 机制，用户可以非常方便的对网络事件进行拦截和定制； 所有的 IO 操作都是异步的，用户可以通过 Future-Listener 机制主动 Get 结果或者由 IO 线程操作完成之后主动 Notify 结果，用户的业务线程不需要同步等待； IP 黑白名单控制； 打印消息码流； 流量控制和整形； 性能统计； 基于链路空闲事件检测的心跳检测 …… Netty总体结构 Netty网络模型Netty是典型的Reactor模型结构。Netty中的Reactor模型主要由多路复用器(Acceptor)、事件分发器(Dispatcher)、事件处理器(Handler)组成，可以分为三种。 单线程模型所有I/O操作都由一个线程完成，即多路复用、事件分发和处理都是在一个Reactor线程上完成的。 对于一些小容量应用场景，可以使用单线程模型。但是对于高负载、大并发的应用却不合适，主要原因如下： 一个线程同时处理成百上千的链路，性能上无法支撑，即便CPU负荷达到100%，也无法满足海量消息的编码、解码、读取和发送； 当负载过重后，处理速度将变慢，这会导致大量客户端连接超时，超时之后往往会进行重发，最终会导致大量消息积压和处理超时，成为系统的性能瓶颈； 一旦单线程意外跑飞，或者进入死循环，会导致整个系统通信模块不可用，不能接收和处理外部消息，造成节点故障，可靠性不高。多线程模型为了解决单线程模型存在的一些问题，演化而来的Reactor线程模型。 多线程模型的特点： 有专门一个Acceptor线程用于监听服务端，接收客户端的TCP连接请求； 网络IO的读写操作由一个NIO线程池负责，线程池可以采用标准的JDK线程池实现，包含一个任务队列和N个可用的线程，由这些NIO线程负责消息的读取、解码、编码和发送； 一个NIO线程可以同时处理多条链路，但是一个链路只能对应一个NIO线程，防止发生并发操作问题。 在绝大多数场景下，Reactor多线程模型都可以满足性能需求；但是，在极特殊应用场景中，一个NIO线程负责监听和处理所有的客户端连接可能会存在性能问题。例如百万客户端并发连接，或者服务端需要对客户端的握手消息进行安全认证，认证本身非常损耗性能。在这类场景下，单独一个Acceptor线程可能会存在性能不足问题，为了解决性能问题，产生了第三种Reactor线程模型-主从Reactor多线程模型。 主从多线程模型采用多个reactor，每个reactor都在自己单独的线程里执行。如果是多核，则可以同时响应多个客户端的请求，一旦链路建立成功就将链路注册到负责I/O读写的SubReactor线程池上。 事实上，Netty的线程模型并非固定不变，在启动辅助类中创建不同的EventLoopGroup实例并通过适当的参数配置，就可以支持上述三种Reactor线程模型。正是因为Netty对Reactor线程模型的支持提供了灵活的定制能力，所以可以满足不同业务场景的性能需求。 入门实例在用netty之前，先看看NIO的步骤 创建ServerSocketChannel，配置它为非阻塞模式 绑定监听，配置TCP参数，例如backlog大小 创建一个独立的I/O线程，用于轮询多路复用器Selector 创建Selector，将之前创建的ServerSocketChannel注册到Selector上，监听SelectKey.ACCEPT 启动I/O线程，在循环体中执行Selector.select()方法，轮询就绪的Channel 当轮询到就绪状态的Channel时，需要对其进行判断，如果是OP_APPECT状态，说明是新客户端接入，则调用ServerSocketChannel.accept()方法接受新的客户端 设置新接入的客户端链路SocketChannel为非阻塞模式，配置其他的一些TCP参数 将SocketChannel注册到Selector，监听OP_READ操作位 如果轮询的Channel为OP_READ，则说明SocketChannel中有新的就绪的数据包需要读取，则构造ByteBuffer对象，读取数据包。 如果轮询的Channel为OP_WRITE，说明还有数据没有发送完，需要继续发送用netty来做呢，还是用李林峰老师的代码来理解，netty版本是 &lt;dependency&gt; &lt;groupId&gt;io.netty&lt;/groupId&gt; &lt;artifactId&gt;netty-all&lt;/artifactId&gt; &lt;version&gt;5.0.0.Alpha1&lt;/version&gt; &lt;/dependency&gt; 服务端TimeServer： import io.netty.bootstrap.ServerBootstrap; import io.netty.channel.ChannelFuture; import io.netty.channel.ChannelInitializer; import io.netty.channel.ChannelOption; import io.netty.channel.EventLoopGroup; import io.netty.channel.nio.NioEventLoopGroup; import io.netty.channel.socket.SocketChannel; import io.netty.channel.socket.nio.NioServerSocketChannel; public class TimeServer { public void bind(int port) throws Exception { // 配置服务端的NIO两个线程组，其实就是Reactor线程组。 //创建两个的原因就是一个是服务器接收客户端的连接，一个是进行SocketChannel网络读写 EventLoopGroup bossGroup = new NioEventLoopGroup(); EventLoopGroup workerGroup = new NioEventLoopGroup(); try { //这个b对象是netty用于启动NIO服务端的辅助启动类，目的是降低服务器端的开发复杂度 ServerBootstrap b = new ServerBootstrap(); //将两个线程组当参数传递到启动类中 b.group(bossGroup, workerGroup) //设置Channel为NioServerSocketChannel，对应的就是JDK中的ServerSocketChannel .channel(NioServerSocketChannel.class) //设置TCP参数，即backlog为1024 .option(ChannelOption.SO_BACKLOG, 1024) //绑定I/O事件的处理类ChildChannelHandler .childHandler(new ChildChannelHandler()); // 绑定端口，同步等待成功 ChannelFuture f = b.bind(port).sync(); // 异步阻塞，等待服务端监听端口关闭 f.channel().closeFuture().sync(); } finally { // 优雅退出，释放线程池资源 bossGroup.shutdownGracefully(); workerGroup.shutdownGracefully(); } } private class ChildChannelHandler extends ChannelInitializer&lt;SocketChannel&gt; { @Override protected void initChannel(SocketChannel arg0) throws Exception { arg0.pipeline().addLast(new TimeServerHandler()); } } /** * @param args * @throws Exception */ public static void main(String[] args) throws Exception { int port = 8080; if (args != null &amp;&amp; args.length &gt; 0) { try { port = Integer.valueOf(args[0]); } catch (NumberFormatException e) { // 采用默认值 } } new TimeServer().bind(port); } } TimeServerHandler： import io.netty.buffer.ByteBuf; import io.netty.buffer.Unpooled; import io.netty.channel.ChannelHandlerAdapter; import io.netty.channel.ChannelHandlerContext; //继承了ChannelHandlerAdapter，用于网络事件的读写操作 public class TimeServerHandler extends ChannelHandlerAdapter { public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception { ByteBuf buf = (ByteBuf) msg; //buf.readableBytes()获取缓冲区可读的字节数，并根据可读的字节数创建数组 byte[] req = new byte[buf.readableBytes()]; //复制到新的数组 buf.readBytes(req); //获取请求信息 String body = new String(req, &quot;UTF-8&quot;); System.out.println(&quot;The time server receive order : &quot; + body); //如果是QUERY TIME ORDER创建应答信息并返回给客户端 String currentTime = &quot;QUERY TIME ORDER&quot;.equalsIgnoreCase(body) ? new java.util.Date( System.currentTimeMillis()).toString() : &quot;BAD ORDER&quot;; ByteBuf resp = Unpooled.copiedBuffer(currentTime.getBytes()); ctx.write(resp); } public void channelReadComplete(ChannelHandlerContext ctx) throws Exception { //将消息发送队列中的消息写到SocketChannel中发送给对方 ctx.flush(); } @Override public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) { //发送异常时关闭 ctx.close(); } } 客户端TimeClient： import io.netty.bootstrap.Bootstrap; import io.netty.channel.ChannelFuture; import io.netty.channel.ChannelInitializer; import io.netty.channel.ChannelOption; import io.netty.channel.EventLoopGroup; import io.netty.channel.nio.NioEventLoopGroup; import io.netty.channel.socket.SocketChannel; import io.netty.channel.socket.nio.NioSocketChannel; public class TimeClient { public void connect(int port, String host) throws Exception { // 配置客户端NIO线程组，这个和server一样 EventLoopGroup group = new NioEventLoopGroup(); try { Bootstrap b = new Bootstrap(); b.group(group).channel(NioSocketChannel.class) .option(ChannelOption.TCP_NODELAY, true) .handler(new ChannelInitializer&lt;SocketChannel&gt;() { @Override public void initChannel(SocketChannel ch) throws Exception { ch.pipeline().addLast(new TimeClientHandler()); } }); // 发起异步连接操作，调用sync等待连接成功 ChannelFuture f = b.connect(host, port).sync(); // 当代客户端链路关闭 f.channel().closeFuture().sync(); } finally { // 优雅退出，释放NIO线程组 group.shutdownGracefully(); } } /** * @param args * @throws Exception */ public static void main(String[] args) throws Exception { int port = 8080; if (args != null &amp;&amp; args.length &gt; 0) { try { port = Integer.valueOf(args[0]); } catch (NumberFormatException e) { // 采用默认值 } } new TimeClient().connect(port, &quot;127.0.0.1&quot;); } } TimeClientHandler ： import io.netty.buffer.ByteBuf; import io.netty.buffer.Unpooled; import io.netty.channel.ChannelHandlerAdapter; import io.netty.channel.ChannelHandlerContext; import java.util.logging.Logger; public class TimeClientHandler extends ChannelHandlerAdapter { private static final Logger logger = Logger .getLogger(TimeClientHandler.class.getName()); private final ByteBuf firstMessage; /** * Creates a client-side handler. */ public TimeClientHandler() { byte[] req = &quot;QUERY TIME ORDER&quot;.getBytes(); firstMessage = Unpooled.buffer(req.length); firstMessage.writeBytes(req); } //当客户端和服务端的TCP链路建立成功之后，会调用该方法，发送查询时间的指令给服务器 public void channelActive(ChannelHandlerContext ctx) { ctx.writeAndFlush(firstMessage); } //当服务器返回应答信息时，该方法被调用，从netty的ByteBuf中读取并打印应答信息 public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception { ByteBuf buf = (ByteBuf) msg; byte[] req = new byte[buf.readableBytes()]; buf.readBytes(req); String body = new String(req, &quot;UTF-8&quot;); System.out.println(&quot;Now is : &quot; + body); } @Override public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) { // 发生异常，打印异常日志，释放客户端资源 logger.warning(&quot;Unexpected exception from downstream : &quot; + cause.getMessage()); ctx.close(); } } 运行结果是：]]></content>
      <categories>
        <category>netty</category>
      </categories>
      <tags>
        <tag>netty</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Selector]]></title>
    <url>%2F2017%2F10%2F12%2FSelector%2F</url>
    <content type="text"><![CDATA[选择器的概念Selector是Java NIO中的一个组件，用于检查一个或多个NIO Channel的状态是否处于可读、可写。如此可以实现单线程管理多个channels,也就是可以管理多个网络链接。 为什么要用选择器用单线程处理多个channels的好处是我需要更少的线程来处理channel。实际上，你甚至可以用一个线程来处理所有的channels。从操作系统的角度来看，切换线程开销是比较昂贵的，并且每个线程都需要占用系统资源，因此用的线程越少越好。但是现在的操作系统和CPU内核已经越来越好了（不在此说了）。通过一个图来表示一个线程管理selector Selector操作创建SelectorSelector selector = Selector.open(); 注册Channel到Selector上为了将Channel和Selector配合使用，必须将Channel注册到Selector上。通过SelectableChannel.register()来实现，如下 channel.configureBlocking(false); SelectionKey key = channel.register(selector, Selectionkey.OP_READ); Channel必须是非阻塞的。所以FileChannel不适用Selector，因为FileChannel不能切换为非阻塞模式。Socket channel可以正常使用。注意register()的第二个参数，这是一个interest集合，意思啥通过Selector监听Channel对什么事件感兴趣，可以监听四种不通类型的事件： Connect(SelectionKey.OP_CONNECT) Accept(SelectionKey.OP_ACCEPT) Read(SelectionKey.OP_READ) Writer(SelectionKey.OP_WRITE) 如果对多个事件感兴趣可利用位的或运算结合多个常量 int interestSet = SelectionKey.OP_READ | SelectionKey.OP_WRITE; SelectionKey代表了Secletor和SelectableChannel的注册关系 key.attachment(); //返回SelectionKey的attachment，attachment可以在注册channel的时候指定。 key.channel(); // 返回该SelectionKey对应的channel。 key.selector(); // 返回该SelectionKey对应的Selector。 key.interestOps(); //返回代表需要Selector监控的IO操作的bit mask key.readyOps(); //返回一个bit mask，代表在相应channel上可以进行的IO操作。 key.attachment()可以将一个对象或者更多信息附着到SelectionKey上，这样就能方便的识别某个给定的通道。例如，可以附加 与通道一起使用的Buffer，或是包含聚集数据的某个对象。使用方法如下： selectionKey.attach(theObject); Object attachedObj = selectionKey.attachment(); 还可以在用register()方法向Selector注册Channel的时候附加对象 SelectionKey key = channel.register(selector, SelectionKey.OP_READ, theObject); key.channel() &amp;&amp; key.selector()从SelectionKey访问Channel和Selector很简单 Channel channel = selectionKey.channel(); Selector selector = selectionKey.selector(); key.interestOps()就像向Selector注册通道一节中所描述的，interest集合是你所选择的感兴趣的事件集合。可以通过SelectionKey读写interest集合 int interestSet = selectionKey.interestOps(); boolean isInterestedInAccept = (interestSet &amp; SelectionKey.OP_ACCEPT) == SelectionKey.OP_ACCEPT； boolean isInterestedInConnect = interestSet &amp; SelectionKey.OP_CONNECT; boolean isInterestedInRead = interestSet &amp; SelectionKey.OP_READ; boolean isInterestedInWrite = interestSet &amp; SelectionKey.OP_WRITE; key.readyOps()ready 集合是通道已经准备就绪的操作的集合。在一次选择(Selection)之后，你会首先访问这个ready set。Selection将在下一小节进行解释。可以这样访问ready集合 int readySet = selectionKey.readyOps(); 可以用像检测interest集合那样的方法，来检测channel中什么事件或操作已经就绪。但是，也可以使用以下四个方法，它们都会返回一个布尔类型： selectionKey.isAcceptable(); selectionKey.isConnectable(); selectionKey.isReadable(); selectionKey.isWritable(); 通过Selector选择通道一旦向Selector注册了一或多个通道，就可以调用几个重载的select()方法。这些方法返回你所感兴趣的事件（如连接、接受、读或写）已经准备就绪的那些通道。换句话说，如果你对“读就绪”的通道感兴趣，select()方法会返回读事件已经就绪的那些通道。 int select() int select(long timeout) int selectNow() select()阻塞到至少有一个通道在你注册的事件上就绪了。 select(long timeout)和select()一样，除了最长会阻塞timeout毫秒(参数)。 selectNow()不会阻塞，不管什么通道就绪都立刻返回（译者注：此方法执行非阻塞的选择操作。如果自从前一次选择操作后，没有通道变成可选择的，则此方法直接返回零。）。 select()方法返回的int值表示有多少通道已经就绪。亦即，自上次调用select()方法后有多少通道变成就绪状态。如果调用select()方法，因为有一个通道变成就绪状态，返回了1，若再次调用select()方法，如果另一个通道就绪了，它会再次返回1。如果对第一个就绪的channel没有做任何操作，现在就有两个就绪的通道，但在每次select()方法调用之间，只有一个通道就绪了。 selectedKeys()一旦调用了select()方法，并且返回值表明有一个或更多个通道就绪了，然后可以通过调用selector的selectedKeys()方法，访问“已选择键集（selected key set）”中的就绪通道。如下所示： Set selectedKeys = selector.selectedKeys(); 可以遍历这个已选择的键集合来访问就绪的通道 Set selectedKeys = selector.selectedKeys(); Iterator keyIterator = selectedKeys.iterator(); while(keyIterator.hasNext()) { SelectionKey key = keyIterator.next(); if(key.isAcceptable()) { // a connection was accepted by a ServerSocketChannel. } else if (key.isConnectable()) { // a connection was established with a remote server. } else if (key.isReadable()) { // a channel is ready for reading } else if (key.isWritable()) { // a channel is ready for writing } keyIterator.remove(); } 这个循环遍历已选择键集中的每个键，并检测各个键所对应的通道的就绪事件。 注意每次迭代末尾的keyIterator.remove()调用。Selector不会自己从已选择键集中移除SelectionKey实例。必须在处理完通道时自己移除。下次该通道变成就绪时，Selector会再次将其放入已选择键集中。 SelectionKey.channel()方法返回的通道需要转型成你要处理的类型，如ServerSocketChannel或SocketChannel等。wakeUp() 某个线程调用select()方法后阻塞了，即使没有通道已经就绪，也有办法让其从select()方法返回。只要让其它线程在第一个线程调用select()方法的那个对象上调用Selector.wakeup()方法即可。阻塞在select()方法上的线程会立马返回。 如果有其它线程调用了wakeup()方法，但当前没有线程阻塞在select()方法上，下个调用select()方法的线程会立即“醒来（wake up）”。close() 用完Selector后调用其close()方法会关闭该Selector，且使注册到该Selector上的所有SelectionKey实例无效。通道本身并不会关闭。 完整的示例这里有一个完整的示例，打开一个Selector，注册一个通道注册到这个Selector上(通道的初始化过程略去),然后持续监控这个Selector的四种事件（接受，连接，读，写）是否就绪。 Selector selector = Selector.open(); channel.configureBlocking(false); SelectionKey key = channel.register(selector, SelectionKey.OP_READ); while(true) { int readyChannels = selector.select(); if(readyChannels == 0) continue; Set selectedKeys = selector.selectedKeys(); Iterator keyIterator = selectedKeys.iterator(); while(keyIterator.hasNext()) { SelectionKey key = keyIterator.next(); if(key.isAcceptable()) { // a connection was accepted by a ServerSocketChannel. } else if (key.isConnectable()) { // a connection was established with a remote server. } else if (key.isReadable()) { // a channel is ready for reading } else if (key.isWritable()) { // a channel is ready for writing } keyIterator.remove(); } } 引用李林峰老师《netty权威指南》的代码 server public class TimeServer { public static void main(String[] args) throws IOException { int port = 8080; if (args != null &amp;&amp; args.length &gt; 0) { try { port = Integer.valueOf(args[0]); } catch (NumberFormatException e) { // 采用默认值 } } MultiplexerTimeServer timeServer = new MultiplexerTimeServer(port); new Thread(timeServer, &quot;NIO-MultiplexerTimeServer-001&quot;).start(); } } class MultiplexerTimeServer implements Runnable { private Selector selector; private ServerSocketChannel servChannel; private volatile boolean stop; /** * 初始化多路复用器、绑定监听端口 * * @param port */ public MultiplexerTimeServer(int port) { try { selector = Selector.open(); servChannel = ServerSocketChannel.open(); servChannel.configureBlocking(false); servChannel.socket().bind(new InetSocketAddress(port), 1024); servChannel.register(selector, SelectionKey.OP_ACCEPT); System.out.println(&quot;The time server is start in port : &quot; + port); } catch (IOException e) { e.printStackTrace(); System.exit(1); } } public void stop() { this.stop = true; } /* * (non-Javadoc) * * @see java.lang.Runnable#run() */ public void run() { while (!stop) { try { selector.select(1000); Set&lt;SelectionKey&gt; selectedKeys = selector.selectedKeys(); Iterator&lt;SelectionKey&gt; it = selectedKeys.iterator(); SelectionKey key = null; while (it.hasNext()) { key = it.next(); it.remove(); try { handleInput(key); } catch (Exception e) { if (key != null) { key.cancel(); if (key.channel() != null) key.channel().close(); } } } } catch (Throwable t) { t.printStackTrace(); } } // 多路复用器关闭后，所有注册在上面的Channel和Pipe等资源都会被自动去注册并关闭，所以不需要重复释放资源 if (selector != null) try { selector.close(); } catch (IOException e) { e.printStackTrace(); } } private void handleInput(SelectionKey key) throws IOException { if (key.isValid()) { // 处理新接入的请求消息 if (key.isAcceptable()) { // Accept the new connection ServerSocketChannel ssc = (ServerSocketChannel) key.channel(); SocketChannel sc = ssc.accept(); sc.configureBlocking(false); // Add the new connection to the selector sc.register(selector, SelectionKey.OP_READ); } if (key.isReadable()) { // Read the data SocketChannel sc = (SocketChannel) key.channel(); ByteBuffer readBuffer = ByteBuffer.allocate(1024); int readBytes = sc.read(readBuffer); if (readBytes &gt; 0) { readBuffer.flip(); byte[] bytes = new byte[readBuffer.remaining()]; readBuffer.get(bytes); String body = new String(bytes, &quot;UTF-8&quot;); System.out.println(&quot;The time server receive order : &quot; + body); String currentTime = &quot;QUERY TIME ORDER&quot; .equalsIgnoreCase(body) ? new java.util.Date( System.currentTimeMillis()).toString() : &quot;BAD ORDER&quot;; doWrite(sc, currentTime); } else if (readBytes &lt; 0) { // 对端链路关闭 key.cancel(); sc.close(); } else ; // 读到0字节，忽略 } } } private void doWrite(SocketChannel channel, String response) throws IOException { if (response != null &amp;&amp; response.trim().length() &gt; 0) { byte[] bytes = response.getBytes(); ByteBuffer writeBuffer = ByteBuffer.allocate(bytes.length); writeBuffer.put(bytes); writeBuffer.flip(); channel.write(writeBuffer); } } } client public class TimeClient { public static void main(String[] args) { int port = 8080; if (args != null &amp;&amp; args.length &gt; 0) { try { port = Integer.valueOf(args[0]); } catch (NumberFormatException e) { // 采用默认值 } } new Thread(new TimeClientHandle(&quot;127.0.0.1&quot;, port), &quot;TimeClient-001&quot;) .start(); } } class TimeClientHandle implements Runnable { private String host; private int port; private Selector selector; private SocketChannel socketChannel; private volatile boolean stop; public TimeClientHandle(String host, int port) { this.host = host == null ? &quot;127.0.0.1&quot; : host; this.port = port; try { selector = Selector.open(); socketChannel = SocketChannel.open(); socketChannel.configureBlocking(false); } catch (IOException e) { e.printStackTrace(); System.exit(1); } } /* * (non-Javadoc) * * @see java.lang.Runnable#run() */ public void run() { try { doConnect(); } catch (IOException e) { e.printStackTrace(); System.exit(1); } while (!stop) { try { selector.select(1000); Set&lt;SelectionKey&gt; selectedKeys = selector.selectedKeys(); Iterator&lt;SelectionKey&gt; it = selectedKeys.iterator(); SelectionKey key = null; while (it.hasNext()) { key = it.next(); it.remove(); try { handleInput(key); } catch (Exception e) { if (key != null) { key.cancel(); if (key.channel() != null) key.channel().close(); } } } } catch (Exception e) { e.printStackTrace(); System.exit(1); } } // 多路复用器关闭后，所有注册在上面的Channel和Pipe等资源都会被自动去注册并关闭，所以不需要重复释放资源 if (selector != null) try { selector.close(); } catch (IOException e) { e.printStackTrace(); } } private void handleInput(SelectionKey key) throws IOException { if (key.isValid()) { // 判断是否连接成功 SocketChannel sc = (SocketChannel) key.channel(); if (key.isConnectable()) { if (sc.finishConnect()) { sc.register(selector, SelectionKey.OP_READ); doWrite(sc); } else System.exit(1);// 连接失败，进程退出 } if (key.isReadable()) { ByteBuffer readBuffer = ByteBuffer.allocate(1024); int readBytes = sc.read(readBuffer); if (readBytes &gt; 0) { readBuffer.flip(); byte[] bytes = new byte[readBuffer.remaining()]; readBuffer.get(bytes); String body = new String(bytes, &quot;UTF-8&quot;); System.out.println(&quot;Now is : &quot; + body); this.stop = true; } else if (readBytes &lt; 0) { // 对端链路关闭 key.cancel(); sc.close(); } else ; // 读到0字节，忽略 } } } private void doConnect() throws IOException { // 如果直接连接成功，则注册到多路复用器上，发送请求消息，读应答 if (socketChannel.connect(new InetSocketAddress(host, port))) { socketChannel.register(selector, SelectionKey.OP_READ); doWrite(socketChannel); } else socketChannel.register(selector, SelectionKey.OP_CONNECT); } private void doWrite(SocketChannel sc) throws IOException { byte[] req = &quot;QUERY TIME ORDER&quot;.getBytes(); ByteBuffer writeBuffer = ByteBuffer.allocate(req.length); writeBuffer.put(req); writeBuffer.flip(); sc.write(writeBuffer); if (!writeBuffer.hasRemaining()) System.out.println(&quot;Send order 2 server succeed.&quot;); } }]]></content>
      <categories>
        <category>NIO</category>
      </categories>
      <tags>
        <tag>Selector</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java面试之dubbo]]></title>
    <url>%2F2017%2F10%2F12%2Fjava%E9%9D%A2%E8%AF%95%E4%B9%8Bdubbo%2F</url>
    <content type="text"><![CDATA[什么是dubbodubbo是一个分布式框架，远程服务调用的分布式框架，其核心部分包含： **集群容错**：提供基于接口方法的透明远程过程调用，包括多协议支持，以及软负载均衡，失败容错，地址路由，动态配置等集群支持。 **远程通讯**： 提供对多种基于长连接的NIO框架抽象封装，包括多种线程模型，序列化，以及“请求-响应”模式的信息交换方式。 **自动发现**：基于注册中心目录服务，使服务消费方能动态的查找服务提供方，使地址透明，使服务提供方可以平滑增加或减少机器。 dubbo可以做什么 透明化的远程方法调用，就像调用本地方法一样调用远程方法，只需简单配置，没有任何API侵入。 软负载均衡及容错机制，可在内网替代F5等硬件负载均衡器，降低成本，减少单点。 服务自动注册与发现，不再需要写死服务提供方地址，注册中心基于接口名查询服务提供者的IP地址，并且能够平滑添加或删除服务提供者。 dubbo的架构 图中节点角色说明：Provider: 暴露服务的服务提供方。Consumer: 调用远程服务的服务消费方。Registry: 服务注册与发现的注册中心。Monitor: 统计服务的调用次调和调用时间的监控中心。Container: 服务运行容器。对于这些角色来说，其他都还好，Monitor可能猿友们前期使用会把它忽略，但是后期会发现它的作用十分明显哦，如服务的调用量越来越大，服务的容量问题就暴露出来，这个服务需要多少机器支撑？什么时候该加机器？为了解决这个问题，第一步，要将服务现在每天的调用量，响应时间，都统计出来，作为容量规划的参考指标。其次，要可以动态调整权重，在线上，将某台机器的权重一直加大，并在加大的过程中记录响应时间的变化，直到响应时间到达阀值，记录此时的访问量，再以此访问量乘以机器数反推总容量。 调用关系说明：0 服务容器负责启动，加载，运行服务提供者。1 服务提供者在启动时，向注册中心注册自己提供的服务。2 服务消费者在启动时，向注册中心订阅自己所需的服务。3 注册中心返回服务提供者地址列表给消费者，如果有变更，注册中心将基于长连接推送变更数据给消费者。4 服务消费者，从提供者地址列表中，基于软负载均衡算法，选一台提供者进行调用，如果调用失败，再选另一台调用。5 服务消费者和提供者，在内存中累计调用次数和调用时间，定时每分钟发送一次统计数据到监控中心。 dubbo的使用框架的搭建自己去google，有的博客讲的特别细。有的会在部署中出问题，有的会在打包出问题，这个需要多google去解决 dubbo的一些面试题dubbo默认使用什么通信协议dubbo共支持如下几种通信协议： dubbo:// Dubbo缺省协议采用单一长连接和NIO异步通讯，适合于小数据量大并发的服务调用，以及服务消费者机器数远大于服务提供者机器数的情况。 rmi:// RMI协议采用JDK标准的java.rmi.*实现，采用阻塞式短连接和JDK标准序列化方式 hessian:// http:// webservice:// thrift:// memcached:// redis:// 服务调用超时问题怎么解决dubbo在调用服务不成功时，默认是会重试两次的。这样在服务端的处理时间超过了设定的超时时间时，就会有重复请求，比如在发邮件时，可能就会发出多份重复邮件，执行注册请求时，就会插入多条重复的注册数据，那么怎么解决超时问题呢？1.对于核心的服务中心，去除dubbo超时重试机制，并重新评估设置超时时间。2.业务处理代码必须放在服务端，客户端只做参数验证和服务调用，不涉及业务流程处理代码配置：&lt;dubbo:provider delay=&quot;-1&quot; timeout=&quot;6000&quot; retries=&quot;0&quot;/&gt;当然Dubbo的重试机制其实是非常好的QOS保证，它的路由机制，是会帮你把超时的请求路由到其他机器上，而不是本机尝试，所以 dubbo的重试机器也能一定程度的保证服务的质量。但是请一定要综合线上的访问情况，给出综合的评估。 一般使用什么注册中心，还有其他的选择吗？Multicast注册中心 Zookeeper注册中心 Redis注册中心 Simple注册中心 正常情况下我们使用zookeeper注册中心 ZooKeeper的节点是通过像树一样的结构来进行维护的，并且每一个节点通过路径来标示以及访问。除此之外，每一个节点还拥有自身的一些信息，包括：数据、数据长度、创建时间、修改时间等等。 从这样一类既含有数据，又作为路径表标示的节点的特点中，可以看出，ZooKeeper的节点既可以被看做是一个文件，又可以被看做是一个目录，它同时具有二者的特点。为了简单我们可以Znode来表示所讨论的ZooKeeper节点。 具体地说，Znode维护着数据、ACL（access controllist，访问控制列表）、时间戳等交换版本号等数据结构，它通过对这些数据的管理来让缓存生效并且令协调更新。每当Znode中的数据更新后它所维护的版本号将增加，这非常类似于数据库中计数器时间戳的操作方式。 另外Znode还具有原子性操作的特点：命名空间中，每一个Znode的数据将被原子地读写。读操作将读取与Znode相关的所有数据，写操作将替换掉所有的数据。除此之外，每一个节点都有一个访问控制列表，这个访问控制列表规定了用户操作的权限。 ZooKeeper中同样存在临时节点。这些节点与session同时存在，当session生命周期结束，这些临时节点也将被删除。临时节点在某些场合也发挥着非常重要的作用。 了解了Zookeeper的命名空间和节点之后我们需要跟上一篇文章中提到的内部逻辑联系起来.在上篇介绍到的内部流程中,拿到这里看看Zookeeper是如何处理的,流程如下图: 1 当服务提供者启动时,Zookeeper向/dubbo/com.foo.BarService/providers目录下写入自己的URL地址。2 当服务消费者启动时,这时候有两个动作: 订阅/dubbo/com.foo.BarService/providers目录下的提供者URL地址。 并向/dubbo/com.foo.BarService/consumers目录下写入自己的URL地址。 3当监控中心启动时,订阅/dubbo/com.foo.BarService目录下的所有提供者和消费者URL地址。 默认使用什么序列化框架Dubbo默认使用的是Hessian序列化。hessian是一个采用二进制格式传输的服务框架，相对传统soap web service，更轻量，更快速。 Hessian原理与协议简析：http的协议约定了数据传输的方式，hessian也无法改变太多： 1) hessian中client与server的交互，基于http-post方式。 2) hessian将辅助信息，封装在http header中，比如“授权token”等，我们可以基于http-header来封装关于“安全校验”“meta数据”等。hessian提供了简单的&quot;校验&quot;机制。 3) 对于hessian的交互核心数据，比如“调用的方法”和参数列表信息，将通过post请求的body体直接发送，格式为字节流。 4) 对于hessian的server端响应数据，将在response中通过字节流的方式直接输出。 hessian的协议本身并不复杂，在此不再赘言；所谓协议(protocol)就是约束数据的格式，client按照协议将请求信息序列化成字节序列发送给server端，server端根据协议，将数据反序列化成“对象”，然后执行指定的方法，并将方法的返回值再次按照协议序列化成字节流，响应给client，client按照协议将字节流反序列话成”对象”。 服务提供者能实现失效踢出的原理 ConfigServer（配置中心）每个Server/Client之间会作一个实时的心跳检测（因为它们都是建立的Socket长连接），比如几秒钟检测一次。收集每个Server提供的服务的信息，每个Client的信息，整理出一个服务列表，如： serviceName serverAddressList clientAddressList UserService 192.168.0.1，192.168.0.2，192.168.0.3，192.168.0.4 172.16.0.1，172.16.0.2 ProductService 192.168.0.3，192.168.0.4，192.168.0.5，192.168.0.6 172.16.0.2，172.16.0.3 OrderService 192.168.0.10，192.168.0.12，192.168.0.5，192.168.0.6 172.16.0.3，172.16.0.4 当某个Server不可用，那么就更新受影响的服务对应的serverAddressList，即把这个Server从serverAddressList中踢出去（从地址列表中删除），同时将推送serverAddressList给这些受影响的服务的clientAddressList里面的所有Client。如：192.168.0.3挂了，那么UserService和ProductService的serverAddressList都要把192.168.0.3删除掉，同时把新的列表告诉对应的Client 172.16.0.1，172.16.0.2，172.16.0.3；当某个Client挂了，那么更新受影响的服务对应的clientAddressListConfigServer根据服务列表，就能提供一个web管理界面，来查看管理服务的提供者和使用者。新加一个Server时，由于它会主动与ConfigServer取得联系，而ConfigServer又会将这个信息主动发送给Client，所以新加一个Server时，只需要启动Server，然后几秒钟内，Client就会使用上它提供的服务 Client（调用服务的机器） 每个Client启动时，主动与ConfigServer建立Socket长连接，并将自己的IP等相应信息发送给ConfigServer。Client在使用服务的时候根据服务名称去ConfigServer中获取服务提供者信息（这样ConfigServer就知道某个服务是当前哪几个Client在使用），Client拿到这些服务提供者信息后，与它们都建立连接，后面就可以直接调用服务了，当有多个服务提供者的时候，Client根据一定的规则来进行负载均衡，如轮询，随机，按权重等。一旦Client使用的服务它对应的服务提供者有变化（服务提供者有新增，删除的情况），ConfigServer就会把最新的服务提供者列表推送给Client，Client就会依据最新的服务提供者列表重新建立连接，新增的提供者建立连接，删除的提供者丢弃连接 Server（真正提供服务的机器） 每个Server启动时，主动与ConfigServer建立Scoket长连接，并将自己的IP，提供的服务名称，端口等信息直接发送给ConfigServer，ConfigServer就会收集到每个Server提供的服务的信息。 优点： 只要在Client和Server启动的时候，ConfigServer是好的，服务就可调用了，如果后面ConfigServer挂了，那只影响ConfigServer挂了以后服务提供者有变化，而Client还无法感知这一变化。 Client每次调用服务是不经过ConfigServer的，Client只是与它建立联系，从它那里获取提供服务者列表而已 调用服务-负载均衡：Client调用服务时，可以根据规则在多个服务提供者之间轮流调用服务。 服务提供者-容灾：某一个Server挂了，Client依然是可以正确的调用服务的，当前提是这个服务有至少2个服务提供者，Client能很快的感知到服务提供者的变化，并作出相应反应。 服务提供者-扩展：添加一个服务提供者很容易，而且Client会很快的感知到它的存在并使用它。 服务上线怎么不影响旧版本dubbo的文档中说到： 当一个接口实现，出现不兼容升级时，可以用版本号过渡，版本号不同的服务相互间不引用。 在低压力时间段，先升级一半提供者为新版本，再将所有消费者升级为新版本，然后将剩下的一半提供者升级为新版本 &lt;dubbo:service interface=&quot;com.foo.BarService&quot; version=&quot;1.0.0&quot; /&gt; &lt;dubbo:service interface=&quot;com.foo.BarService&quot; version=&quot;2.0.0&quot; /&gt; &lt;dubbo:reference id=&quot;barService&quot; interface=&quot;com.foo.BarService&quot; version=&quot;1.0.0&quot; /&gt; &lt;dubbo:reference id=&quot;barService&quot; interface=&quot;com.foo.BarService&quot; version=&quot;2.0.0&quot; /&gt; 不区分版本：(2.2.0以上版本支持) &lt;dubbo:reference id=&quot;barService&quot; interface=&quot;com.foo.BarService&quot; version=&quot;*&quot; /&gt; dubbo协议下的单一长连接与多线程并发如何协同工作底层采用netty。 集群容错怎么做dubbo的容错方案当我们的系统中用到Dubbo的集群环境,因为各种原因在集群调用失败时，Dubbo提供了多种容错方案，缺省为failover重试。Dubbo的集群容错在这里想说说他是因为我们实际的项目中出现了此类的问题,因为依赖的第三方项目出现异常,导致dubbo调用超时,此时使用的是默认的集群容错方式,而配置的reties=’3’,这样前段系统连续掉用了三次服务。 通过上面dubbo架构图这里的Invoker是Provider的一个可调用Service的抽象，Invoker封装了Provider地址及Service接口信息。Directory代表多个Invoker，可以把它看成List，但与List不同的是，它的值可能是动态变化的，比如注册中心推送变更。Cluster将Directory中的多个Invoker伪装成一个Invoker，对上层透明，伪装过程包含了容错逻辑，调用失败后，重试另一个。Router负责从多个Invoker中按路由规则选出子集，比如读写分离，应用隔离等。LoadBalance负责从多个Invoker中选出具体的一个用于本次调用，选的过程包含了负载均衡算法，调用失败后，需要重选。集群容错模式：Failover Cluster失败自动切换，当出现失败，重试其它服务器。(缺省)通常用于读操作，但重试会带来更长延迟。可通过retries=”2”来设置重试次数(不含第一次)。正是文章刚开始说的那种情况.Failfast Cluster快速失败，只发起一次调用，失败立即报错。通常用于非幂等性的写操作，比如新增记录。Failsafe Cluster失败安全，出现异常时，直接忽略。通常用于写入审计日志等操作。Failback Cluster失败自动恢复，后台记录失败请求，定时重发。通常用于消息通知操作。Forking Cluster并行调用多个服务器，只要一个成功即返回。通常用于实时性要求较高的读操作，但需要浪费更多服务资源。可通过forks=”2”来设置最大并行数。Broadcast Cluster广播调用所有提供者，逐个调用，任意一台报错则报错。(2.1.0开始支持)通常用于通知所有提供者更新缓存或日志等本地资源信息。重试次数配置如：(failover集群模式生效)&lt;dubbo:serviceretries=&quot;2&quot;/&gt;或：&lt;dubbo:referenceretries=&quot;2&quot;/&gt;或：&lt;dubbo:reference&gt; &lt;dubbo:methodname=&quot;findFoo&quot;retries=&quot;2&quot;/&gt; &lt;/dubbo:reference&gt; 集群模式配置如：&lt;dubbo:servicecluster=&quot;failsafe&quot;/&gt;或：&lt;dubbo:referencecluster=&quot;failsafe&quot;/&gt; dubbo是如何实现负载均衡dubbo负载均衡策略：在集群负载均衡时，Dubbo提供了多种均衡策略，缺省为random随机调用。RandomLoadBalance随机，按权重设置随机概率。在一个截面上碰撞的概率高，但调用量越大分布越均匀，而且按概率使用权重后也比较均匀，有利于动态调整提供者权重。RoundRobin LoadBalance轮循，按公约后的权重设置轮循比率。存在慢的提供者累积请求问题，比如：第二台机器很慢，但没挂，当请求调到第二台时就卡在那，久而久之，所有请求都卡在调到第二台上。LeastActive LoadBalance最少活跃调用数，相同活跃数的随机，活跃数指调用前后计数差。使慢的提供者收到更少请求，因为越慢的提供者的调用前后计数差会越大。ConsistentHashLoadBalance一致性Hash，相同参数的请求总是发到同一提供者。当某一台提供者挂时，原本发往该提供者的请求，基于虚拟节点，平摊到其它提供者，不会引起剧烈变动。Dubbo的集群容错和负载均衡同样也是Dubbo本身的高级特性.正如我们在说自定义扩展的时候一样,这两个特征同样也可以进行自定义扩展,用户可以根据自己实际的需求来扩展他们从而满足项目的实际需求. 遇到的问题场景描述：客户端远程异步调用ServiceA，ServiceA在处理客户端请求的过程中需要远程同步调用ServiceB，ServiceA从ServiceB的响应中取数据时，得到的是null。对于上面的问题，解决办法有三个：1.方法调用两次 ServiceA调用ServiceB的地方写两次一样的调用，这个方法原理就像ServiceB调用ServiceC一样，即清除attachements。 这个方法最简单，但是可能对不了解的人来说，这块业务代码写重复了，会不小心删除掉，而且从写代码的角度来说，这个很鸡肋，所以不推荐。 2.修改Dubbo源码 修改AbstractInvoker第137行，改成每次都对async进行实际赋值， boolean isAsync = getUrl().getMethodParameter(invocation.getMethodName(), Constants.ASYNC_KEY, false); invocation.setAttachment(Constants.ASYNC_KEY, String.valueOf(isAsync)); 3.自定义Filter实现com.alibaba.dubbo.rpc.Filter，在RpcContext中清除这个async， @Activate(group = {Constants.PROVIDER}) public class AsyncFilter implements Filter { @Override public Result invoke(Invoker&lt;?&gt; invoker, Invocation invocation) throws RpcException { RpcContext.getContext().getAttachments().remove(Constants.ASYNC_KEY); return invoker.invoke(invocation); } } 同时在src/main/resources/META-INF/dubbo/下添加com.alibaba.dubbo.rpc.Filter文件，内容文件如下： asyncFilter=com.abc.filter.AsyncFilter根据n多的博客整理出来的一些，以后有其他东西再加进去]]></content>
      <categories>
        <category>面试</category>
      </categories>
      <tags>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Channel]]></title>
    <url>%2F2017%2F10%2F11%2FChannel%2F</url>
    <content type="text"><![CDATA[Channel基础Channel 用于在字节缓冲区和位于通道另一侧的实体（通常是一个文件或套接字）之间有效地传输数据。Java NIO的通道类似流，但又有些不同 既可以从通道中读取数据，也可以写数据到通道。但是流的读写通常是单向的 通道可以异步读写 通道中的数据通常总是要先读到一个Buffer，或者总是从Buffer中写入 Channel的源码 import java.io.Closeable; import java.io.IOException; public interface Channel extends Closeable { boolean isOpen();//打开通道 void close() throws IOException;//关闭通道 } Channel的实现类 FileChannel：从文件中读取数据DatagramChannel：能通过UDP读写网络中的数据SockeChannel：能通过TCP读写网络中的数据ServerSocketChannel：可以监听新进来的TCP连接，像WEB服务器那样。对每一个新进来的连接都会创建一个SocketChannel。 Channel的实例FileChannel读文件import java.io.RandomAccessFile; import java.nio.ByteBuffer; import java.nio.channels.FileChannel; public class FileChannelDemo{ public static void main(String[] args) throws Exception { RandomAccessFile rFile = new RandomAccessFile(&quot;D:\\test_gc.log&quot;,&quot;rw&quot;); //从文件中读取数据，打开通道 FileChannel inChannel = rFile.getChannel(); //创建48字节的缓冲区 ByteBuffer buf = ByteBuffer.allocate(48); //从通道读取数据到缓冲区 int bytesRead = inChannel.read(buf); while(bytesRead != -1){ //写模式改成读模式 buf.flip(); System.out.println(&quot;Read &quot;+bytesRead); while(buf.hasRemaining()){ System.out.println((char)buf.get()); System.out.println(buf.position()+&quot;=========&quot;); } buf.clear(); bytesRead = inChannel.read(buf); } rFile.close(); } } FileChannel写文件import java.io.RandomAccessFile; import java.nio.ByteBuffer; import java.nio.channels.FileChannel; public class FileChannelDemo{ public static void main(String[] args) throws Exception { String date = &quot;test insert...&quot;; RandomAccessFile rFile = new RandomAccessFile(&quot;D:\\test_gc.log&quot;,&quot;rw&quot;); //从文件中读取数据，打开通道 FileChannel inChannel = rFile.getChannel(); //创建48字节的缓冲区,如果分配4个字节，而date比较长，那么在buf.put的时候就会报错。 ByteBuffer buf = ByteBuffer.allocate(48); //指定position为文件大小的值，即在channel的末尾追加内容,如果没有，则直接覆盖原来的数据 inChannel.position(inChannel.size()); buf.clear(); buf.put(date.getBytes()); buf.flip(); while(buf.hasRemaining()) { inChannel.write(buf); } inChannel.close(); rFile.close(); } } DatagramChannel由于DatagramChannel通过UDP读取数据，需要一个接受方，和一个发送方。接收方代码： import java.io.IOException; import java.net.InetSocketAddress; import java.nio.ByteBuffer; import java.nio.channels.DatagramChannel; import java.nio.charset.Charset; public class Reveiver { public static void main(String[] args) { try { receive(); } catch (IOException e) { e.printStackTrace(); } } private static void receive() throws IOException{ //指定端口 DatagramChannel channel =DatagramChannel.open(); channel.socket().bind(new InetSocketAddress(10022)); ByteBuffer buffer =ByteBuffer.allocate(60); //接受数据 while(channel.receive(buffer)==null){ try { Thread.sleep(1000); } catch (InterruptedException e) { e.printStackTrace(); } } buffer.flip(); String recStr =Charset.forName(&quot;utf-8&quot;).newDecoder().decode(buffer).toString(); System.out.println(recStr); channel.close(); } } 发送方代码： import java.io.IOException; import java.net.InetSocketAddress; import java.nio.ByteBuffer; import java.nio.channels.DatagramChannel; public class Sender { public static void main(String[] args) { try { send(); } catch (IOException e) { e.printStackTrace(); } } private static void send() throws IOException{ DatagramChannel channel =DatagramChannel.open(); ByteBuffer buffer =ByteBuffer.wrap(&quot;测试DatagramChannel&quot;.getBytes(&quot;utf-8&quot;)); //通过send发送数据 channel.send(buffer, new InetSocketAddress(&quot;localhost&quot;,10022)); channel.close(); } } SocketChannel 和ServerSocketChannel可以用非阻塞的SocketChannel和ServerSocketChannel代替阻塞的Socket和ServerSocket。这个后期学到选择器的时候再具体研究。]]></content>
      <categories>
        <category>NIO</category>
      </categories>
      <tags>
        <tag>Channel</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Buffer]]></title>
    <url>%2F2017%2F10%2F10%2FBuffer%2F</url>
    <content type="text"><![CDATA[缓冲区缓冲区基础缓冲区概念缓冲区是包在一个对象内的基本数据元素数组。Buffer 类相比一个简单数组的优点是它将关于数据的数据内容和信息包含在一个单一的对象中。Buffer 类以及它专有的子类定义了一个用于处理数据缓冲区的 API。如下图，还有一些其他的子类这就不列举了 通过上图可以看出，都是基本类型对应的Buffer。上图的几个Buffer都提供了读和写的方法get()和put()。 属性所有的缓冲区都具有四个属性来提供关于其所包含的数据元素的信息。 容量（Capacity）：缓冲区能够容纳的数据元素的最大数量。这一容量在缓冲区创建时被设定，并且永远不能被改变。 上界（Limit）：缓冲区的第一个不能被读或写的元素。或者说，缓冲区中现存元素的计数。 位置（Position）：下一个要被读或写的元素的索引。位置会自动由相应的 get( )和 put( )函数更新。 标记（Mark）：一个备忘位置。调用 mark( )来设定 mark = postion。调用 reset( )设定 position = mark。标记在设定前是未定义的( undefined) 。 缓冲区的创建想要获得一个Buffer对象首先要进行分配。每一个Buffer类都有一个allocate()方法这是一个可储存100字符的CharBuffer CharBuffer buf = CharBuffer.allocate(100);或者用以下wrap方法 char [] myArray = new char [100]; CharBuffer charbuffer = CharBuffer.wrap (myArray);通过创建缓冲区我们再来看看capacity，limit，positioncapacity作为一个内存块，Buffer有一个固定的大小值,一般创建Buffer时初始化写入–&gt;ByteBuffer.allocate(capacity)，你只能往capacity里写byte、long、char等类型。一旦Buffer满了，需要将其清空（通过读数据或者清除数据）才能继续往里面写数据pisition当你写数据到Buffer中，position表示当前的位置。初始位置的position值为0，当一个byte、long等数据写到Buffer后，position会向前移动到下一个可插入数据的Buffer单元。position最大可为capacity-1(因为position的初始值为0)当读取数据时，也是从某个特定位置读，当Buffer从写模式切换到读模式，position会被重置为0，当从Buffer的position处读取数据时，position向前移动到下一个可读位置。limit在写模式中，Buffer的limit表示你最多往Buffer中写多少数据。写模式下，limit=capacity在读模式中，limit表示你最多能读多少数据。因此，当切换读模式，limit会被设置成写模式下的position值（你能读到之前写入的所有数据）如下图，我插入了1,2,3,4四个数据进这个Buffer 下面通过一个例子来看看 import java.nio.Buffer; import java.nio.ByteBuffer; import java.nio.CharBuffer; import java.nio.ByteOrder; public class BufferCharView { public static void main (String [] argv) throws Exception { ByteBuffer byteBuffer = ByteBuffer.allocate (7).order (ByteOrder.BIG_ENDIAN); CharBuffer charBuffer = byteBuffer.asCharBuffer( ); // Load the ByteBuffer with some bytes byteBuffer.put (0, (byte)0); byteBuffer.put (1, (byte)&apos;H&apos;); byteBuffer.put (2, (byte)0); byteBuffer.put (3, (byte)&apos;i&apos;); byteBuffer.put (4, (byte)0); byteBuffer.put (5, (byte)&apos;!&apos;); byteBuffer.put (6, (byte)0); println (byteBuffer); println (charBuffer); } // Print info about a buffer private static void println (Buffer buffer) { System.out.println (&quot;pos=&quot; + buffer.position( ) + &quot;, limit=&quot; + buffer.limit( ) + &quot;, capacity=&quot; + buffer.capacity( ) + &quot;: &apos;&quot; + buffer.toString( ) + &quot;&apos;&quot;); } } 运行结果： 函数Buffer的实现类自带了几个函数，也是我们经常用的flip()该方法是将Buffer从写模式切换到读模式。调用flip()方法会将position设回0，并将limit设置成之前position的值（position表示标记读的位置，limit表示之前写进多少个字节等—》现在能读多少个字节） public final Buffer flip() { limit = position; position = 0; mark = -1; return this; } rewind()Buffer.rewind()将position设回0，所以你可以重读Buffer中的所有数据。limit保持不变，仍然表示能从Buffer中读取多少个元素（byte、char等）。 public final Buffer rewind() { position = 0; mark = -1; return this; } clear()和compact()一旦读完Buffer中的数据，需要让Buffer准备好再次被写入，可以通过clear()或者compact()来完成。 如果调用的是clear()，position将被设为0，limit将被设为capacity的值，换句话说，Buffer被清空来，Buffer中的数据并未清除，只说这些标记告诉我们可以从哪里开始往Buffer中写数据了。如果里面还有数据，调用clear()，这些数据将被遗忘，意味着不再有任何标记会告诉你哪些数据被读过，哪些没有。 public final Buffer clear() { position = 0; limit = capacity; mark = -1; return this; } 如果Buffer中未读的数据，并且以后还需要，那么使用compact()方法。 compact方法将所有未读的数据copy到Buffer起始处，然后将position设到最后一个未读数据的后面。limit属性仍然和clear()方法一样，设置成capacity。现在Buffer准备好写数据了，但是不会覆盖未读的数据。mark()与reset()通过Buffer.mark()方法，可以标记Buffer中的一个特定的position，之后可以通过调用Buffer.reset()恢复到这个position。 public final Buffer mark() { mark = position; return this; } public final Buffer reset() { int m = mark; if (m &lt; 0) throw new InvalidMarkException(); position = m; return this; } 下面通过一个例子来看看mark和rest的方法 import java.io.BufferedInputStream; import java.io.ByteArrayInputStream; import java.io.IOException; public class MarkDemo { public static void main(String[] args) { try { // 初始化一个字节数组，内有5个字节的数据 byte[] bytes = { 1, 2, 3, 4, 5 }; // 用一个ByteArrayInputStream来读取这个字节数组 ByteArrayInputStream in = new ByteArrayInputStream(bytes); // 将ByteArrayInputStream包含在一个BufferedInputStream，并初始化缓冲区大小为2。 BufferedInputStream bis = new BufferedInputStream(in, 2); // 读取字节1 System.out.print(bis.read() + &quot;,&quot;); // 在字节2处做标记，同时设置readlimit参数为1 // 根据JAVA文档mark以后最多只能读取1个字节，否则mark标记失效，但实际运行结果不是这样 System.out.println(&quot;mark&quot;); bis.mark(1); /* * 连续读取两个字节，超过了readlimit的大小，mark标记仍有效 */ // 连续读取两个字节 System.out.print(bis.read() + &quot;,&quot;); System.out.print(bis.read() + &quot;,&quot;); // 调用reset方法，未发生异常，说明mark标记仍有效。 // 因为，虽然readlimit参数为1，但是这个BufferedInputStream类的缓冲区大小为2， // 所以允许读取2字节 System.out.println(&quot;reset&quot;); bis.reset(); /* * 连续读取3个字节，超过了缓冲区大小，mark标记失效。 * 在这个例子中BufferedInputStream类的缓冲区大小大于readlimit, mark标记由缓冲区大小决定 */ // reset重置后连续读取3个字节，超过了BufferedInputStream类的缓冲区大小 System.out.print(bis.read() + &quot;,&quot;); System.out.print(bis.read() + &quot;,&quot;); System.out.print(bis.read() + &quot;,&quot;); // 再次调用reset重置，抛出异常，说明mark后读取3个字节，mark标记失效 System.out.println(&quot;reset again&quot;); bis.reset(); } catch (IOException e) { // TODO Auto-generated catch block e.printStackTrace(); } } }]]></content>
      <categories>
        <category>NIO</category>
      </categories>
      <tags>
        <tag>NIO</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring源码之Autowired]]></title>
    <url>%2F2017%2F10%2F09%2FSpring%E6%BA%90%E7%A0%81%E4%B9%8BAutowired%2F</url>
    <content type="text"><![CDATA[#测试]]></content>
      <categories>
        <category>spring</category>
      </categories>
      <tags>
        <tag>spring Autowired</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[开篇]]></title>
    <url>%2F2017%2F09%2F27%2Ftest%2F</url>
    <content type="text"><![CDATA[开篇寄语一直想自己搭建一个博客，但是身为资深懒人，什么都不愿意去做，正好趁着闲时抓紧时间去做一下，不然肯定又拖了。主要分享一些工作中遇到的问题和一些面试问题。因为我本人是学java的，所以一般是java的代码。]]></content>
      <categories>
        <category>随笔</category>
      </categories>
  </entry>
</search>
